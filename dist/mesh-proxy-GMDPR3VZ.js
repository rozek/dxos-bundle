import{a as v,M as d,C as _,P as S,b as a,R as o,l as i,t as c,h as w,__tla as k}from"./index.js";let n,l=Promise.all([(()=>{try{return k}catch{}})()]).then(async()=>{let s;s="/home/runner/work/dxos/dxos/packages/sdk/client/src/mesh/mesh-proxy.ts",n=class{constructor(e,t){this._serviceProvider=e,this._traceParent=t,this._networkStatusUpdated=new v,this._networkStatus=d.from(this._networkStatusUpdated,{swarm:_.OFFLINE,signaling:[]}),this._instanceId=S.random().toHex()}toJSON(){return{networkStatus:this._networkStatus.get()}}get networkStatus(){return this._networkStatus}async updateConfig(e){return a(this._serviceProvider.services.NetworkService,"NetworkService is not available.",{F:s,L:49,S:this,A:["this._serviceProvider.services.NetworkService","'NetworkService is not available.'"]}),this._serviceProvider.services.NetworkService.updateConfig({swarm:e},{timeout:o})}async _open(){i.trace("dxos.sdk.mesh-proxy.open",c.begin({id:this._instanceId,parentId:this._traceParent}),{F:s,L:57,S:this,C:(t,r)=>t(...r)}),this._ctx=new w({onError:t=>i.catch(t,void 0,{F:s,L:58,S:this,C:(r,h)=>r(...h)})}),a(this._serviceProvider.services.NetworkService,"NetworkService is not available.",{F:s,L:60,S:this,A:["this._serviceProvider.services.NetworkService","'NetworkService is not available.'"]});const e=this._serviceProvider.services.NetworkService.queryStatus(void 0,{timeout:o});e.subscribe(t=>{this._networkStatusUpdated.emit(t)}),this._ctx.onDispose(()=>e.close()),i.trace("dxos.sdk.mesh-proxy.open",c.end({id:this._instanceId}),{F:s,L:69,S:this,C:(t,r)=>t(...r)})}async _close(){var e;await((e=this._ctx)==null?void 0:e.dispose())}}});export{n as MeshProxy,l as __tla};
