{"version":3,"mappings":"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","names":["__create","__defProp","__getOwnPropDesc","__getOwnPropNames","__getProtoOf","__hasOwnProp","__commonJS","cb","mod","__copyProps","to","from","except","desc","key","__toESM","isNodeMode","target","exports","module","obj","sym","symVal","syms","descriptor","hasSymbols","hasSymbolSham","origSymbol","test","$Object","ERROR_MESSAGE","toStr","max","a","b","i","j","arrLike","offset","arr","str","joiner","that","args","slicy","bound","result","boundLength","boundArgs","joiny","binder","implementation","call","$hasOwn","bind","$Function","expressionSyntax","$gOPD","$TypeError","ThrowTypeError","throwTypeError","getProto","x","TypedArray","INTRINSICS","undefined2","needsEval","errorProto","doEval","value","name","getEvalledConstructor","doEval2","fn","gen","LEGACY_ALIASES","$concat","$replace","$strSlice","reEscapeChar","string","first","last","$SyntaxError","quote","subString","getBaseIntrinsic","intrinsicName","hasOwn","alias","allowMissing","$exec","parts","stringToPath","intrinsicBaseName","intrinsic","skipFurtherCaching","part","intrinsicRealName","isOwn","hasPropertyDescriptors","GetIntrinsic","$defineProperty","gopd","property","nonEnumerable","nonWritable","nonConfigurable","loose","define","hasDescriptors","gOPD","$floor","length","functionLengthIsConfigurable","functionLengthIsWritable","setFunctionLength","$call","$max","$reflectApply","applyBind","callBind","$indexOf","$toString","isStandardArguments","hasToStringTag","isLegacyArguments","fnToStr","isFnRegex","GeneratorFunction","generatorFunc","getGeneratorFunc","reflectApply","badArrayLike","isCallableMarker","_","constructorRegex","fnStr","tryFunctionObject","isES6ClassFn","fnClass","genClass","isDDA","all","isIE68","ddaClass","ddaClass2","ddaClass3","objectClass","e","strClass","isCallable","array","len","receiver","iterator","forEachString","forEachObject","object","k","hasOwnProperty","forEach","list","forEachArray","g","out","possibleNames","originalFunction","availableTypedArrays","callBound","typedArrays","$slice","cache","getPrototypeOf","typedArray","proto","superProto","tryTypedArrays","getter","found","trySlices","tag","whichTypedArray","toStrTags","foundName","isTypedArray","anyTrue","isArgumentsObject","uncurryThis","f","SymbolSupported","numberValue","stringValue","booleanValue","BigIntSupported","bigIntValue","symbolValue","checkBoxedPrimitive","prototypeValueOf","isPromise","input","isArrayBufferView","isDataView","isUint8Array","isUint8ClampedArray","isUint16Array","isUint32Array","isInt8Array","isInt16Array","isInt32Array","isFloat32Array","isBigInt64Array","isBigUint64Array","isMapToString","ObjectToString","isMap","isSetToString","isWeakMapToString","isWeakMap","isWeakSetToString","isWeakSet","isArrayBufferToString","isArrayBuffer","isDataViewToString","isSharedArrayBuffer","SharedArrayBufferCopy","isSharedArrayBufferToString","isAsyncFunction","isMapIterator","isSetIterator","isWebAssemblyCompiledModule","isNumberObject","isStringObject","isBigIntObject","isBooleanObject","isBoxedPrimitive","method","arg","require_inherits_browser","ctor","superCtor","TempCtor","getOwnPropertyDescriptors","keys","descriptors","objects","x2","isNull","msg","warned","debugs","debugEnvRegex","define_process_env_default","debugEnv","set","pid","opts","ctx","stylizeNoColor","isBoolean","isUndefined","stylizeWithColor","inspect","styleType","style","arrayToHash","hash","val","formatValue","recurseTimes","isFunction","ret","formatPrimitive","primitive","visibleKeys","isRegExp","isDate","formatError","braces","isArray","n","base","isError","output","formatArray","formatProperty","isString","isNumber","l","line","reduceToSingleString","prev","cur","ar","isNullOrUndefined","isSymbol","re","isObject","objectToString","d","isPrimitive","o","pad","months","timestamp","time","origin","add","prop","kCustomPromisifiedSymbol","original","promiseResolve","promiseReject","promise","reject","resolve","err","reason","newReason","callbackified","maybeCb","self","nextTick","fun","platform","browser","config","noop","once","performance","clocktime","seconds","nanoseconds","previousTimestamp","currentTime","process","segs","seg","lookup","revLookup","Arr","code","b64","len2","validLen","placeHoldersLen","lens","getLens","tmp","_byteLength","curByte","i2","num","uint8","start","end","maxChunkLength","len22","extraBytes","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","s","buffer","c","rt","base64","ieee754","customInspectSymbol","K_MAX_LENGTH","Buffer","typedArraySupport","encodingOrOffset","isInstance","valueOf","size","encoding","assertSize","createBuffer","fill","alloc","checked","allocUnsafe","byteLength","buf","actual","fromArrayLike","fromArrayView","arrayView","copy","byteOffset","fromObject","SlowBuffer","y","pos","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","latin1Slice","base64Slice","swap","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","dir","numberIsNaN","arrayIndexOf","indexSize","arrLength","valLength","read","foundIndex","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","base64Write","ucs2Write","utf16leToBytes","hexWrite","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","asciiSlice","hexSliceLookupTable","utf16leSlice","bytes","newBuf","checkOffset","ext","byteLength2","noAssert","mul","defineBigIntMethod","validateNumber","boundsError","lo","hi","min","checkInt","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","limit","sub","littleEndian","writeFloat","writeDouble","checkIEEE754","targetStart","errors","E","Base","getMessage","received","addNumericalSeparator","range","checkBounds","INVALID_BASE64_RE","units","leadSurrogate","byteArray","base64clean","src","dst","type","alphabet","table","i16","BufferBigIntNotDefined","import_buffer","postfix","endIndex","index","returnValue","util","stringReplaceAll","stringEncaseCRLFWithFirstIndex","TEMPLATE_REGEX","u","chunks","number","ESCAPE_REGEX","character","chunk","results","STYLE_REGEX","matches","buildStyle","layer","enabled","styleName","current","temporary","styles","parseStyle","chalk","require$$0","require$$1","require$$2","options","colorLevel","arguments_","builder","model","styler","bgModel","level","close","parent","openAll","closeAll","open","_styler","lfIndex","truncateKey","timeout","context","stack","timeoutId","body","propertyName","message","formatter","levels2","entry","shouldLog","retryTS","log2","processLog","meta","error","processor","constr","props","info","inspect3","_ts_decorate","decorators","r","__dxlog_file","onError","#name","#isDisposed","#disposePromise","_b","#parent","#attributes","#onError","_a","#disposeCallbacks","callback","throwOnError","resolveDispose","callbacks","clean","attributes","_Context","clearDispose","newCtx","LifecycleState2","#lifecycleState","#closePromise","#internalCtx","#createContext","#parentCtx","#openPromise","#open","#close","Observable_1","hasSymbol","getSymbol","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","getSpecies","Observable","isObservable","hostReportError","enqueue","cleanupSubscription","subscription","cleanup","unsubscribe","closeSubscription","flushSubscription","queue","notifySubscription","observer","onNotify","subscriptionObserver","subscriber","Subscription","done","C","hasSeed","hasValue","acc","values","startNext","next","v","sources","subscriptions","inner","completeIfDone","outer","observable","item","items","zenObservable","p","stream","warning","EventEmitter","eventsModule","listener","events","doError","er","handler","listeners","prepend","existing","w","state","wrapped","originalListener","position","evlistener","unwrap","emitter","errorListener","resolver","flags","wrapListener","encodeChunk","fromString","codegen","fetch","filename","contents","xhr","comment","lastCommentLine","endOffset","startOffset","isComment","charAt","isLeadingComment","curr","isDoc","setComment","repeat","delim","token","source","stringDelim","push","peek","expected","equals","optional","trailingLine","comments","alternateCommentMode","skip","parse","Type","require$$3","require$$4","require$$5","require$$6","Service","require$$7","require$$8","require$$9","require$$10","root","tn","substitutions","field","genMapScalar","substitution","ref","pb.Type","mapper","invariant","pb.MapField","pb.Enum","_type","_mapping","_schema","data","schema","encode","decode","__dxlog_file3","Stream","_Stream","producer","producerCleanup","err2","entries","map","ready","streamPromise","onMessage","onClose","invariant3","onReady","__dxlog_file4","_service","backend","handlers","encodingOptions","service","invariant4","requestCodec","responseCodec","requestOptions","encoded","request","response","methodName","_serviceDefinition","_serviceProvider","_encodingOptions","mappedMethodName","requestDecoded","handlerPromise","responseStream","_Schema","_typesRoot","typeName","codec","Root2","merge","structValue","visitedObjects","struct","trigger","seq","frames","frameKey","_Timeframe","hex","other","timeframe","currentEntry","tf2","feedKey","frame","lines","spanSymbol","cause","TypeId","_empty","empty","make","unsafeGet","get","getOption","option.none","internal.makeGenericTag","internal.empty","internal.make","internal.add","internal.get","internal.unsafeGet","internal.getOption","internal.merge","format","toJSON","Dual.dual","Hash.string","Hash.symbol","isFiberId","id","Hash.cached","Equal.symbol","left","right","Hash.combine","Hash.hash","Equal.equals","none","None","Runtime","composite","HashSet.empty","HashSet.make","HashSet.union","MutableRef.make","threadName","unsafeMake","MutableRef.get","MutableRef.set","internal.runtime","internal.composite","internal.isFiberId","internal.threadName","internal.unsafeMake","fromIterable","HM.fromIterable","HM.isEmpty","HM.get","HM.set","HM.keys","HM.size","HM.modifyAt","HM.map","reduce","HM.reduce","toArray","Arr.fromIterable","isEquivalent","Equivalence.mapInput","Arr.getEquivalence","Hash.array","head","tail","cons","element","prefix","temp","zero","these","Structural","variance","PatchProto","EmptyProto","AndThenProto","makeAndThen","second","update","diff","oldValue","newValue","patch","missingServices","old","newService","combine","wasServiceUpdated","Chunk.of","updatedContext","Chunk.isNonEmpty","patches","Chunk.headNonEmpty","Chunk.tailNonEmpty","Chunk.prepend","HashSet.reduce","HashSet.has","HashSet.remove","HashSet.add","Data.Structural","until","oldElement","newElement","valuePatch","Arr.drop","Arr.of","Arr.isNonEmptyArray","Arr.headNonEmpty","Arr.tailNonEmpty","differ","readonlyArray","identity","params","ContextPatch.empty","ContextPatch.combine","ContextPatch.diff","ContextPatch.patch","hashSet","HashSetPatch.empty","HashSetPatch.combine","HashSetPatch.diff","HashSetPatch.patch","ReadonlyArrayPatch.empty","ReadonlyArrayPatch.combine","constant","active","enable","disable","flag","exclude","interruptible","runtimeFlagsPatch.make","runtimeFlagsPatch.invert","runtimeFlagsPatch.active","runtimeFlagsPatch.enabled","internalDiffer.make","runtimeFlagsPatch.andThen","_patch","internal.enable","internal.disable","internal.exclude","flatten","List.empty","List.reduce","parallel","blockedRequest","step","sequential","List.isNil","List.reverse","requests","List.cons","parKeys","seqHeadKeys","HashMap.empty","HashMap.modifyAt","Option.orElseSome","Option.map","Chunk.append","HashMap.reduce","HashMap.set","Option.match","HashMap.get","Chunk.appendAll","HashMap.isEmpty","HashMap.keys","HashMap.map","joiners","OpCodes.OP_STATE_PENDING","effect","OpCodes.OP_STATE_DONE","Context.GenericTag","characters","charactersLength","endTime","startTime","kind","blockedRequests","EffectTypeId","OpCodes.OP_REVERT_FLAGS","_op","Hash.random","isEffect","withRuntime","OpCodes.OP_WITH_RUNTIME","acquire","release","flatMap","suspend","restore","use","exit","OpCodes.OP_FAILURE","internalCause.parallel","OpCodes.OP_SUCCESS","succeed","OpCodes.OP_COMMIT","wrapper","register","FiberId.none","OpCodes.OP_ASYNC","cancelerRef","blockingOn","backingResume","pendingEffect","proxyResume","resume","controllerRef","catchAll","matchEffect","span","Option.isSome","defect","internalCause.die","either","Either.right","fail","internalCause.fail","fiber","evaluate","OpCodes.OP_ON_SUCCESS","OpCodes.OP_ON_SUCCESS_AND_FAILURE","internalCause.defects","internalCause.failures","Chunk.unsafeHead","Arr.allocate","OpCodes.OP_UPDATE_RUNTIME_FLAGS","RuntimeFlagsPatch.enable","_runtimeFlags.Interruption","mapError","internalCause.failureOrCause","cause2","internalCause.sequential","success","internalCause.isInterruptedOnly","internalCause.interruptors","orElse","OpCodes.OP_SYNC","scopeOverride","scope","Option.getOrElse","Option.some","onSuccess","Option.getOrThrow","internalCause.keepDefectsAndElectFailures","RuntimeFlagsPatch.disable","oldFlags","_runtimeFlags.interruption","yieldNow","OpCodes.OP_YIELD","fiberId","internalDiffer.update","initial","internalDiffer.readonlyArray","internalDiffer.environment","_runtimeFlags.differ","currentContext","Context.empty","scheduler","Arr.empty","Option.none","internalCause.empty","finalizer","strategy","YieldableError","tree","indentation","indent","pretty","seed","SHP","ProtocolStream","dest","names","ch","crypto","ms","ping","ontimeout","discoveryKey","Page","MASK","MASK_INCL","LITTLE_ENDIAN","Bitfield","page","upd","Iterator","val2","delta","em","bit","sm","factor","createIfMissing","bitfield","mask","clz","Protocol","rle","treeIndex","EMPTY","replicate","initiator","onready","feed","onhandshake","replicatePeer","peer","Peer","want","allowPush","onproof","proof","downloading","uploading","have","updated","bits","sel","remoteLength","unhave","selections","wlen","waiting","slen","inflight","block","wait","blk","ite","nextRandom","reserved","wantedEnd","le","createView","local","import$_dxos_node_std_events","opening","Nanoresource","inherits","preclosing","allowActive","fastClose","closing","sync","onclose","cqueue","batch","chunked","Readable2","WriteStream","ReadStream","remove","MerkleGenerator","codecs","Nanoguard","safeBufferEquals","Message","broadcasted","sk","sig","pk","Feed","createStorage2","defaultStorageDir","Buffer2","secretKey","Extension","sparseBitfield","toCodec","loop","onerror","workHook","work","depth"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57],"sources":["../node_modules/@dxos/node-std/dist/lib/browser/chunk-MJPHVYKR.mjs","../node_modules/@dxos/node-std/dist/lib/browser/chunk-RGVVW7F2.mjs","../node_modules/@dxos/node-std/dist/lib/browser/chunk-QWZSWMMO.mjs","../node_modules/@dxos/node-std/dist/lib/browser/chunk-HFGMGNFE.mjs","../node_modules/@dxos/node-std/dist/lib/browser/chunk-P5GBL7TE.mjs","../node_modules/@dxos/node-std/dist/lib/browser/util.mjs","../node_modules/chalk/source/util.js","../node_modules/chalk/source/templates.js","../node_modules/chalk/source/index.js","../node_modules/@dxos/debug/dist/lib/browser/index.mjs","../node_modules/@dxos/log/dist/lib/browser/index.mjs","../node_modules/@dxos/context/dist/lib/browser/index.mjs","../node_modules/zen-observable/lib/Observable.js","../node_modules/zen-observable/index.js","../node_modules/zen-push/node_modules/zen-observable/lib/Observable.js","../node_modules/zen-push/node_modules/zen-observable/index.js","../node_modules/zen-push/index.js","../node_modules/events/events.js","../node_modules/readable-stream/lib/internal/streams/stream-browser.js","../node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/buffer/index.js","../node_modules/@dxos/async/dist/lib/browser/index.mjs","../node_modules/@dxos/protocols/dist/esm/src/errors/encoding.js","../node_modules/@dxos/protocols/dist/esm/src/errors/errors.js","../node_modules/@protobufjs/codegen/index.js","../node_modules/@protobufjs/fetch/index.js","../node_modules/protobufjs/src/tokenize.js","../node_modules/protobufjs/src/parse.js","../node_modules/@dxos/codec-protobuf/dist/lib/browser/index.mjs","../node_modules/@dxos/timeframe/dist/lib/browser/index.mjs","../node_modules/@dxos/protocols/dist/esm/src/proto/substitutions.js","../node_modules/@dxos/protocols/dist/esm/src/proto/gen/index.js","../node_modules/@dxos/rpc/dist/lib/browser/index.mjs","../node_modules/effect/dist/esm/internal/cause.js","../node_modules/effect/dist/esm/internal/context.js","../node_modules/effect/dist/esm/Context.js","../node_modules/effect/dist/esm/MutableRef.js","../node_modules/effect/dist/esm/internal/fiberId.js","../node_modules/effect/dist/esm/FiberId.js","../node_modules/effect/dist/esm/HashMap.js","../node_modules/effect/dist/esm/List.js","../node_modules/effect/dist/esm/internal/data.js","../node_modules/effect/dist/esm/internal/differ/contextPatch.js","../node_modules/effect/dist/esm/internal/differ/hashSetPatch.js","../node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js","../node_modules/effect/dist/esm/internal/differ.js","../node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js","../node_modules/effect/dist/esm/internal/runtimeFlags.js","../node_modules/effect/dist/esm/RuntimeFlagsPatch.js","../node_modules/effect/dist/esm/internal/blockedRequests.js","../node_modules/effect/dist/esm/internal/opCodes/deferred.js","../node_modules/effect/dist/esm/internal/deferred.js","../node_modules/effect/dist/esm/internal/singleShotGen.js","../node_modules/effect/dist/esm/internal/tracer.js","../node_modules/effect/dist/esm/internal/core.js","../node_modules/@effect/schema/dist/esm/TreeFormatter.js","../node_modules/@dxos/hypercore/dist/lib/browser/index.mjs"],"sourcesContent":["var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\nexport {\n  __commonJS,\n  __toESM\n};\n//# sourceMappingURL=chunk-MJPHVYKR.mjs.map\n","import {\n  __commonJS\n} from \"./chunk-MJPHVYKR.mjs\";\n\n// node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js\nvar require_shams = __commonJS({\n  \"node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function hasSymbols() {\n      if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n        return false;\n      }\n      if (typeof Symbol.iterator === \"symbol\") {\n        return true;\n      }\n      var obj = {};\n      var sym = Symbol(\"test\");\n      var symObj = Object(sym);\n      if (typeof sym === \"string\") {\n        return false;\n      }\n      if (Object.prototype.toString.call(sym) !== \"[object Symbol]\") {\n        return false;\n      }\n      if (Object.prototype.toString.call(symObj) !== \"[object Symbol]\") {\n        return false;\n      }\n      var symVal = 42;\n      obj[sym] = symVal;\n      for (sym in obj) {\n        return false;\n      }\n      if (typeof Object.keys === \"function\" && Object.keys(obj).length !== 0) {\n        return false;\n      }\n      if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(obj).length !== 0) {\n        return false;\n      }\n      var syms = Object.getOwnPropertySymbols(obj);\n      if (syms.length !== 1 || syms[0] !== sym) {\n        return false;\n      }\n      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {\n        return false;\n      }\n      if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n        if (descriptor.value !== symVal || descriptor.enumerable !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/.pnpm/has-tostringtag@1.0.0/node_modules/has-tostringtag/shams.js\nvar require_shams2 = __commonJS({\n  \"node_modules/.pnpm/has-tostringtag@1.0.0/node_modules/has-tostringtag/shams.js\"(exports, module) {\n    \"use strict\";\n    var hasSymbols = require_shams();\n    module.exports = function hasToStringTagShams() {\n      return hasSymbols() && !!Symbol.toStringTag;\n    };\n  }\n});\n\n// node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js\nvar require_has_symbols = __commonJS({\n  \"node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js\"(exports, module) {\n    \"use strict\";\n    var origSymbol = typeof Symbol !== \"undefined\" && Symbol;\n    var hasSymbolSham = require_shams();\n    module.exports = function hasNativeSymbols() {\n      if (typeof origSymbol !== \"function\") {\n        return false;\n      }\n      if (typeof Symbol !== \"function\") {\n        return false;\n      }\n      if (typeof origSymbol(\"foo\") !== \"symbol\") {\n        return false;\n      }\n      if (typeof Symbol(\"bar\") !== \"symbol\") {\n        return false;\n      }\n      return hasSymbolSham();\n    };\n  }\n});\n\n// node_modules/.pnpm/has-proto@1.0.1/node_modules/has-proto/index.js\nvar require_has_proto = __commonJS({\n  \"node_modules/.pnpm/has-proto@1.0.1/node_modules/has-proto/index.js\"(exports, module) {\n    \"use strict\";\n    var test = {\n      foo: {}\n    };\n    var $Object = Object;\n    module.exports = function hasProto() {\n      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);\n    };\n  }\n});\n\n// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js\nvar require_implementation = __commonJS({\n  \"node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js\"(exports, module) {\n    \"use strict\";\n    var ERROR_MESSAGE = \"Function.prototype.bind called on incompatible \";\n    var toStr = Object.prototype.toString;\n    var max = Math.max;\n    var funcType = \"[object Function]\";\n    var concatty = function concatty2(a, b) {\n      var arr = [];\n      for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n      }\n      for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n      }\n      return arr;\n    };\n    var slicy = function slicy2(arrLike, offset) {\n      var arr = [];\n      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n      }\n      return arr;\n    };\n    var joiny = function(arr, joiner) {\n      var str = \"\";\n      for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n          str += joiner;\n        }\n      }\n      return str;\n    };\n    module.exports = function bind(that) {\n      var target = this;\n      if (typeof target !== \"function\" || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n      }\n      var args = slicy(arguments, 1);\n      var bound;\n      var binder = function() {\n        if (this instanceof bound) {\n          var result = target.apply(\n            this,\n            concatty(args, arguments)\n          );\n          if (Object(result) === result) {\n            return result;\n          }\n          return this;\n        }\n        return target.apply(\n          that,\n          concatty(args, arguments)\n        );\n      };\n      var boundLength = max(0, target.length - args.length);\n      var boundArgs = [];\n      for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = \"$\" + i;\n      }\n      bound = Function(\"binder\", \"return function (\" + joiny(boundArgs, \",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n      if (target.prototype) {\n        var Empty = function Empty2() {\n        };\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n      }\n      return bound;\n    };\n  }\n});\n\n// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js\nvar require_function_bind = __commonJS({\n  \"node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js\"(exports, module) {\n    \"use strict\";\n    var implementation = require_implementation();\n    module.exports = Function.prototype.bind || implementation;\n  }\n});\n\n// node_modules/.pnpm/hasown@2.0.0/node_modules/hasown/index.js\nvar require_hasown = __commonJS({\n  \"node_modules/.pnpm/hasown@2.0.0/node_modules/hasown/index.js\"(exports, module) {\n    \"use strict\";\n    var call = Function.prototype.call;\n    var $hasOwn = Object.prototype.hasOwnProperty;\n    var bind = require_function_bind();\n    module.exports = bind.call(call, $hasOwn);\n  }\n});\n\n// node_modules/.pnpm/get-intrinsic@1.2.2/node_modules/get-intrinsic/index.js\nvar require_get_intrinsic = __commonJS({\n  \"node_modules/.pnpm/get-intrinsic@1.2.2/node_modules/get-intrinsic/index.js\"(exports, module) {\n    \"use strict\";\n    var undefined2;\n    var $SyntaxError = SyntaxError;\n    var $Function = Function;\n    var $TypeError = TypeError;\n    var getEvalledConstructor = function(expressionSyntax) {\n      try {\n        return $Function('\"use strict\"; return (' + expressionSyntax + \").constructor;\")();\n      } catch (e) {\n      }\n    };\n    var $gOPD = Object.getOwnPropertyDescriptor;\n    if ($gOPD) {\n      try {\n        $gOPD({}, \"\");\n      } catch (e) {\n        $gOPD = null;\n      }\n    }\n    var throwTypeError = function() {\n      throw new $TypeError();\n    };\n    var ThrowTypeError = $gOPD ? function() {\n      try {\n        arguments.callee;\n        return throwTypeError;\n      } catch (calleeThrows) {\n        try {\n          return $gOPD(arguments, \"callee\").get;\n        } catch (gOPDthrows) {\n          return throwTypeError;\n        }\n      }\n    }() : throwTypeError;\n    var hasSymbols = require_has_symbols()();\n    var hasProto = require_has_proto()();\n    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {\n      return x.__proto__;\n    } : null);\n    var needsEval = {};\n    var TypedArray = typeof Uint8Array === \"undefined\" || !getProto ? undefined2 : getProto(Uint8Array);\n    var INTRINSICS = {\n      \"%AggregateError%\": typeof AggregateError === \"undefined\" ? undefined2 : AggregateError,\n      \"%Array%\": Array,\n      \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? undefined2 : ArrayBuffer,\n      \"%ArrayIteratorPrototype%\": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,\n      \"%AsyncFromSyncIteratorPrototype%\": undefined2,\n      \"%AsyncFunction%\": needsEval,\n      \"%AsyncGenerator%\": needsEval,\n      \"%AsyncGeneratorFunction%\": needsEval,\n      \"%AsyncIteratorPrototype%\": needsEval,\n      \"%Atomics%\": typeof Atomics === \"undefined\" ? undefined2 : Atomics,\n      \"%BigInt%\": typeof BigInt === \"undefined\" ? undefined2 : BigInt,\n      \"%BigInt64Array%\": typeof BigInt64Array === \"undefined\" ? undefined2 : BigInt64Array,\n      \"%BigUint64Array%\": typeof BigUint64Array === \"undefined\" ? undefined2 : BigUint64Array,\n      \"%Boolean%\": Boolean,\n      \"%DataView%\": typeof DataView === \"undefined\" ? undefined2 : DataView,\n      \"%Date%\": Date,\n      \"%decodeURI%\": decodeURI,\n      \"%decodeURIComponent%\": decodeURIComponent,\n      \"%encodeURI%\": encodeURI,\n      \"%encodeURIComponent%\": encodeURIComponent,\n      \"%Error%\": Error,\n      \"%eval%\": eval,\n      // eslint-disable-line no-eval\n      \"%EvalError%\": EvalError,\n      \"%Float32Array%\": typeof Float32Array === \"undefined\" ? undefined2 : Float32Array,\n      \"%Float64Array%\": typeof Float64Array === \"undefined\" ? undefined2 : Float64Array,\n      \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? undefined2 : FinalizationRegistry,\n      \"%Function%\": $Function,\n      \"%GeneratorFunction%\": needsEval,\n      \"%Int8Array%\": typeof Int8Array === \"undefined\" ? undefined2 : Int8Array,\n      \"%Int16Array%\": typeof Int16Array === \"undefined\" ? undefined2 : Int16Array,\n      \"%Int32Array%\": typeof Int32Array === \"undefined\" ? undefined2 : Int32Array,\n      \"%isFinite%\": isFinite,\n      \"%isNaN%\": isNaN,\n      \"%IteratorPrototype%\": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,\n      \"%JSON%\": typeof JSON === \"object\" ? JSON : undefined2,\n      \"%Map%\": typeof Map === \"undefined\" ? undefined2 : Map,\n      \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),\n      \"%Math%\": Math,\n      \"%Number%\": Number,\n      \"%Object%\": Object,\n      \"%parseFloat%\": parseFloat,\n      \"%parseInt%\": parseInt,\n      \"%Promise%\": typeof Promise === \"undefined\" ? undefined2 : Promise,\n      \"%Proxy%\": typeof Proxy === \"undefined\" ? undefined2 : Proxy,\n      \"%RangeError%\": RangeError,\n      \"%ReferenceError%\": ReferenceError,\n      \"%Reflect%\": typeof Reflect === \"undefined\" ? undefined2 : Reflect,\n      \"%RegExp%\": RegExp,\n      \"%Set%\": typeof Set === \"undefined\" ? undefined2 : Set,\n      \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),\n      \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? undefined2 : SharedArrayBuffer,\n      \"%String%\": String,\n      \"%StringIteratorPrototype%\": hasSymbols && getProto ? getProto(\"\"[Symbol.iterator]()) : undefined2,\n      \"%Symbol%\": hasSymbols ? Symbol : undefined2,\n      \"%SyntaxError%\": $SyntaxError,\n      \"%ThrowTypeError%\": ThrowTypeError,\n      \"%TypedArray%\": TypedArray,\n      \"%TypeError%\": $TypeError,\n      \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? undefined2 : Uint8Array,\n      \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? undefined2 : Uint8ClampedArray,\n      \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? undefined2 : Uint16Array,\n      \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? undefined2 : Uint32Array,\n      \"%URIError%\": URIError,\n      \"%WeakMap%\": typeof WeakMap === \"undefined\" ? undefined2 : WeakMap,\n      \"%WeakRef%\": typeof WeakRef === \"undefined\" ? undefined2 : WeakRef,\n      \"%WeakSet%\": typeof WeakSet === \"undefined\" ? undefined2 : WeakSet\n    };\n    if (getProto) {\n      try {\n        null.error;\n      } catch (e) {\n        errorProto = getProto(getProto(e));\n        INTRINSICS[\"%Error.prototype%\"] = errorProto;\n      }\n    }\n    var errorProto;\n    var doEval = function doEval2(name) {\n      var value;\n      if (name === \"%AsyncFunction%\") {\n        value = getEvalledConstructor(\"async function () {}\");\n      } else if (name === \"%GeneratorFunction%\") {\n        value = getEvalledConstructor(\"function* () {}\");\n      } else if (name === \"%AsyncGeneratorFunction%\") {\n        value = getEvalledConstructor(\"async function* () {}\");\n      } else if (name === \"%AsyncGenerator%\") {\n        var fn = doEval2(\"%AsyncGeneratorFunction%\");\n        if (fn) {\n          value = fn.prototype;\n        }\n      } else if (name === \"%AsyncIteratorPrototype%\") {\n        var gen = doEval2(\"%AsyncGenerator%\");\n        if (gen && getProto) {\n          value = getProto(gen.prototype);\n        }\n      }\n      INTRINSICS[name] = value;\n      return value;\n    };\n    var LEGACY_ALIASES = {\n      \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n      \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n      \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n      \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n      \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n      \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n      \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n      \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n      \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n      \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n      \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n      \"%DatePrototype%\": [\"Date\", \"prototype\"],\n      \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n      \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n      \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n      \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n      \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n      \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n      \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n      \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n      \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n      \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n      \"%JSONParse%\": [\"JSON\", \"parse\"],\n      \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n      \"%MapPrototype%\": [\"Map\", \"prototype\"],\n      \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n      \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n      \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n      \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n      \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n      \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n      \"%Promise_all%\": [\"Promise\", \"all\"],\n      \"%Promise_reject%\": [\"Promise\", \"reject\"],\n      \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n      \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n      \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n      \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n      \"%SetPrototype%\": [\"Set\", \"prototype\"],\n      \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n      \"%StringPrototype%\": [\"String\", \"prototype\"],\n      \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n      \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n      \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n      \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n      \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n      \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n      \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n      \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n      \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n      \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n      \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n    };\n    var bind = require_function_bind();\n    var hasOwn = require_hasown();\n    var $concat = bind.call(Function.call, Array.prototype.concat);\n    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);\n    var $replace = bind.call(Function.call, String.prototype.replace);\n    var $strSlice = bind.call(Function.call, String.prototype.slice);\n    var $exec = bind.call(Function.call, RegExp.prototype.exec);\n    var rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n    var reEscapeChar = /\\\\(\\\\)?/g;\n    var stringToPath = function stringToPath2(string) {\n      var first = $strSlice(string, 0, 1);\n      var last = $strSlice(string, -1);\n      if (first === \"%\" && last !== \"%\") {\n        throw new $SyntaxError(\"invalid intrinsic syntax, expected closing `%`\");\n      } else if (last === \"%\" && first !== \"%\") {\n        throw new $SyntaxError(\"invalid intrinsic syntax, expected opening `%`\");\n      }\n      var result = [];\n      $replace(string, rePropName, function(match, number, quote, subString) {\n        result[result.length] = quote ? $replace(subString, reEscapeChar, \"$1\") : number || match;\n      });\n      return result;\n    };\n    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {\n      var intrinsicName = name;\n      var alias;\n      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n        alias = LEGACY_ALIASES[intrinsicName];\n        intrinsicName = \"%\" + alias[0] + \"%\";\n      }\n      if (hasOwn(INTRINSICS, intrinsicName)) {\n        var value = INTRINSICS[intrinsicName];\n        if (value === needsEval) {\n          value = doEval(intrinsicName);\n        }\n        if (typeof value === \"undefined\" && !allowMissing) {\n          throw new $TypeError(\"intrinsic \" + name + \" exists, but is not available. Please file an issue!\");\n        }\n        return {\n          alias,\n          name: intrinsicName,\n          value\n        };\n      }\n      throw new $SyntaxError(\"intrinsic \" + name + \" does not exist!\");\n    };\n    module.exports = function GetIntrinsic(name, allowMissing) {\n      if (typeof name !== \"string\" || name.length === 0) {\n        throw new $TypeError(\"intrinsic name must be a non-empty string\");\n      }\n      if (arguments.length > 1 && typeof allowMissing !== \"boolean\") {\n        throw new $TypeError('\"allowMissing\" argument must be a boolean');\n      }\n      if ($exec(/^%?[^%]*%?$/, name) === null) {\n        throw new $SyntaxError(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n      }\n      var parts = stringToPath(name);\n      var intrinsicBaseName = parts.length > 0 ? parts[0] : \"\";\n      var intrinsic = getBaseIntrinsic(\"%\" + intrinsicBaseName + \"%\", allowMissing);\n      var intrinsicRealName = intrinsic.name;\n      var value = intrinsic.value;\n      var skipFurtherCaching = false;\n      var alias = intrinsic.alias;\n      if (alias) {\n        intrinsicBaseName = alias[0];\n        $spliceApply(parts, $concat([0, 1], alias));\n      }\n      for (var i = 1, isOwn = true; i < parts.length; i += 1) {\n        var part = parts[i];\n        var first = $strSlice(part, 0, 1);\n        var last = $strSlice(part, -1);\n        if ((first === '\"' || first === \"'\" || first === \"`\" || (last === '\"' || last === \"'\" || last === \"`\")) && first !== last) {\n          throw new $SyntaxError(\"property names with quotes must have matching quotes\");\n        }\n        if (part === \"constructor\" || !isOwn) {\n          skipFurtherCaching = true;\n        }\n        intrinsicBaseName += \".\" + part;\n        intrinsicRealName = \"%\" + intrinsicBaseName + \"%\";\n        if (hasOwn(INTRINSICS, intrinsicRealName)) {\n          value = INTRINSICS[intrinsicRealName];\n        } else if (value != null) {\n          if (!(part in value)) {\n            if (!allowMissing) {\n              throw new $TypeError(\"base intrinsic for \" + name + \" exists, but the property is not available.\");\n            }\n            return void 0;\n          }\n          if ($gOPD && i + 1 >= parts.length) {\n            var desc = $gOPD(value, part);\n            isOwn = !!desc;\n            if (isOwn && \"get\" in desc && !(\"originalValue\" in desc.get)) {\n              value = desc.get;\n            } else {\n              value = value[part];\n            }\n          } else {\n            isOwn = hasOwn(value, part);\n            value = value[part];\n          }\n          if (isOwn && !skipFurtherCaching) {\n            INTRINSICS[intrinsicRealName] = value;\n          }\n        }\n      }\n      return value;\n    };\n  }\n});\n\n// node_modules/.pnpm/has-property-descriptors@1.0.0/node_modules/has-property-descriptors/index.js\nvar require_has_property_descriptors = __commonJS({\n  \"node_modules/.pnpm/has-property-descriptors@1.0.0/node_modules/has-property-descriptors/index.js\"(exports, module) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $defineProperty = GetIntrinsic(\"%Object.defineProperty%\", true);\n    var hasPropertyDescriptors = function hasPropertyDescriptors2() {\n      if ($defineProperty) {\n        try {\n          $defineProperty({}, \"a\", { value: 1 });\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n      return false;\n    };\n    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n      if (!hasPropertyDescriptors()) {\n        return null;\n      }\n      try {\n        return $defineProperty([], \"length\", { value: 1 }).length !== 1;\n      } catch (e) {\n        return true;\n      }\n    };\n    module.exports = hasPropertyDescriptors;\n  }\n});\n\n// node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js\nvar require_gopd = __commonJS({\n  \"node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js\"(exports, module) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $gOPD = GetIntrinsic(\"%Object.getOwnPropertyDescriptor%\", true);\n    if ($gOPD) {\n      try {\n        $gOPD([], \"length\");\n      } catch (e) {\n        $gOPD = null;\n      }\n    }\n    module.exports = $gOPD;\n  }\n});\n\n// node_modules/.pnpm/define-data-property@1.1.1/node_modules/define-data-property/index.js\nvar require_define_data_property = __commonJS({\n  \"node_modules/.pnpm/define-data-property@1.1.1/node_modules/define-data-property/index.js\"(exports, module) {\n    \"use strict\";\n    var hasPropertyDescriptors = require_has_property_descriptors()();\n    var GetIntrinsic = require_get_intrinsic();\n    var $defineProperty = hasPropertyDescriptors && GetIntrinsic(\"%Object.defineProperty%\", true);\n    if ($defineProperty) {\n      try {\n        $defineProperty({}, \"a\", { value: 1 });\n      } catch (e) {\n        $defineProperty = false;\n      }\n    }\n    var $SyntaxError = GetIntrinsic(\"%SyntaxError%\");\n    var $TypeError = GetIntrinsic(\"%TypeError%\");\n    var gopd = require_gopd();\n    module.exports = function defineDataProperty(obj, property, value) {\n      if (!obj || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        throw new $TypeError(\"`obj` must be an object or a function`\");\n      }\n      if (typeof property !== \"string\" && typeof property !== \"symbol\") {\n        throw new $TypeError(\"`property` must be a string or a symbol`\");\n      }\n      if (arguments.length > 3 && typeof arguments[3] !== \"boolean\" && arguments[3] !== null) {\n        throw new $TypeError(\"`nonEnumerable`, if provided, must be a boolean or null\");\n      }\n      if (arguments.length > 4 && typeof arguments[4] !== \"boolean\" && arguments[4] !== null) {\n        throw new $TypeError(\"`nonWritable`, if provided, must be a boolean or null\");\n      }\n      if (arguments.length > 5 && typeof arguments[5] !== \"boolean\" && arguments[5] !== null) {\n        throw new $TypeError(\"`nonConfigurable`, if provided, must be a boolean or null\");\n      }\n      if (arguments.length > 6 && typeof arguments[6] !== \"boolean\") {\n        throw new $TypeError(\"`loose`, if provided, must be a boolean\");\n      }\n      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n      var nonWritable = arguments.length > 4 ? arguments[4] : null;\n      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n      var loose = arguments.length > 6 ? arguments[6] : false;\n      var desc = !!gopd && gopd(obj, property);\n      if ($defineProperty) {\n        $defineProperty(obj, property, {\n          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n          value,\n          writable: nonWritable === null && desc ? desc.writable : !nonWritable\n        });\n      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {\n        obj[property] = value;\n      } else {\n        throw new $SyntaxError(\"This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.\");\n      }\n    };\n  }\n});\n\n// node_modules/.pnpm/set-function-length@1.1.1/node_modules/set-function-length/index.js\nvar require_set_function_length = __commonJS({\n  \"node_modules/.pnpm/set-function-length@1.1.1/node_modules/set-function-length/index.js\"(exports, module) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var define = require_define_data_property();\n    var hasDescriptors = require_has_property_descriptors()();\n    var gOPD = require_gopd();\n    var $TypeError = GetIntrinsic(\"%TypeError%\");\n    var $floor = GetIntrinsic(\"%Math.floor%\");\n    module.exports = function setFunctionLength(fn, length) {\n      if (typeof fn !== \"function\") {\n        throw new $TypeError(\"`fn` is not a function\");\n      }\n      if (typeof length !== \"number\" || length < 0 || length > 4294967295 || $floor(length) !== length) {\n        throw new $TypeError(\"`length` must be a positive 32-bit integer\");\n      }\n      var loose = arguments.length > 2 && !!arguments[2];\n      var functionLengthIsConfigurable = true;\n      var functionLengthIsWritable = true;\n      if (\"length\" in fn && gOPD) {\n        var desc = gOPD(fn, \"length\");\n        if (desc && !desc.configurable) {\n          functionLengthIsConfigurable = false;\n        }\n        if (desc && !desc.writable) {\n          functionLengthIsWritable = false;\n        }\n      }\n      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {\n        if (hasDescriptors) {\n          define(fn, \"length\", length, true, true);\n        } else {\n          define(fn, \"length\", length);\n        }\n      }\n      return fn;\n    };\n  }\n});\n\n// node_modules/.pnpm/call-bind@1.0.5/node_modules/call-bind/index.js\nvar require_call_bind = __commonJS({\n  \"node_modules/.pnpm/call-bind@1.0.5/node_modules/call-bind/index.js\"(exports, module) {\n    \"use strict\";\n    var bind = require_function_bind();\n    var GetIntrinsic = require_get_intrinsic();\n    var setFunctionLength = require_set_function_length();\n    var $TypeError = GetIntrinsic(\"%TypeError%\");\n    var $apply = GetIntrinsic(\"%Function.prototype.apply%\");\n    var $call = GetIntrinsic(\"%Function.prototype.call%\");\n    var $reflectApply = GetIntrinsic(\"%Reflect.apply%\", true) || bind.call($call, $apply);\n    var $defineProperty = GetIntrinsic(\"%Object.defineProperty%\", true);\n    var $max = GetIntrinsic(\"%Math.max%\");\n    if ($defineProperty) {\n      try {\n        $defineProperty({}, \"a\", { value: 1 });\n      } catch (e) {\n        $defineProperty = null;\n      }\n    }\n    module.exports = function callBind(originalFunction) {\n      if (typeof originalFunction !== \"function\") {\n        throw new $TypeError(\"a function is required\");\n      }\n      var func = $reflectApply(bind, $call, arguments);\n      return setFunctionLength(\n        func,\n        1 + $max(0, originalFunction.length - (arguments.length - 1)),\n        true\n      );\n    };\n    var applyBind = function applyBind2() {\n      return $reflectApply(bind, $apply, arguments);\n    };\n    if ($defineProperty) {\n      $defineProperty(module.exports, \"apply\", { value: applyBind });\n    } else {\n      module.exports.apply = applyBind;\n    }\n  }\n});\n\n// node_modules/.pnpm/call-bind@1.0.5/node_modules/call-bind/callBound.js\nvar require_callBound = __commonJS({\n  \"node_modules/.pnpm/call-bind@1.0.5/node_modules/call-bind/callBound.js\"(exports, module) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var callBind = require_call_bind();\n    var $indexOf = callBind(GetIntrinsic(\"String.prototype.indexOf\"));\n    module.exports = function callBoundIntrinsic(name, allowMissing) {\n      var intrinsic = GetIntrinsic(name, !!allowMissing);\n      if (typeof intrinsic === \"function\" && $indexOf(name, \".prototype.\") > -1) {\n        return callBind(intrinsic);\n      }\n      return intrinsic;\n    };\n  }\n});\n\n// node_modules/.pnpm/is-arguments@1.1.1/node_modules/is-arguments/index.js\nvar require_is_arguments = __commonJS({\n  \"node_modules/.pnpm/is-arguments@1.1.1/node_modules/is-arguments/index.js\"(exports, module) {\n    \"use strict\";\n    var hasToStringTag = require_shams2()();\n    var callBound = require_callBound();\n    var $toString = callBound(\"Object.prototype.toString\");\n    var isStandardArguments = function isArguments(value) {\n      if (hasToStringTag && value && typeof value === \"object\" && Symbol.toStringTag in value) {\n        return false;\n      }\n      return $toString(value) === \"[object Arguments]\";\n    };\n    var isLegacyArguments = function isArguments(value) {\n      if (isStandardArguments(value)) {\n        return true;\n      }\n      return value !== null && typeof value === \"object\" && typeof value.length === \"number\" && value.length >= 0 && $toString(value) !== \"[object Array]\" && $toString(value.callee) === \"[object Function]\";\n    };\n    var supportsStandardArguments = function() {\n      return isStandardArguments(arguments);\n    }();\n    isStandardArguments.isLegacyArguments = isLegacyArguments;\n    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n  }\n});\n\n// node_modules/.pnpm/is-generator-function@1.0.10/node_modules/is-generator-function/index.js\nvar require_is_generator_function = __commonJS({\n  \"node_modules/.pnpm/is-generator-function@1.0.10/node_modules/is-generator-function/index.js\"(exports, module) {\n    \"use strict\";\n    var toStr = Object.prototype.toString;\n    var fnToStr = Function.prototype.toString;\n    var isFnRegex = /^\\s*(?:function)?\\*/;\n    var hasToStringTag = require_shams2()();\n    var getProto = Object.getPrototypeOf;\n    var getGeneratorFunc = function() {\n      if (!hasToStringTag) {\n        return false;\n      }\n      try {\n        return Function(\"return function*() {}\")();\n      } catch (e) {\n      }\n    };\n    var GeneratorFunction;\n    module.exports = function isGeneratorFunction(fn) {\n      if (typeof fn !== \"function\") {\n        return false;\n      }\n      if (isFnRegex.test(fnToStr.call(fn))) {\n        return true;\n      }\n      if (!hasToStringTag) {\n        var str = toStr.call(fn);\n        return str === \"[object GeneratorFunction]\";\n      }\n      if (!getProto) {\n        return false;\n      }\n      if (typeof GeneratorFunction === \"undefined\") {\n        var generatorFunc = getGeneratorFunc();\n        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n      }\n      return getProto(fn) === GeneratorFunction;\n    };\n  }\n});\n\n// node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js\nvar require_is_callable = __commonJS({\n  \"node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js\"(exports, module) {\n    \"use strict\";\n    var fnToStr = Function.prototype.toString;\n    var reflectApply = typeof Reflect === \"object\" && Reflect !== null && Reflect.apply;\n    var badArrayLike;\n    var isCallableMarker;\n    if (typeof reflectApply === \"function\" && typeof Object.defineProperty === \"function\") {\n      try {\n        badArrayLike = Object.defineProperty({}, \"length\", {\n          get: function() {\n            throw isCallableMarker;\n          }\n        });\n        isCallableMarker = {};\n        reflectApply(function() {\n          throw 42;\n        }, null, badArrayLike);\n      } catch (_) {\n        if (_ !== isCallableMarker) {\n          reflectApply = null;\n        }\n      }\n    } else {\n      reflectApply = null;\n    }\n    var constructorRegex = /^\\s*class\\b/;\n    var isES6ClassFn = function isES6ClassFunction(value) {\n      try {\n        var fnStr = fnToStr.call(value);\n        return constructorRegex.test(fnStr);\n      } catch (e) {\n        return false;\n      }\n    };\n    var tryFunctionObject = function tryFunctionToStr(value) {\n      try {\n        if (isES6ClassFn(value)) {\n          return false;\n        }\n        fnToStr.call(value);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    };\n    var toStr = Object.prototype.toString;\n    var objectClass = \"[object Object]\";\n    var fnClass = \"[object Function]\";\n    var genClass = \"[object GeneratorFunction]\";\n    var ddaClass = \"[object HTMLAllCollection]\";\n    var ddaClass2 = \"[object HTML document.all class]\";\n    var ddaClass3 = \"[object HTMLCollection]\";\n    var hasToStringTag = typeof Symbol === \"function\" && !!Symbol.toStringTag;\n    var isIE68 = !(0 in [,]);\n    var isDDA = function isDocumentDotAll() {\n      return false;\n    };\n    if (typeof document === \"object\") {\n      all = document.all;\n      if (toStr.call(all) === toStr.call(document.all)) {\n        isDDA = function isDocumentDotAll(value) {\n          if ((isIE68 || !value) && (typeof value === \"undefined\" || typeof value === \"object\")) {\n            try {\n              var str = toStr.call(value);\n              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value(\"\") == null;\n            } catch (e) {\n            }\n          }\n          return false;\n        };\n      }\n    }\n    var all;\n    module.exports = reflectApply ? function isCallable(value) {\n      if (isDDA(value)) {\n        return true;\n      }\n      if (!value) {\n        return false;\n      }\n      if (typeof value !== \"function\" && typeof value !== \"object\") {\n        return false;\n      }\n      try {\n        reflectApply(value, null, badArrayLike);\n      } catch (e) {\n        if (e !== isCallableMarker) {\n          return false;\n        }\n      }\n      return !isES6ClassFn(value) && tryFunctionObject(value);\n    } : function isCallable(value) {\n      if (isDDA(value)) {\n        return true;\n      }\n      if (!value) {\n        return false;\n      }\n      if (typeof value !== \"function\" && typeof value !== \"object\") {\n        return false;\n      }\n      if (hasToStringTag) {\n        return tryFunctionObject(value);\n      }\n      if (isES6ClassFn(value)) {\n        return false;\n      }\n      var strClass = toStr.call(value);\n      if (strClass !== fnClass && strClass !== genClass && !/^\\[object HTML/.test(strClass)) {\n        return false;\n      }\n      return tryFunctionObject(value);\n    };\n  }\n});\n\n// node_modules/.pnpm/for-each@0.3.3/node_modules/for-each/index.js\nvar require_for_each = __commonJS({\n  \"node_modules/.pnpm/for-each@0.3.3/node_modules/for-each/index.js\"(exports, module) {\n    \"use strict\";\n    var isCallable = require_is_callable();\n    var toStr = Object.prototype.toString;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var forEachArray = function forEachArray2(array, iterator, receiver) {\n      for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n          if (receiver == null) {\n            iterator(array[i], i, array);\n          } else {\n            iterator.call(receiver, array[i], i, array);\n          }\n        }\n      }\n    };\n    var forEachString = function forEachString2(string, iterator, receiver) {\n      for (var i = 0, len = string.length; i < len; i++) {\n        if (receiver == null) {\n          iterator(string.charAt(i), i, string);\n        } else {\n          iterator.call(receiver, string.charAt(i), i, string);\n        }\n      }\n    };\n    var forEachObject = function forEachObject2(object, iterator, receiver) {\n      for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n          if (receiver == null) {\n            iterator(object[k], k, object);\n          } else {\n            iterator.call(receiver, object[k], k, object);\n          }\n        }\n      }\n    };\n    var forEach = function forEach2(list, iterator, thisArg) {\n      if (!isCallable(iterator)) {\n        throw new TypeError(\"iterator must be a function\");\n      }\n      var receiver;\n      if (arguments.length >= 3) {\n        receiver = thisArg;\n      }\n      if (toStr.call(list) === \"[object Array]\") {\n        forEachArray(list, iterator, receiver);\n      } else if (typeof list === \"string\") {\n        forEachString(list, iterator, receiver);\n      } else {\n        forEachObject(list, iterator, receiver);\n      }\n    };\n    module.exports = forEach;\n  }\n});\n\n// node_modules/.pnpm/available-typed-arrays@1.0.5/node_modules/available-typed-arrays/index.js\nvar require_available_typed_arrays = __commonJS({\n  \"node_modules/.pnpm/available-typed-arrays@1.0.5/node_modules/available-typed-arrays/index.js\"(exports, module) {\n    \"use strict\";\n    var possibleNames = [\n      \"BigInt64Array\",\n      \"BigUint64Array\",\n      \"Float32Array\",\n      \"Float64Array\",\n      \"Int16Array\",\n      \"Int32Array\",\n      \"Int8Array\",\n      \"Uint16Array\",\n      \"Uint32Array\",\n      \"Uint8Array\",\n      \"Uint8ClampedArray\"\n    ];\n    var g = typeof globalThis === \"undefined\" ? global : globalThis;\n    module.exports = function availableTypedArrays() {\n      var out = [];\n      for (var i = 0; i < possibleNames.length; i++) {\n        if (typeof g[possibleNames[i]] === \"function\") {\n          out[out.length] = possibleNames[i];\n        }\n      }\n      return out;\n    };\n  }\n});\n\n// node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/index.js\nvar require_call_bind2 = __commonJS({\n  \"node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/index.js\"(exports, module) {\n    \"use strict\";\n    var bind = require_function_bind();\n    var GetIntrinsic = require_get_intrinsic();\n    var $apply = GetIntrinsic(\"%Function.prototype.apply%\");\n    var $call = GetIntrinsic(\"%Function.prototype.call%\");\n    var $reflectApply = GetIntrinsic(\"%Reflect.apply%\", true) || bind.call($call, $apply);\n    var $gOPD = GetIntrinsic(\"%Object.getOwnPropertyDescriptor%\", true);\n    var $defineProperty = GetIntrinsic(\"%Object.defineProperty%\", true);\n    var $max = GetIntrinsic(\"%Math.max%\");\n    if ($defineProperty) {\n      try {\n        $defineProperty({}, \"a\", { value: 1 });\n      } catch (e) {\n        $defineProperty = null;\n      }\n    }\n    module.exports = function callBind(originalFunction) {\n      var func = $reflectApply(bind, $call, arguments);\n      if ($gOPD && $defineProperty) {\n        var desc = $gOPD(func, \"length\");\n        if (desc.configurable) {\n          $defineProperty(\n            func,\n            \"length\",\n            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n          );\n        }\n      }\n      return func;\n    };\n    var applyBind = function applyBind2() {\n      return $reflectApply(bind, $apply, arguments);\n    };\n    if ($defineProperty) {\n      $defineProperty(module.exports, \"apply\", { value: applyBind });\n    } else {\n      module.exports.apply = applyBind;\n    }\n  }\n});\n\n// node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/callBound.js\nvar require_callBound2 = __commonJS({\n  \"node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/callBound.js\"(exports, module) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var callBind = require_call_bind2();\n    var $indexOf = callBind(GetIntrinsic(\"String.prototype.indexOf\"));\n    module.exports = function callBoundIntrinsic(name, allowMissing) {\n      var intrinsic = GetIntrinsic(name, !!allowMissing);\n      if (typeof intrinsic === \"function\" && $indexOf(name, \".prototype.\") > -1) {\n        return callBind(intrinsic);\n      }\n      return intrinsic;\n    };\n  }\n});\n\n// node_modules/.pnpm/es-abstract@1.20.4/node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\nvar require_getOwnPropertyDescriptor = __commonJS({\n  \"node_modules/.pnpm/es-abstract@1.20.4/node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\"(exports, module) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $gOPD = GetIntrinsic(\"%Object.getOwnPropertyDescriptor%\", true);\n    if ($gOPD) {\n      try {\n        $gOPD([], \"length\");\n      } catch (e) {\n        $gOPD = null;\n      }\n    }\n    module.exports = $gOPD;\n  }\n});\n\n// node_modules/.pnpm/which-typed-array@1.1.13/node_modules/which-typed-array/index.js\nvar require_which_typed_array = __commonJS({\n  \"node_modules/.pnpm/which-typed-array@1.1.13/node_modules/which-typed-array/index.js\"(exports, module) {\n    \"use strict\";\n    var forEach = require_for_each();\n    var availableTypedArrays = require_available_typed_arrays();\n    var callBind = require_call_bind();\n    var callBound = require_callBound();\n    var gOPD = require_gopd();\n    var $toString = callBound(\"Object.prototype.toString\");\n    var hasToStringTag = require_shams2()();\n    var g = typeof globalThis === \"undefined\" ? global : globalThis;\n    var typedArrays = availableTypedArrays();\n    var $slice = callBound(\"String.prototype.slice\");\n    var getPrototypeOf = Object.getPrototypeOf;\n    var $indexOf = callBound(\"Array.prototype.indexOf\", true) || function indexOf(array, value) {\n      for (var i = 0; i < array.length; i += 1) {\n        if (array[i] === value) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    var cache = { __proto__: null };\n    if (hasToStringTag && gOPD && getPrototypeOf) {\n      forEach(typedArrays, function(typedArray) {\n        var arr = new g[typedArray]();\n        if (Symbol.toStringTag in arr) {\n          var proto = getPrototypeOf(arr);\n          var descriptor = gOPD(proto, Symbol.toStringTag);\n          if (!descriptor) {\n            var superProto = getPrototypeOf(proto);\n            descriptor = gOPD(superProto, Symbol.toStringTag);\n          }\n          cache[\"$\" + typedArray] = callBind(descriptor.get);\n        }\n      });\n    } else {\n      forEach(typedArrays, function(typedArray) {\n        var arr = new g[typedArray]();\n        var fn = arr.slice || arr.set;\n        if (fn) {\n          cache[\"$\" + typedArray] = callBind(fn);\n        }\n      });\n    }\n    var tryTypedArrays = function tryAllTypedArrays(value) {\n      var found = false;\n      forEach(cache, function(getter, typedArray) {\n        if (!found) {\n          try {\n            if (\"$\" + getter(value) === typedArray) {\n              found = $slice(typedArray, 1);\n            }\n          } catch (e) {\n          }\n        }\n      });\n      return found;\n    };\n    var trySlices = function tryAllSlices(value) {\n      var found = false;\n      forEach(cache, function(getter, name) {\n        if (!found) {\n          try {\n            getter(value);\n            found = $slice(name, 1);\n          } catch (e) {\n          }\n        }\n      });\n      return found;\n    };\n    module.exports = function whichTypedArray(value) {\n      if (!value || typeof value !== \"object\") {\n        return false;\n      }\n      if (!hasToStringTag) {\n        var tag = $slice($toString(value), 8, -1);\n        if ($indexOf(typedArrays, tag) > -1) {\n          return tag;\n        }\n        if (tag !== \"Object\") {\n          return false;\n        }\n        return trySlices(value);\n      }\n      if (!gOPD) {\n        return null;\n      }\n      return tryTypedArrays(value);\n    };\n  }\n});\n\n// node_modules/.pnpm/is-typed-array@1.1.12/node_modules/is-typed-array/index.js\nvar require_is_typed_array = __commonJS({\n  \"node_modules/.pnpm/is-typed-array@1.1.12/node_modules/is-typed-array/index.js\"(exports, module) {\n    \"use strict\";\n    var whichTypedArray = require_which_typed_array();\n    module.exports = function isTypedArray(value) {\n      return !!whichTypedArray(value);\n    };\n  }\n});\n\n// node_modules/.pnpm/which-typed-array@1.1.8/node_modules/which-typed-array/index.js\nvar require_which_typed_array2 = __commonJS({\n  \"node_modules/.pnpm/which-typed-array@1.1.8/node_modules/which-typed-array/index.js\"(exports, module) {\n    \"use strict\";\n    var forEach = require_for_each();\n    var availableTypedArrays = require_available_typed_arrays();\n    var callBound = require_callBound2();\n    var $toString = callBound(\"Object.prototype.toString\");\n    var hasToStringTag = require_shams2()();\n    var g = typeof globalThis === \"undefined\" ? global : globalThis;\n    var typedArrays = availableTypedArrays();\n    var $slice = callBound(\"String.prototype.slice\");\n    var toStrTags = {};\n    var gOPD = require_getOwnPropertyDescriptor();\n    var getPrototypeOf = Object.getPrototypeOf;\n    if (hasToStringTag && gOPD && getPrototypeOf) {\n      forEach(typedArrays, function(typedArray) {\n        if (typeof g[typedArray] === \"function\") {\n          var arr = new g[typedArray]();\n          if (Symbol.toStringTag in arr) {\n            var proto = getPrototypeOf(arr);\n            var descriptor = gOPD(proto, Symbol.toStringTag);\n            if (!descriptor) {\n              var superProto = getPrototypeOf(proto);\n              descriptor = gOPD(superProto, Symbol.toStringTag);\n            }\n            toStrTags[typedArray] = descriptor.get;\n          }\n        }\n      });\n    }\n    var tryTypedArrays = function tryAllTypedArrays(value) {\n      var foundName = false;\n      forEach(toStrTags, function(getter, typedArray) {\n        if (!foundName) {\n          try {\n            var name = getter.call(value);\n            if (name === typedArray) {\n              foundName = name;\n            }\n          } catch (e) {\n          }\n        }\n      });\n      return foundName;\n    };\n    var isTypedArray = require_is_typed_array();\n    module.exports = function whichTypedArray(value) {\n      if (!isTypedArray(value)) {\n        return false;\n      }\n      if (!hasToStringTag || !(Symbol.toStringTag in value)) {\n        return $slice($toString(value), 8, -1);\n      }\n      return tryTypedArrays(value);\n    };\n  }\n});\n\n// node_modules/.pnpm/is-typed-array@1.1.9/node_modules/is-typed-array/index.js\nvar require_is_typed_array2 = __commonJS({\n  \"node_modules/.pnpm/is-typed-array@1.1.9/node_modules/is-typed-array/index.js\"(exports, module) {\n    \"use strict\";\n    var forEach = require_for_each();\n    var availableTypedArrays = require_available_typed_arrays();\n    var callBound = require_callBound2();\n    var $toString = callBound(\"Object.prototype.toString\");\n    var hasToStringTag = require_shams2()();\n    var g = typeof globalThis === \"undefined\" ? global : globalThis;\n    var typedArrays = availableTypedArrays();\n    var $indexOf = callBound(\"Array.prototype.indexOf\", true) || function indexOf(array, value) {\n      for (var i = 0; i < array.length; i += 1) {\n        if (array[i] === value) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    var $slice = callBound(\"String.prototype.slice\");\n    var toStrTags = {};\n    var gOPD = require_getOwnPropertyDescriptor();\n    var getPrototypeOf = Object.getPrototypeOf;\n    if (hasToStringTag && gOPD && getPrototypeOf) {\n      forEach(typedArrays, function(typedArray) {\n        var arr = new g[typedArray]();\n        if (Symbol.toStringTag in arr) {\n          var proto = getPrototypeOf(arr);\n          var descriptor = gOPD(proto, Symbol.toStringTag);\n          if (!descriptor) {\n            var superProto = getPrototypeOf(proto);\n            descriptor = gOPD(superProto, Symbol.toStringTag);\n          }\n          toStrTags[typedArray] = descriptor.get;\n        }\n      });\n    }\n    var tryTypedArrays = function tryAllTypedArrays(value) {\n      var anyTrue = false;\n      forEach(toStrTags, function(getter, typedArray) {\n        if (!anyTrue) {\n          try {\n            anyTrue = getter.call(value) === typedArray;\n          } catch (e) {\n          }\n        }\n      });\n      return anyTrue;\n    };\n    module.exports = function isTypedArray(value) {\n      if (!value || typeof value !== \"object\") {\n        return false;\n      }\n      if (!hasToStringTag || !(Symbol.toStringTag in value)) {\n        var tag = $slice($toString(value), 8, -1);\n        return $indexOf(typedArrays, tag) > -1;\n      }\n      if (!gOPD) {\n        return false;\n      }\n      return tryTypedArrays(value);\n    };\n  }\n});\n\n// node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js\nvar require_types = __commonJS({\n  \"node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js\"(exports) {\n    \"use strict\";\n    var isArgumentsObject = require_is_arguments();\n    var isGeneratorFunction = require_is_generator_function();\n    var whichTypedArray = require_which_typed_array2();\n    var isTypedArray = require_is_typed_array2();\n    function uncurryThis(f) {\n      return f.call.bind(f);\n    }\n    var BigIntSupported = typeof BigInt !== \"undefined\";\n    var SymbolSupported = typeof Symbol !== \"undefined\";\n    var ObjectToString = uncurryThis(Object.prototype.toString);\n    var numberValue = uncurryThis(Number.prototype.valueOf);\n    var stringValue = uncurryThis(String.prototype.valueOf);\n    var booleanValue = uncurryThis(Boolean.prototype.valueOf);\n    if (BigIntSupported) {\n      bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n    }\n    var bigIntValue;\n    if (SymbolSupported) {\n      symbolValue = uncurryThis(Symbol.prototype.valueOf);\n    }\n    var symbolValue;\n    function checkBoxedPrimitive(value, prototypeValueOf) {\n      if (typeof value !== \"object\") {\n        return false;\n      }\n      try {\n        prototypeValueOf(value);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    exports.isArgumentsObject = isArgumentsObject;\n    exports.isGeneratorFunction = isGeneratorFunction;\n    exports.isTypedArray = isTypedArray;\n    function isPromise(input) {\n      return typeof Promise !== \"undefined\" && input instanceof Promise || input !== null && typeof input === \"object\" && typeof input.then === \"function\" && typeof input.catch === \"function\";\n    }\n    exports.isPromise = isPromise;\n    function isArrayBufferView(value) {\n      if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n        return ArrayBuffer.isView(value);\n      }\n      return isTypedArray(value) || isDataView(value);\n    }\n    exports.isArrayBufferView = isArrayBufferView;\n    function isUint8Array(value) {\n      return whichTypedArray(value) === \"Uint8Array\";\n    }\n    exports.isUint8Array = isUint8Array;\n    function isUint8ClampedArray(value) {\n      return whichTypedArray(value) === \"Uint8ClampedArray\";\n    }\n    exports.isUint8ClampedArray = isUint8ClampedArray;\n    function isUint16Array(value) {\n      return whichTypedArray(value) === \"Uint16Array\";\n    }\n    exports.isUint16Array = isUint16Array;\n    function isUint32Array(value) {\n      return whichTypedArray(value) === \"Uint32Array\";\n    }\n    exports.isUint32Array = isUint32Array;\n    function isInt8Array(value) {\n      return whichTypedArray(value) === \"Int8Array\";\n    }\n    exports.isInt8Array = isInt8Array;\n    function isInt16Array(value) {\n      return whichTypedArray(value) === \"Int16Array\";\n    }\n    exports.isInt16Array = isInt16Array;\n    function isInt32Array(value) {\n      return whichTypedArray(value) === \"Int32Array\";\n    }\n    exports.isInt32Array = isInt32Array;\n    function isFloat32Array(value) {\n      return whichTypedArray(value) === \"Float32Array\";\n    }\n    exports.isFloat32Array = isFloat32Array;\n    function isFloat64Array(value) {\n      return whichTypedArray(value) === \"Float64Array\";\n    }\n    exports.isFloat64Array = isFloat64Array;\n    function isBigInt64Array(value) {\n      return whichTypedArray(value) === \"BigInt64Array\";\n    }\n    exports.isBigInt64Array = isBigInt64Array;\n    function isBigUint64Array(value) {\n      return whichTypedArray(value) === \"BigUint64Array\";\n    }\n    exports.isBigUint64Array = isBigUint64Array;\n    function isMapToString(value) {\n      return ObjectToString(value) === \"[object Map]\";\n    }\n    isMapToString.working = typeof Map !== \"undefined\" && isMapToString(/* @__PURE__ */ new Map());\n    function isMap(value) {\n      if (typeof Map === \"undefined\") {\n        return false;\n      }\n      return isMapToString.working ? isMapToString(value) : value instanceof Map;\n    }\n    exports.isMap = isMap;\n    function isSetToString(value) {\n      return ObjectToString(value) === \"[object Set]\";\n    }\n    isSetToString.working = typeof Set !== \"undefined\" && isSetToString(/* @__PURE__ */ new Set());\n    function isSet(value) {\n      if (typeof Set === \"undefined\") {\n        return false;\n      }\n      return isSetToString.working ? isSetToString(value) : value instanceof Set;\n    }\n    exports.isSet = isSet;\n    function isWeakMapToString(value) {\n      return ObjectToString(value) === \"[object WeakMap]\";\n    }\n    isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(/* @__PURE__ */ new WeakMap());\n    function isWeakMap(value) {\n      if (typeof WeakMap === \"undefined\") {\n        return false;\n      }\n      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;\n    }\n    exports.isWeakMap = isWeakMap;\n    function isWeakSetToString(value) {\n      return ObjectToString(value) === \"[object WeakSet]\";\n    }\n    isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(/* @__PURE__ */ new WeakSet());\n    function isWeakSet(value) {\n      return isWeakSetToString(value);\n    }\n    exports.isWeakSet = isWeakSet;\n    function isArrayBufferToString(value) {\n      return ObjectToString(value) === \"[object ArrayBuffer]\";\n    }\n    isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer());\n    function isArrayBuffer(value) {\n      if (typeof ArrayBuffer === \"undefined\") {\n        return false;\n      }\n      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;\n    }\n    exports.isArrayBuffer = isArrayBuffer;\n    function isDataViewToString(value) {\n      return ObjectToString(value) === \"[object DataView]\";\n    }\n    isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n    function isDataView(value) {\n      if (typeof DataView === \"undefined\") {\n        return false;\n      }\n      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;\n    }\n    exports.isDataView = isDataView;\n    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : void 0;\n    function isSharedArrayBufferToString(value) {\n      return ObjectToString(value) === \"[object SharedArrayBuffer]\";\n    }\n    function isSharedArrayBuffer(value) {\n      if (typeof SharedArrayBufferCopy === \"undefined\") {\n        return false;\n      }\n      if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n      }\n      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;\n    }\n    exports.isSharedArrayBuffer = isSharedArrayBuffer;\n    function isAsyncFunction(value) {\n      return ObjectToString(value) === \"[object AsyncFunction]\";\n    }\n    exports.isAsyncFunction = isAsyncFunction;\n    function isMapIterator(value) {\n      return ObjectToString(value) === \"[object Map Iterator]\";\n    }\n    exports.isMapIterator = isMapIterator;\n    function isSetIterator(value) {\n      return ObjectToString(value) === \"[object Set Iterator]\";\n    }\n    exports.isSetIterator = isSetIterator;\n    function isGeneratorObject(value) {\n      return ObjectToString(value) === \"[object Generator]\";\n    }\n    exports.isGeneratorObject = isGeneratorObject;\n    function isWebAssemblyCompiledModule(value) {\n      return ObjectToString(value) === \"[object WebAssembly.Module]\";\n    }\n    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n    function isNumberObject(value) {\n      return checkBoxedPrimitive(value, numberValue);\n    }\n    exports.isNumberObject = isNumberObject;\n    function isStringObject(value) {\n      return checkBoxedPrimitive(value, stringValue);\n    }\n    exports.isStringObject = isStringObject;\n    function isBooleanObject(value) {\n      return checkBoxedPrimitive(value, booleanValue);\n    }\n    exports.isBooleanObject = isBooleanObject;\n    function isBigIntObject(value) {\n      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n    }\n    exports.isBigIntObject = isBigIntObject;\n    function isSymbolObject(value) {\n      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n    }\n    exports.isSymbolObject = isSymbolObject;\n    function isBoxedPrimitive(value) {\n      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);\n    }\n    exports.isBoxedPrimitive = isBoxedPrimitive;\n    function isAnyArrayBuffer(value) {\n      return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(value) || isSharedArrayBuffer(value));\n    }\n    exports.isAnyArrayBuffer = isAnyArrayBuffer;\n    [\"isProxy\", \"isExternal\", \"isModuleNamespaceObject\"].forEach(function(method) {\n      Object.defineProperty(exports, method, {\n        enumerable: false,\n        value: function() {\n          throw new Error(method + \" is not supported in userland\");\n        }\n      });\n    });\n  }\n});\n\n// node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js\nvar require_isBufferBrowser = __commonJS({\n  \"node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js\"(exports, module) {\n    module.exports = function isBuffer(arg) {\n      return arg && typeof arg === \"object\" && typeof arg.copy === \"function\" && typeof arg.fill === \"function\" && typeof arg.readUInt8 === \"function\";\n    };\n  }\n});\n\n// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js\nvar require_inherits_browser = __commonJS({\n  \"node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js\"(exports, module) {\n    if (typeof Object.create === \"function\") {\n      module.exports = function inherits(ctor, superCtor) {\n        if (superCtor) {\n          ctor.super_ = superCtor;\n          ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n              value: ctor,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n        }\n      };\n    } else {\n      module.exports = function inherits(ctor, superCtor) {\n        if (superCtor) {\n          ctor.super_ = superCtor;\n          var TempCtor = function() {\n          };\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        }\n      };\n    }\n  }\n});\n\n// node_modules/.pnpm/util@0.12.5/node_modules/util/util.js\nvar require_util = __commonJS({\n  \"node_modules/.pnpm/util@0.12.5/node_modules/util/util.js\"(exports) {\n    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {\n      var keys = Object.keys(obj);\n      var descriptors = {};\n      for (var i = 0; i < keys.length; i++) {\n        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n      }\n      return descriptors;\n    };\n    var formatRegExp = /%[sdj%]/g;\n    exports.format = function(f) {\n      if (!isString(f)) {\n        var objects = [];\n        for (var i = 0; i < arguments.length; i++) {\n          objects.push(inspect(arguments[i]));\n        }\n        return objects.join(\" \");\n      }\n      var i = 1;\n      var args = arguments;\n      var len = args.length;\n      var str = String(f).replace(formatRegExp, function(x2) {\n        if (x2 === \"%%\")\n          return \"%\";\n        if (i >= len)\n          return x2;\n        switch (x2) {\n          case \"%s\":\n            return String(args[i++]);\n          case \"%d\":\n            return Number(args[i++]);\n          case \"%j\":\n            try {\n              return JSON.stringify(args[i++]);\n            } catch (_) {\n              return \"[Circular]\";\n            }\n          default:\n            return x2;\n        }\n      });\n      for (var x = args[i]; i < len; x = args[++i]) {\n        if (isNull(x) || !isObject(x)) {\n          str += \" \" + x;\n        } else {\n          str += \" \" + inspect(x);\n        }\n      }\n      return str;\n    };\n    exports.deprecate = function(fn, msg) {\n      if (typeof process !== \"undefined\" && process.noDeprecation === true) {\n        return fn;\n      }\n      if (typeof process === \"undefined\") {\n        return function() {\n          return exports.deprecate(fn, msg).apply(this, arguments);\n        };\n      }\n      var warned = false;\n      function deprecated() {\n        if (!warned) {\n          if (process.throwDeprecation) {\n            throw new Error(msg);\n          } else if (process.traceDeprecation) {\n            console.trace(msg);\n          } else {\n            console.error(msg);\n          }\n          warned = true;\n        }\n        return fn.apply(this, arguments);\n      }\n      return deprecated;\n    };\n    var debugs = {};\n    var debugEnvRegex = /^$/;\n    if (process.env.NODE_DEBUG) {\n      debugEnv = process.env.NODE_DEBUG;\n      debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n      debugEnvRegex = new RegExp(\"^\" + debugEnv + \"$\", \"i\");\n    }\n    var debugEnv;\n    exports.debuglog = function(set) {\n      set = set.toUpperCase();\n      if (!debugs[set]) {\n        if (debugEnvRegex.test(set)) {\n          var pid = process.pid;\n          debugs[set] = function() {\n            var msg = exports.format.apply(exports, arguments);\n            console.error(\"%s %d: %s\", set, pid, msg);\n          };\n        } else {\n          debugs[set] = function() {\n          };\n        }\n      }\n      return debugs[set];\n    };\n    function inspect(obj, opts) {\n      var ctx = {\n        seen: [],\n        stylize: stylizeNoColor\n      };\n      if (arguments.length >= 3)\n        ctx.depth = arguments[2];\n      if (arguments.length >= 4)\n        ctx.colors = arguments[3];\n      if (isBoolean(opts)) {\n        ctx.showHidden = opts;\n      } else if (opts) {\n        exports._extend(ctx, opts);\n      }\n      if (isUndefined(ctx.showHidden))\n        ctx.showHidden = false;\n      if (isUndefined(ctx.depth))\n        ctx.depth = 2;\n      if (isUndefined(ctx.colors))\n        ctx.colors = false;\n      if (isUndefined(ctx.customInspect))\n        ctx.customInspect = true;\n      if (ctx.colors)\n        ctx.stylize = stylizeWithColor;\n      return formatValue(ctx, obj, ctx.depth);\n    }\n    exports.inspect = inspect;\n    inspect.colors = {\n      \"bold\": [1, 22],\n      \"italic\": [3, 23],\n      \"underline\": [4, 24],\n      \"inverse\": [7, 27],\n      \"white\": [37, 39],\n      \"grey\": [90, 39],\n      \"black\": [30, 39],\n      \"blue\": [34, 39],\n      \"cyan\": [36, 39],\n      \"green\": [32, 39],\n      \"magenta\": [35, 39],\n      \"red\": [31, 39],\n      \"yellow\": [33, 39]\n    };\n    inspect.styles = {\n      \"special\": \"cyan\",\n      \"number\": \"yellow\",\n      \"boolean\": \"yellow\",\n      \"undefined\": \"grey\",\n      \"null\": \"bold\",\n      \"string\": \"green\",\n      \"date\": \"magenta\",\n      // \"name\": intentionally not styling\n      \"regexp\": \"red\"\n    };\n    function stylizeWithColor(str, styleType) {\n      var style = inspect.styles[styleType];\n      if (style) {\n        return \"\\x1B[\" + inspect.colors[style][0] + \"m\" + str + \"\\x1B[\" + inspect.colors[style][1] + \"m\";\n      } else {\n        return str;\n      }\n    }\n    function stylizeNoColor(str, styleType) {\n      return str;\n    }\n    function arrayToHash(array) {\n      var hash = {};\n      array.forEach(function(val, idx) {\n        hash[val] = true;\n      });\n      return hash;\n    }\n    function formatValue(ctx, value, recurseTimes) {\n      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n          ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n      }\n      var primitive = formatPrimitive(ctx, value);\n      if (primitive) {\n        return primitive;\n      }\n      var keys = Object.keys(value);\n      var visibleKeys = arrayToHash(keys);\n      if (ctx.showHidden) {\n        keys = Object.getOwnPropertyNames(value);\n      }\n      if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) {\n        return formatError(value);\n      }\n      if (keys.length === 0) {\n        if (isFunction(value)) {\n          var name = value.name ? \": \" + value.name : \"\";\n          return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n        }\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        }\n        if (isDate(value)) {\n          return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n        }\n        if (isError(value)) {\n          return formatError(value);\n        }\n      }\n      var base = \"\", array = false, braces = [\"{\", \"}\"];\n      if (isArray(value)) {\n        array = true;\n        braces = [\"[\", \"]\"];\n      }\n      if (isFunction(value)) {\n        var n = value.name ? \": \" + value.name : \"\";\n        base = \" [Function\" + n + \"]\";\n      }\n      if (isRegExp(value)) {\n        base = \" \" + RegExp.prototype.toString.call(value);\n      }\n      if (isDate(value)) {\n        base = \" \" + Date.prototype.toUTCString.call(value);\n      }\n      if (isError(value)) {\n        base = \" \" + formatError(value);\n      }\n      if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n      }\n      if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        } else {\n          return ctx.stylize(\"[Object]\", \"special\");\n        }\n      }\n      ctx.seen.push(value);\n      var output;\n      if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n      } else {\n        output = keys.map(function(key) {\n          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n      }\n      ctx.seen.pop();\n      return reduceToSingleString(output, base, braces);\n    }\n    function formatPrimitive(ctx, value) {\n      if (isUndefined(value))\n        return ctx.stylize(\"undefined\", \"undefined\");\n      if (isString(value)) {\n        var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n        return ctx.stylize(simple, \"string\");\n      }\n      if (isNumber(value))\n        return ctx.stylize(\"\" + value, \"number\");\n      if (isBoolean(value))\n        return ctx.stylize(\"\" + value, \"boolean\");\n      if (isNull(value))\n        return ctx.stylize(\"null\", \"null\");\n    }\n    function formatError(value) {\n      return \"[\" + Error.prototype.toString.call(value) + \"]\";\n    }\n    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n      var output = [];\n      for (var i = 0, l = value.length; i < l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n          output.push(formatProperty(\n            ctx,\n            value,\n            recurseTimes,\n            visibleKeys,\n            String(i),\n            true\n          ));\n        } else {\n          output.push(\"\");\n        }\n      }\n      keys.forEach(function(key) {\n        if (!key.match(/^\\d+$/)) {\n          output.push(formatProperty(\n            ctx,\n            value,\n            recurseTimes,\n            visibleKeys,\n            key,\n            true\n          ));\n        }\n      });\n      return output;\n    }\n    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n      var name, str, desc;\n      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n      if (desc.get) {\n        if (desc.set) {\n          str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n        } else {\n          str = ctx.stylize(\"[Getter]\", \"special\");\n        }\n      } else {\n        if (desc.set) {\n          str = ctx.stylize(\"[Setter]\", \"special\");\n        }\n      }\n      if (!hasOwnProperty(visibleKeys, key)) {\n        name = \"[\" + key + \"]\";\n      }\n      if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n          if (isNull(recurseTimes)) {\n            str = formatValue(ctx, desc.value, null);\n          } else {\n            str = formatValue(ctx, desc.value, recurseTimes - 1);\n          }\n          if (str.indexOf(\"\\n\") > -1) {\n            if (array) {\n              str = str.split(\"\\n\").map(function(line) {\n                return \"  \" + line;\n              }).join(\"\\n\").slice(2);\n            } else {\n              str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n                return \"   \" + line;\n              }).join(\"\\n\");\n            }\n          }\n        } else {\n          str = ctx.stylize(\"[Circular]\", \"special\");\n        }\n      }\n      if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\"\" + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.slice(1, -1);\n          name = ctx.stylize(name, \"name\");\n        } else {\n          name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n          name = ctx.stylize(name, \"string\");\n        }\n      }\n      return name + \": \" + str;\n    }\n    function reduceToSingleString(output, base, braces) {\n      var numLinesEst = 0;\n      var length = output.reduce(function(prev, cur) {\n        numLinesEst++;\n        if (cur.indexOf(\"\\n\") >= 0)\n          numLinesEst++;\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n      }, 0);\n      if (length > 60) {\n        return braces[0] + (base === \"\" ? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n      }\n      return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n    }\n    exports.types = require_types();\n    function isArray(ar) {\n      return Array.isArray(ar);\n    }\n    exports.isArray = isArray;\n    function isBoolean(arg) {\n      return typeof arg === \"boolean\";\n    }\n    exports.isBoolean = isBoolean;\n    function isNull(arg) {\n      return arg === null;\n    }\n    exports.isNull = isNull;\n    function isNullOrUndefined(arg) {\n      return arg == null;\n    }\n    exports.isNullOrUndefined = isNullOrUndefined;\n    function isNumber(arg) {\n      return typeof arg === \"number\";\n    }\n    exports.isNumber = isNumber;\n    function isString(arg) {\n      return typeof arg === \"string\";\n    }\n    exports.isString = isString;\n    function isSymbol(arg) {\n      return typeof arg === \"symbol\";\n    }\n    exports.isSymbol = isSymbol;\n    function isUndefined(arg) {\n      return arg === void 0;\n    }\n    exports.isUndefined = isUndefined;\n    function isRegExp(re) {\n      return isObject(re) && objectToString(re) === \"[object RegExp]\";\n    }\n    exports.isRegExp = isRegExp;\n    exports.types.isRegExp = isRegExp;\n    function isObject(arg) {\n      return typeof arg === \"object\" && arg !== null;\n    }\n    exports.isObject = isObject;\n    function isDate(d) {\n      return isObject(d) && objectToString(d) === \"[object Date]\";\n    }\n    exports.isDate = isDate;\n    exports.types.isDate = isDate;\n    function isError(e) {\n      return isObject(e) && (objectToString(e) === \"[object Error]\" || e instanceof Error);\n    }\n    exports.isError = isError;\n    exports.types.isNativeError = isError;\n    function isFunction(arg) {\n      return typeof arg === \"function\";\n    }\n    exports.isFunction = isFunction;\n    function isPrimitive(arg) {\n      return arg === null || typeof arg === \"boolean\" || typeof arg === \"number\" || typeof arg === \"string\" || typeof arg === \"symbol\" || // ES6 symbol\n      typeof arg === \"undefined\";\n    }\n    exports.isPrimitive = isPrimitive;\n    exports.isBuffer = require_isBufferBrowser();\n    function objectToString(o) {\n      return Object.prototype.toString.call(o);\n    }\n    function pad(n) {\n      return n < 10 ? \"0\" + n.toString(10) : n.toString(10);\n    }\n    var months = [\n      \"Jan\",\n      \"Feb\",\n      \"Mar\",\n      \"Apr\",\n      \"May\",\n      \"Jun\",\n      \"Jul\",\n      \"Aug\",\n      \"Sep\",\n      \"Oct\",\n      \"Nov\",\n      \"Dec\"\n    ];\n    function timestamp() {\n      var d = /* @__PURE__ */ new Date();\n      var time = [\n        pad(d.getHours()),\n        pad(d.getMinutes()),\n        pad(d.getSeconds())\n      ].join(\":\");\n      return [d.getDate(), months[d.getMonth()], time].join(\" \");\n    }\n    exports.log = function() {\n      console.log(\"%s - %s\", timestamp(), exports.format.apply(exports, arguments));\n    };\n    exports.inherits = require_inherits_browser();\n    exports._extend = function(origin, add) {\n      if (!add || !isObject(add))\n        return origin;\n      var keys = Object.keys(add);\n      var i = keys.length;\n      while (i--) {\n        origin[keys[i]] = add[keys[i]];\n      }\n      return origin;\n    };\n    function hasOwnProperty(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n    var kCustomPromisifiedSymbol = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : void 0;\n    exports.promisify = function promisify(original) {\n      if (typeof original !== \"function\")\n        throw new TypeError('The \"original\" argument must be of type Function');\n      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n        var fn = original[kCustomPromisifiedSymbol];\n        if (typeof fn !== \"function\") {\n          throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n        }\n        Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n          value: fn,\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n        return fn;\n      }\n      function fn() {\n        var promiseResolve, promiseReject;\n        var promise = new Promise(function(resolve, reject) {\n          promiseResolve = resolve;\n          promiseReject = reject;\n        });\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        args.push(function(err, value) {\n          if (err) {\n            promiseReject(err);\n          } else {\n            promiseResolve(value);\n          }\n        });\n        try {\n          original.apply(this, args);\n        } catch (err) {\n          promiseReject(err);\n        }\n        return promise;\n      }\n      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n      if (kCustomPromisifiedSymbol)\n        Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n          value: fn,\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n      return Object.defineProperties(\n        fn,\n        getOwnPropertyDescriptors(original)\n      );\n    };\n    exports.promisify.custom = kCustomPromisifiedSymbol;\n    function callbackifyOnRejected(reason, cb) {\n      if (!reason) {\n        var newReason = new Error(\"Promise was rejected with a falsy value\");\n        newReason.reason = reason;\n        reason = newReason;\n      }\n      return cb(reason);\n    }\n    function callbackify(original) {\n      if (typeof original !== \"function\") {\n        throw new TypeError('The \"original\" argument must be of type Function');\n      }\n      function callbackified() {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        var maybeCb = args.pop();\n        if (typeof maybeCb !== \"function\") {\n          throw new TypeError(\"The last argument must be of type Function\");\n        }\n        var self = this;\n        var cb = function() {\n          return maybeCb.apply(self, arguments);\n        };\n        original.apply(this, args).then(\n          function(ret) {\n            process.nextTick(cb.bind(null, null, ret));\n          },\n          function(rej) {\n            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));\n          }\n        );\n      }\n      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n      Object.defineProperties(\n        callbackified,\n        getOwnPropertyDescriptors(original)\n      );\n      return callbackified;\n    }\n    exports.callbackify = callbackify;\n  }\n});\n\nexport {\n  require_has_property_descriptors,\n  require_define_data_property,\n  require_call_bind,\n  require_call_bind2,\n  require_util\n};\n//# sourceMappingURL=chunk-RGVVW7F2.mjs.map\n","// packages/common/node-std/src/process.js\nfunction nextTick(fun, ...args) {\n  if (args.length > 0) {\n    queueMicrotask(() => fun(...args));\n  } else {\n    queueMicrotask(fun);\n  }\n}\nvar title = \"browser\";\nvar platform = \"browser\";\nvar browser = true;\nvar env = {};\nvar argv = [];\nvar version = \"\";\nvar versions = {};\nvar release = {};\nvar config = {};\nfunction noop() {\n}\nvar on = noop;\nvar addListener = noop;\nvar once = noop;\nvar off = noop;\nvar removeListener = noop;\nvar removeAllListeners = noop;\nvar emit = noop;\nfunction binding(name) {\n  throw new Error(\"process.binding is not supported\");\n}\nfunction cwd() {\n  return \"/\";\n}\nfunction chdir(dir) {\n  throw new Error(\"process.chdir is not supported\");\n}\nfunction umask() {\n  return 0;\n}\nvar performance = globalThis.performance || {};\nvar performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {\n  return (/* @__PURE__ */ new Date()).getTime();\n};\nfunction hrtime(previousTimestamp) {\n  var clocktime = performanceNow.call(performance) * 1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n    if (nanoseconds < 0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [seconds, nanoseconds];\n}\nhrtime.bigint = function() {\n  var clocktime = performanceNow.call(performance) * 1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n  return BigInt(seconds * 1e9) + BigInt(nanoseconds);\n};\nvar startTime = /* @__PURE__ */ new Date();\nfunction uptime() {\n  var currentTime = /* @__PURE__ */ new Date();\n  var dif = currentTime - startTime;\n  return dif / 1e3;\n}\nvar process = {\n  nextTick,\n  title,\n  browser,\n  env,\n  argv,\n  version,\n  versions,\n  on,\n  addListener,\n  once,\n  off,\n  removeListener,\n  removeAllListeners,\n  emit,\n  binding,\n  cwd,\n  chdir,\n  umask,\n  hrtime,\n  platform,\n  release,\n  config,\n  uptime\n};\nvar defines = {};\nObject.keys(defines).forEach((key) => {\n  const segs = key.split(\".\");\n  let target = process;\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i];\n    if (i === segs.length - 1) {\n      target[seg] = defines[key];\n    } else {\n      target = target[seg] || (target[seg] = {});\n    }\n  }\n});\n\nexport {\n  process\n};\n//# sourceMappingURL=chunk-QWZSWMMO.mjs.map\n","import {\n  __commonJS\n} from \"./chunk-MJPHVYKR.mjs\";\n\n// node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\nvar require_base64_js = __commonJS({\n  \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n    \"use strict\";\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for (i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    var i;\n    var len;\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      }\n      var validLen = b64.indexOf(\"=\");\n      if (validLen === -1)\n        validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join(\"\");\n    }\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n        );\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n        );\n      }\n      return parts.join(\"\");\n    }\n  }\n});\n\n// node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\nvar require_ieee754 = __commonJS({\n  \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n    exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n      }\n      e = e << mLen | m;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n      }\n      buffer[offset + i - d] |= s * 128;\n    };\n  }\n});\n\n// node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js\nvar require_buffer = __commonJS({\n  \"node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js\"(exports) {\n    \"use strict\";\n    var base64 = require_base64_js();\n    var ieee754 = require_ieee754();\n    var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    var K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\n        \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n      );\n    }\n    function typedArraySupport() {\n      try {\n        const arr = new Uint8Array(1);\n        const proto = { foo: function() {\n          return 42;\n        } };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    Object.defineProperty(Buffer.prototype, \"parent\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer.isBuffer(this))\n          return void 0;\n        return this.buffer;\n      }\n    });\n    Object.defineProperty(Buffer.prototype, \"offset\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer.isBuffer(this))\n          return void 0;\n        return this.byteOffset;\n      }\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      const buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer.prototype);\n      return buf;\n    }\n    function Buffer(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    Buffer.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      }\n      const valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer.from(valueOf, encodingOrOffset, length);\n      }\n      const b = fromObject(value);\n      if (b)\n        return b;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n      }\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n      );\n    }\n    Buffer.from = function(value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    Buffer.alloc = function(size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    Buffer.allocUnsafe = function(size) {\n      return allocUnsafe(size);\n    };\n    Buffer.allocUnsafeSlow = function(size) {\n      return allocUnsafe(size);\n    };\n    function fromString(string, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      const length = byteLength(string, encoding) | 0;\n      let buf = createBuffer(length);\n      const actual = buf.write(string, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    function fromArrayLike(array) {\n      const length = array.length < 0 ? 0 : checked(array.length) | 0;\n      const buf = createBuffer(length);\n      for (let i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n      }\n      return buf;\n    }\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    function fromArrayBuffer(array, byteOffset, length) {\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      let buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array, byteOffset);\n      } else {\n        buf = new Uint8Array(array, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer.prototype);\n      return buf;\n    }\n    function fromObject(obj) {\n      if (Buffer.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer.alloc(+length);\n    }\n    Buffer.isBuffer = function isBuffer(b) {\n      return b != null && b._isBuffer === true && b !== Buffer.prototype;\n    };\n    Buffer.compare = function compare(a, b) {\n      if (isInstance(a, Uint8Array))\n        a = Buffer.from(a, a.offset, a.byteLength);\n      if (isInstance(b, Uint8Array))\n        b = Buffer.from(b, b.offset, b.byteLength);\n      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      }\n      if (a === b)\n        return 0;\n      let x = a.length;\n      let y = b.length;\n      for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n          x = a[i];\n          y = b[i];\n          break;\n        }\n      }\n      if (x < y)\n        return -1;\n      if (y < x)\n        return 1;\n      return 0;\n    };\n    Buffer.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    };\n    Buffer.concat = function concat(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer.alloc(0);\n      }\n      let i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      const buffer = Buffer.allocUnsafe(length);\n      let pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer.length) {\n            if (!Buffer.isBuffer(buf))\n              buf = Buffer.from(buf);\n            buf.copy(buffer, pos);\n          } else {\n            Uint8Array.prototype.set.call(\n              buffer,\n              buf,\n              pos\n            );\n          }\n        } else if (!Buffer.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer;\n    };\n    function byteLength(string, encoding) {\n      if (Buffer.isBuffer(string)) {\n        return string.length;\n      }\n      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n      }\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n        );\n      }\n      const len = string.length;\n      const mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0)\n        return 0;\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      let loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding)\n        encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase)\n              throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer.prototype._isBuffer = true;\n    function swap(b, n, m) {\n      const i = b[n];\n      b[n] = b[m];\n      b[m] = i;\n    }\n    Buffer.prototype.swap16 = function swap16() {\n      const len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (let i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    };\n    Buffer.prototype.swap32 = function swap32() {\n      const len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (let i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    };\n    Buffer.prototype.swap64 = function swap64() {\n      const len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (let i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    };\n    Buffer.prototype.toString = function toString() {\n      const length = this.length;\n      if (length === 0)\n        return \"\";\n      if (arguments.length === 0)\n        return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n    Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n    Buffer.prototype.equals = function equals(b) {\n      if (!Buffer.isBuffer(b))\n        throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b)\n        return true;\n      return Buffer.compare(this, b) === 0;\n    };\n    Buffer.prototype.inspect = function inspect() {\n      let str = \"\";\n      const max = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max)\n        str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    };\n    if (customInspectSymbol) {\n      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n    }\n    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer.isBuffer(target)) {\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n        );\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target)\n        return 0;\n      let x = thisEnd - thisStart;\n      let y = end - start;\n      const len = Math.min(x, y);\n      const thisCopy = this.slice(thisStart, thisEnd);\n      const targetCopy = target.slice(start, end);\n      for (let i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n      if (x < y)\n        return -1;\n      if (y < x)\n        return 1;\n      return 0;\n    };\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      if (buffer.length === 0)\n        return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n      }\n      if (byteOffset < 0)\n        byteOffset = buffer.length + byteOffset;\n      if (byteOffset >= buffer.length) {\n        if (dir)\n          return -1;\n        else\n          byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir)\n          byteOffset = 0;\n        else\n          return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n      }\n      if (Buffer.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      let indexSize = 1;\n      let arrLength = arr.length;\n      let valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      let i;\n      if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1)\n              foundIndex = i;\n            if (i - foundIndex + 1 === valLength)\n              return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1)\n              i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength)\n          byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j = 0; j < valLength; j++) {\n            if (read(arr, i + j) !== read(val, j)) {\n              found = false;\n              break;\n            }\n          }\n          if (found)\n            return i;\n        }\n      }\n      return -1;\n    }\n    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      const remaining = buf.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      const strLen = string.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      let i;\n      for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed))\n          return i;\n        buf[offset + i] = parsed;\n      }\n      return i;\n    }\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    Buffer.prototype.write = function write(string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n      } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0)\n            encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      }\n      const remaining = this.length - offset;\n      if (length === void 0 || length > remaining)\n        length = remaining;\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding)\n        encoding = \"utf8\";\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string, offset, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string, offset, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string, offset, length);\n          case \"base64\":\n            return base64Write(this, string, offset, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string, offset, length);\n          default:\n            if (loweredCase)\n              throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n    Buffer.prototype.toJSON = function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      const res = [];\n      let i = start;\n      while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          let secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    var MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      const len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      let res = \"\";\n      let i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n        );\n      }\n      return res;\n    }\n    function asciiSlice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    function latin1Slice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    function hexSlice(buf, start, end) {\n      const len = buf.length;\n      if (!start || start < 0)\n        start = 0;\n      if (!end || end < 0 || end > len)\n        end = len;\n      let out = \"\";\n      for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    function utf16leSlice(buf, start, end) {\n      const bytes = buf.slice(start, end);\n      let res = \"\";\n      for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    Buffer.prototype.slice = function slice(start, end) {\n      const len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0)\n          start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0)\n          end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start)\n        end = start;\n      const newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer.prototype);\n      return newBuf;\n    };\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0)\n        throw new RangeError(\"offset is not uint\");\n      if (offset + ext > length)\n        throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      return val;\n    };\n    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset, byteLength2, this.length);\n      }\n      let val = this[offset + --byteLength2];\n      let mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset + --byteLength2] * mul;\n      }\n      return val;\n    };\n    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 1, this.length);\n      return this[offset];\n    };\n    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    };\n    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    };\n    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n    };\n    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    };\n    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n      return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    });\n    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n      return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    });\n    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let i = byteLength2;\n      let mul = 1;\n      let val = this[offset + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 128))\n        return this[offset];\n      return (255 - this[offset] + 1) * -1;\n    };\n    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      const val = this[offset] | this[offset + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      const val = this[offset + 1] | this[offset] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    };\n    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    };\n    Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n    });\n    Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = (first << 24) + // Overflow\n      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n    });\n    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, true, 23, 4);\n    };\n    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, false, 23, 4);\n    };\n    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, true, 52, 8);\n    };\n    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, false, 52, 8);\n    };\n    function checkInt(buf, value, offset, ext, max, min) {\n      if (!Buffer.isBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max || value < min)\n        throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length)\n        throw new RangeError(\"Index out of range\");\n    }\n    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let mul = 1;\n      let i = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 1, 255, 0);\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 255;\n      return offset + 4;\n    };\n    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    function wrtBigUInt64LE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      return offset;\n    }\n    function wrtBigUInt64BE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset + 7] = lo;\n      lo = lo >> 8;\n      buf[offset + 6] = lo;\n      lo = lo >> 8;\n      buf[offset + 5] = lo;\n      lo = lo >> 8;\n      buf[offset + 4] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset + 3] = hi;\n      hi = hi >> 8;\n      buf[offset + 2] = hi;\n      hi = hi >> 8;\n      buf[offset + 1] = hi;\n      hi = hi >> 8;\n      buf[offset] = hi;\n      return offset + 8;\n    }\n    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = 0;\n      let mul = 1;\n      let sub = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      let sub = 0;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 1, 127, -128);\n      if (value < 0)\n        value = 255 + value + 1;\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n      return offset + 4;\n    };\n    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      if (value < 0)\n        value = 4294967295 + value + 1;\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function checkIEEE754(buf, value, offset, ext, max, min) {\n      if (offset + ext > buf.length)\n        throw new RangeError(\"Index out of range\");\n      if (offset < 0)\n        throw new RangeError(\"Index out of range\");\n    }\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    };\n    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    };\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    };\n    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    };\n    Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!Buffer.isBuffer(target))\n        throw new TypeError(\"argument should be a Buffer\");\n      if (!start)\n        start = 0;\n      if (!end && end !== 0)\n        end = this.length;\n      if (targetStart >= target.length)\n        targetStart = target.length;\n      if (!targetStart)\n        targetStart = 0;\n      if (end > 0 && end < start)\n        end = start;\n      if (end === start)\n        return 0;\n      if (target.length === 0 || this.length === 0)\n        return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length)\n        throw new RangeError(\"Index out of range\");\n      if (end < 0)\n        throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length)\n        end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart\n        );\n      }\n      return len;\n    };\n    Buffer.prototype.fill = function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          const code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val)\n        val = 0;\n      let i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    };\n    var errors = {};\n    function E(sym, getMessage, Base) {\n      errors[sym] = class NodeError extends Base {\n        constructor() {\n          super();\n          Object.defineProperty(this, \"message\", {\n            value: getMessage.apply(this, arguments),\n            writable: true,\n            configurable: true\n          });\n          this.name = `${this.name} [${sym}]`;\n          this.stack;\n          delete this.name;\n        }\n        get code() {\n          return sym;\n        }\n        set code(value) {\n          Object.defineProperty(this, \"code\", {\n            configurable: true,\n            enumerable: true,\n            value,\n            writable: true\n          });\n        }\n        toString() {\n          return `${this.name} [${sym}]: ${this.message}`;\n        }\n      };\n    }\n    E(\n      \"ERR_BUFFER_OUT_OF_BOUNDS\",\n      function(name) {\n        if (name) {\n          return `${name} is outside of buffer bounds`;\n        }\n        return \"Attempt to access memory outside buffer bounds\";\n      },\n      RangeError\n    );\n    E(\n      \"ERR_INVALID_ARG_TYPE\",\n      function(name, actual) {\n        return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n      },\n      TypeError\n    );\n    E(\n      \"ERR_OUT_OF_RANGE\",\n      function(str, range, input) {\n        let msg = `The value of \"${str}\" is out of range.`;\n        let received = input;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        }\n        msg += ` It must be ${range}. Received ${received}`;\n        return msg;\n      },\n      RangeError\n    );\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function checkBounds(buf, offset, byteLength2) {\n      validateNumber(offset, \"offset\");\n      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n        boundsError(offset, buf.length - (byteLength2 + 1));\n      }\n    }\n    function checkIntBI(value, min, max, buf, offset, byteLength2) {\n      if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength2 > 3) {\n          if (min === 0 || min === BigInt(0)) {\n            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n          } else {\n            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n          }\n        } else {\n          range = `>= ${min}${n} and <= ${max}${n}`;\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n      }\n      checkBounds(buf, offset, byteLength2);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n    }\n    function boundsError(value, length, type) {\n      if (Math.floor(value) !== value) {\n        validateNumber(value, type);\n        throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n      }\n      if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n      }\n      throw new errors.ERR_OUT_OF_RANGE(\n        type || \"offset\",\n        `>= ${type ? 1 : 0} and <= ${length}`,\n        value\n      );\n    }\n    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2)\n        return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      let codePoint;\n      const length = string.length;\n      let leadSurrogate = null;\n      const bytes = [];\n      for (let i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0)\n            break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0)\n            break;\n          bytes.push(\n            codePoint >> 6 | 192,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0)\n            break;\n          bytes.push(\n            codePoint >> 12 | 224,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0)\n            break;\n          bytes.push(\n            codePoint >> 18 | 240,\n            codePoint >> 12 & 63 | 128,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    function asciiToBytes(str) {\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    function utf16leToBytes(str, units) {\n      let c, hi, lo;\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0)\n          break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    function blitBuffer(src, dst, offset, length) {\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length)\n          break;\n        dst[i + offset] = src[i];\n      }\n      return i;\n    }\n    function isInstance(obj, type) {\n      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n    }\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    var hexSliceLookupTable = function() {\n      const alphabet = \"0123456789abcdef\";\n      const table = new Array(256);\n      for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j = 0; j < 16; ++j) {\n          table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n      }\n      return table;\n    }();\n    function defineBigIntMethod(fn) {\n      return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n    }\n    function BufferBigIntNotDefined() {\n      throw new Error(\"BigInt not supported\");\n    }\n  }\n});\n\nexport {\n  require_buffer\n};\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n//# sourceMappingURL=chunk-HFGMGNFE.mjs.map\n","import {\n  process\n} from \"./chunk-QWZSWMMO.mjs\";\nimport {\n  require_buffer\n} from \"./chunk-HFGMGNFE.mjs\";\nimport {\n  __toESM\n} from \"./chunk-MJPHVYKR.mjs\";\n\n// packages/common/node-std/src/globals.js\nvar import_buffer = __toESM(require_buffer());\nglobalThis.global = globalThis;\nglobalThis.Buffer = import_buffer.Buffer;\nglobalThis.process = process;\n//# sourceMappingURL=chunk-P5GBL7TE.mjs.map\n","import {\n  require_util\n} from \"./chunk-RGVVW7F2.mjs\";\nimport \"./chunk-P5GBL7TE.mjs\";\nimport \"./chunk-QWZSWMMO.mjs\";\nimport \"./chunk-HFGMGNFE.mjs\";\nimport {\n  __toESM\n} from \"./chunk-MJPHVYKR.mjs\";\n\n// packages/common/node-std/src/util.js\nvar import_util = __toESM(require_util());\nvar import_util2 = __toESM(require_util());\nvar util_default = import_util.default;\nvar export_callbackify = import_util2.callbackify;\nvar export_inspect = import_util2.inspect;\nvar export_promisify = import_util2.promisify;\nexport {\n  export_callbackify as callbackify,\n  util_default as default,\n  export_inspect as inspect,\n  export_promisify as promisify\n};\n//# sourceMappingURL=util.mjs.map\n","'use strict';\n\nconst stringReplaceAll = (string, substring, replacer) => {\n\tlet index = string.indexOf(substring);\n\tif (index === -1) {\n\t\treturn string;\n\t}\n\n\tconst substringLength = substring.length;\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\treturnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n\t\tendIndex = index + substringLength;\n\t\tindex = string.indexOf(substring, endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nconst stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\tconst gotCR = string[index - 1] === '\\r';\n\t\treturnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\\r\\n' : '\\n') + postfix;\n\t\tendIndex = index + 1;\n\t\tindex = string.indexOf('\\n', endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nmodule.exports = {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n};\n","'use strict';\nconst TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tconst u = c[0] === 'u';\n\tconst bracket = c[1] === '{';\n\n\tif ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\tif (u && bracket) {\n\t\treturn String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, arguments_) {\n\tconst results = [];\n\tconst chunks = arguments_.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tconst number = Number(chunk);\n\t\tif (!Number.isNaN(number)) {\n\t\t\tresults.push(number);\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const [styleName, styles] of Object.entries(enabled)) {\n\t\tif (!Array.isArray(styles)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(styleName in current)) {\n\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t}\n\n\t\tcurrent = styles.length > 0 ? current[styleName](...styles) : current[styleName];\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, temporary) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttemporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n\t\tif (escapeCharacter) {\n\t\t\tchunk.push(unescape(escapeCharacter));\n\t\t} else if (style) {\n\t\t\tconst string = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(character);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMessage);\n\t}\n\n\treturn chunks.join('');\n};\n","'use strict';\nconst ansiStyles = require('ansi-styles');\nconst {stdout: stdoutColor, stderr: stderrColor} = require('supports-color');\nconst {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n} = require('./util');\n\nconst {isArray} = Array;\n\n// `supportsColor.level`  `ansiStyles.color[name]` mapping\nconst levelMapping = [\n\t'ansi',\n\t'ansi',\n\t'ansi256',\n\t'ansi16m'\n];\n\nconst styles = Object.create(null);\n\nconst applyOptions = (object, options = {}) => {\n\tif (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n\t\tthrow new Error('The `level` option should be an integer from 0 to 3');\n\t}\n\n\t// Detect level if not set manually\n\tconst colorLevel = stdoutColor ? stdoutColor.level : 0;\n\tobject.level = options.level === undefined ? colorLevel : options.level;\n};\n\nclass ChalkClass {\n\tconstructor(options) {\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn chalkFactory(options);\n\t}\n}\n\nconst chalkFactory = options => {\n\tconst chalk = {};\n\tapplyOptions(chalk, options);\n\n\tchalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);\n\n\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\tObject.setPrototypeOf(chalk.template, chalk);\n\n\tchalk.template.constructor = () => {\n\t\tthrow new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');\n\t};\n\n\tchalk.template.Instance = ChalkClass;\n\n\treturn chalk.template;\n};\n\nfunction Chalk(options) {\n\treturn chalkFactory(options);\n}\n\nfor (const [styleName, style] of Object.entries(ansiStyles)) {\n\tstyles[styleName] = {\n\t\tget() {\n\t\t\tconst builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n\t\t\tObject.defineProperty(this, styleName, {value: builder});\n\t\t\treturn builder;\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\tconst builder = createBuilder(this, this._styler, true);\n\t\tObject.defineProperty(this, 'visible', {value: builder});\n\t\treturn builder;\n\t}\n};\n\nconst usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];\n\nfor (const model of usedModels) {\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nfor (const model of usedModels) {\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, {\n\t...styles,\n\tlevel: {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn this._generator.level;\n\t\t},\n\t\tset(level) {\n\t\t\tthis._generator.level = level;\n\t\t}\n\t}\n});\n\nconst createStyler = (open, close, parent) => {\n\tlet openAll;\n\tlet closeAll;\n\tif (parent === undefined) {\n\t\topenAll = open;\n\t\tcloseAll = close;\n\t} else {\n\t\topenAll = parent.openAll + open;\n\t\tcloseAll = close + parent.closeAll;\n\t}\n\n\treturn {\n\t\topen,\n\t\tclose,\n\t\topenAll,\n\t\tcloseAll,\n\t\tparent\n\t};\n};\n\nconst createBuilder = (self, _styler, _isEmpty) => {\n\tconst builder = (...arguments_) => {\n\t\tif (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {\n\t\t\t// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`\n\t\t\treturn applyStyle(builder, chalkTag(builder, ...arguments_));\n\t\t}\n\n\t\t// Single argument is hot path, implicit coercion is faster than anything\n\t\t// eslint-disable-next-line no-implicit-coercion\n\t\treturn applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));\n\t};\n\n\t// We alter the prototype because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tObject.setPrototypeOf(builder, proto);\n\n\tbuilder._generator = self;\n\tbuilder._styler = _styler;\n\tbuilder._isEmpty = _isEmpty;\n\n\treturn builder;\n};\n\nconst applyStyle = (self, string) => {\n\tif (self.level <= 0 || !string) {\n\t\treturn self._isEmpty ? '' : string;\n\t}\n\n\tlet styler = self._styler;\n\n\tif (styler === undefined) {\n\t\treturn string;\n\t}\n\n\tconst {openAll, closeAll} = styler;\n\tif (string.indexOf('\\u001B') !== -1) {\n\t\twhile (styler !== undefined) {\n\t\t\t// Replace any instances already present with a re-opening code\n\t\t\t// otherwise only the part of the string until said closing code\n\t\t\t// will be colored, and the rest will simply be 'plain'.\n\t\t\tstring = stringReplaceAll(string, styler.close, styler.open);\n\n\t\t\tstyler = styler.parent;\n\t\t}\n\t}\n\n\t// We can move both next actions out of loop, because remaining actions in loop won't have\n\t// any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n\t// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n\tconst lfIndex = string.indexOf('\\n');\n\tif (lfIndex !== -1) {\n\t\tstring = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n\t}\n\n\treturn openAll + string + closeAll;\n};\n\nlet template;\nconst chalkTag = (chalk, ...strings) => {\n\tconst [firstString] = strings;\n\n\tif (!isArray(firstString) || !isArray(firstString.raw)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn strings.join(' ');\n\t}\n\n\tconst arguments_ = strings.slice(1);\n\tconst parts = [firstString.raw[0]];\n\n\tfor (let i = 1; i < firstString.length; i++) {\n\t\tparts.push(\n\t\t\tString(arguments_[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'),\n\t\t\tString(firstString.raw[i])\n\t\t);\n\t}\n\n\tif (template === undefined) {\n\t\ttemplate = require('./templates');\n\t}\n\n\treturn template(chalk, parts.join(''));\n};\n\nObject.defineProperties(Chalk.prototype, styles);\n\nconst chalk = Chalk(); // eslint-disable-line new-cap\nchalk.supportsColor = stdoutColor;\nchalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap\nchalk.stderr.supportsColor = stderrColor;\n\nmodule.exports = chalk;\n","// packages/common/debug/src/assert.ts\nvar checkType = (value) => value;\n\n// packages/common/debug/src/error-handler.ts\nimport { EventEmitter } from \"@dxos/node-std/events\";\nvar ErrorHandler = class extends EventEmitter {\n  constructor() {\n    super();\n    this._listener = (event) => {\n      const cause = event.error || event.reason || event;\n      const message = cause.stack || cause.message || cause.toString();\n      this.emit(\"error\", message);\n    };\n    window.addEventListener(\"error\", this._listener);\n    window.addEventListener(\"unhandledrejection\", this._listener);\n  }\n  reset() {\n    window.removeEventListener(\"error\", this._listener);\n    window.removeEventListener(\"unhandledrejection\", this._listener);\n  }\n};\n\n// packages/common/debug/src/error-stream.ts\nvar ErrorStream = class {\n  constructor() {\n    this._unhandledErrors = 0;\n  }\n  assertNoUnhandledErrors() {\n    if (this._unhandledErrors > 0) {\n      throw new Error(`Assertion failed: expected no unhandled errors to be thrown, but ${this._unhandledErrors} were thrown.`);\n    }\n  }\n  raise(error) {\n    if (this._handler) {\n      this._handler(error);\n    } else {\n      this._unhandledError(error);\n    }\n  }\n  handle(handler) {\n    this._handler = handler;\n  }\n  pipeTo(receiver) {\n    this.handle((error) => receiver.raise(error));\n  }\n  _unhandledError(error) {\n    this._unhandledErrors++;\n    setTimeout(() => {\n      throw error;\n    });\n  }\n};\n\n// packages/common/debug/src/fail.ts\nvar failUndefined = () => {\n  throw new Error(\"Required value was null or undefined.\");\n};\n\n// packages/common/debug/src/inspect.ts\nimport { inspect } from \"@dxos/node-std/util\";\nvar inspectObject = (obj) => {\n  const name = Object.getPrototypeOf(obj).constructor.name;\n  return obj.toJSON ? `${name}(${inspect(obj.toJSON())})` : String(obj);\n};\n\n// packages/common/debug/src/log-method.ts\nfunction logMethod(target, propertyName, descriptor) {\n  const method = descriptor.value;\n  descriptor.value = function(...args) {\n    console.log(`Called ${target.constructor.name}.${propertyName} ${args}`);\n    try {\n      const result = method.apply(this, args);\n      if (typeof result.catch === \"function\") {\n        result.catch((err) => {\n          console.log(`Rejected ${target.constructor.name}.${propertyName}`, err);\n        });\n      }\n      return result;\n    } catch (err) {\n      console.log(`Thrown ${target.constructor.name}.${propertyName}`, err);\n      throw err;\n    }\n  };\n}\n\n// packages/common/debug/src/raise.ts\nvar raise = (error) => {\n  throw error;\n};\n\n// packages/common/debug/src/snoop.ts\nvar SnoopLevel;\n(function(SnoopLevel2) {\n  SnoopLevel2[SnoopLevel2[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SnoopLevel2[SnoopLevel2[\"VERBOSE\"] = 1] = \"VERBOSE\";\n  SnoopLevel2[SnoopLevel2[\"BOLD\"] = 2] = \"BOLD\";\n})(SnoopLevel || (SnoopLevel = {}));\nvar Snoop = class _Snoop {\n  static stackFunction(err) {\n    const stack = err.stack.split(\"\\n\");\n    const match = stack[2].match(/.+\\((.+)\\).*/);\n    if (match) {\n      const [file, line] = match[1].split(\":\");\n      return `[${file.substring(file.lastIndexOf(\"/\") + 1)}:${line}]`;\n    }\n  }\n  constructor(_context) {\n    this._context = _context;\n  }\n  get verbose() {\n    return 1;\n  }\n  get bold() {\n    return 2;\n  }\n  format(prefix, name, args, level) {\n    const pre = prefix.repeat(level === 2 ? 8 : 2);\n    const label = this._context ? `${this._context}.${name}` : name;\n    const line = `${pre} ${label}${args}`;\n    return level === 2 ? [\n      pre,\n      line,\n      pre\n    ].join(\"\\n\") : line;\n  }\n  in(label, level, ...args) {\n    return this.format(\"<\", label, level === 0 ? \"\" : `(${String(...args)})`, level);\n  }\n  out(label, level, result) {\n    return this.format(\">\", label, level === 0 ? \"\" : ` = ${String(result)}`, level);\n  }\n  sync(f, label, level = 1) {\n    label = label ?? _Snoop.stackFunction(new Error());\n    return (...args) => {\n      console.log(this.in(label ?? \"\", level, ...args));\n      const r = f(...args);\n      console.log(this.out(label ?? \"\", level, r));\n      return r;\n    };\n  }\n  async(f, label, level = 1) {\n    label = label ?? _Snoop.stackFunction(new Error());\n    return async (...args) => {\n      console.log(this.in(label ?? \"\", level, ...args));\n      const r = await f(...args);\n      console.log(this.out(label ?? \"\", level, r));\n      return r;\n    };\n  }\n};\nvar snoop = new Snoop();\n\n// packages/common/debug/src/stack-trace.ts\nvar StackTrace = class {\n  constructor() {\n    this._stack = new Error();\n  }\n  /**\n  * Get stack formatted as string.\n  *\n  * @param skipFrames Number of frames to skip. By default the first frame would be the invocation of the StackTrace constructor.\n  * @returns\n  */\n  getStack(skipFrames = 0) {\n    const stack = this._stack.stack.split(\"\\n\");\n    return stack.slice(skipFrames + 2).join(\"\\n\");\n  }\n};\n\n// packages/common/debug/src/strings.ts\nvar truncate = (str = \"\", length = 8, pad = false) => {\n  if (str.length >= length - 1) {\n    return str.substring(0, length - 1) + \"\\u2026\";\n  } else {\n    return pad ? str.padEnd(length, typeof pad === \"boolean\" ? \" \" : pad[0]) : str;\n  }\n};\nvar truncateKey = (key, length = 8) => {\n  const str = String(key);\n  if (str.length <= length) {\n    return str;\n  }\n  return str.slice(0, length);\n};\n\n// packages/common/debug/src/throw.ts\nvar expectToThrow = async (test, errType = Error) => {\n  let thrown;\n  try {\n    await test();\n  } catch (err) {\n    thrown = err;\n  }\n  if (thrown === void 0 || !(thrown instanceof errType)) {\n    throw new Error(`Expected function to throw instance of ${errType.prototype.name}`);\n  }\n};\n\n// packages/common/debug/src/timeout-warning.ts\nvar warnAfterTimeout = async (timeout, context, body) => {\n  const stack = new StackTrace();\n  const timeoutId = setTimeout(() => {\n    console.warn(`Action \\`${context}\\` is taking more then ${timeout.toLocaleString()}ms to complete. This might be a bug.\n${stack.getStack()}`);\n  }, timeout);\n  try {\n    return await body();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n};\nfunction timed(timeout) {\n  return (target, propertyName, descriptor) => {\n    const method = descriptor.value;\n    descriptor.value = function(...args) {\n      return warnAfterTimeout(timeout, `${target.constructor.name}.${propertyName}`, () => method.apply(this, args));\n    };\n  };\n}\n\n// packages/common/debug/src/todo.ts\nvar todo = (message) => {\n  throw new Error(message ?? \"Not implemented.\");\n};\n\n// packages/common/debug/src/devtools-formatter.ts\nvar devtoolsFormatter = Symbol.for(\"devtoolsFormatter\");\nvar register = () => {\n  if (typeof window !== \"undefined\") {\n    (window.devtoolsFormatters ??= []).push({\n      header: (value, config) => {\n        const formatter = value[devtoolsFormatter];\n        if (formatter === void 0) {\n          return null;\n        }\n        if (typeof formatter !== \"object\" || formatter === null || typeof formatter.header !== \"function\") {\n          throw new Error(`Invalid devtools formatter for ${value.constructor.name}`);\n        }\n        return formatter.header(config);\n      },\n      hasBody: (value, config) => {\n        const formatter = value[devtoolsFormatter];\n        if (!formatter || !formatter.hasBody) {\n          return false;\n        }\n        return formatter.hasBody(config);\n      },\n      body: (value, config) => {\n        const formatter = value[devtoolsFormatter];\n        if (!formatter || !formatter.body) {\n          return null;\n        }\n        return formatter.body(config);\n      }\n    });\n  }\n};\nregister();\n\n// packages/common/debug/src/equality.ts\nvar equalsSymbol = Symbol.for(\"dxos.common.equals\");\nvar isEquatable = (value) => {\n  return typeof value === \"object\" && value !== null && typeof value[equalsSymbol] === \"function\";\n};\nvar isEqual = (value, other) => {\n  return value[equalsSymbol](other);\n};\nvar loadashEqualityFn = (value, other) => {\n  if (!isEquatable(value)) {\n    return void 0;\n  }\n  return isEqual(value, other);\n};\n\n// packages/common/debug/src/exposed-modules.ts\nvar exposeModule = (name, module) => {\n  EXPOSED_MODULES[name] = module;\n};\nvar importModule = (name) => {\n  if (EXPOSED_MODULES[name]) {\n    return EXPOSED_MODULES[name];\n  } else {\n    throw new Error(`Module ${name} is not exposed.`);\n  }\n};\nvar EXPOSED_MODULES = {};\nexport {\n  ErrorHandler,\n  ErrorStream,\n  Snoop,\n  SnoopLevel,\n  StackTrace,\n  checkType,\n  devtoolsFormatter,\n  equalsSymbol,\n  expectToThrow,\n  exposeModule,\n  failUndefined,\n  importModule,\n  inspectObject,\n  isEqual,\n  isEquatable,\n  loadashEqualityFn,\n  logMethod,\n  raise,\n  snoop,\n  timed,\n  todo,\n  truncate,\n  truncateKey,\n  warnAfterTimeout\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/common/log/src/index.ts\nimport omit from \"lodash.omit\";\nimport pick from \"lodash.pick\";\n\n// packages/common/log/src/config.ts\nvar LogLevel;\n(function(LogLevel2) {\n  LogLevel2[LogLevel2[\"TRACE\"] = 5] = \"TRACE\";\n  LogLevel2[LogLevel2[\"DEBUG\"] = 10] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 11] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 12] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 13] = \"ERROR\";\n})(LogLevel || (LogLevel = {}));\nvar levels = {\n  trace: 5,\n  debug: 10,\n  info: 11,\n  warn: 12,\n  error: 13\n};\nvar shortLevelName = {\n  [5]: \"T\",\n  [10]: \"D\",\n  [11]: \"I\",\n  [12]: \"W\",\n  [13]: \"E\"\n};\nvar LogProcessorType;\n(function(LogProcessorType2) {\n  LogProcessorType2[\"CONSOLE\"] = \"console\";\n  LogProcessorType2[\"BROWSER\"] = \"browser\";\n  LogProcessorType2[\"DEBUG\"] = \"debug\";\n})(LogProcessorType || (LogProcessorType = {}));\n\n// packages/common/log/src/scope.ts\nvar logInfoProperties = Symbol(\"logInfoProperties\");\nvar logInfo = (target, propertyKey, descriptor) => {\n  (target[logInfoProperties] ??= []).push(propertyKey);\n};\nvar gatherLogInfoFromScope = (scope) => {\n  if (!scope) {\n    return {};\n  }\n  const res = {};\n  const prototype = Object.getPrototypeOf(scope);\n  const infoProps = prototype[logInfoProperties] ?? [];\n  for (const prop of infoProps) {\n    try {\n      res[prop] = typeof scope[prop] === \"function\" ? scope[prop]() : scope[prop];\n    } catch (err) {\n      res[prop] = err.message;\n    }\n  }\n  return res;\n};\n\n// packages/common/log/src/context.ts\nvar matchFilter = (filter, level, path) => {\n  return level >= filter.level && (!filter.pattern || path.includes(filter.pattern));\n};\nvar shouldLog = (entry, filters) => {\n  if (filters === void 0) {\n    return true;\n  } else {\n    return filters.some((filter) => matchFilter(filter, entry.level, entry.meta?.F ?? \"\"));\n  }\n};\nvar getContextFromEntry = (entry) => {\n  let context;\n  if (entry.meta) {\n    const scopeInfo = gatherLogInfoFromScope(entry.meta.S);\n    if (Object.keys(scopeInfo).length > 0) {\n      context = Object.assign(context ?? {}, scopeInfo);\n    }\n  }\n  const entryContext = typeof entry.context === \"function\" ? entry.context() : entry.context;\n  if (entryContext) {\n    if (entryContext instanceof Error) {\n      const c = entryContext.context;\n      context = Object.assign(context ?? {}, {\n        error: entryContext.stack,\n        ...c\n      });\n    } else if (typeof entryContext === \"object\") {\n      context = Object.assign(context ?? {}, entryContext);\n    }\n  }\n  if (entry.error) {\n    const errorContext = entry.error.context;\n    context = Object.assign(context ?? {}, {\n      error: entry.error,\n      ...errorContext\n    });\n  }\n  return context && Object.keys(context).length > 0 ? context : void 0;\n};\n\n// packages/common/log/src/decorators.ts\nimport chalk from \"chalk\";\nimport { inspect } from \"@dxos/node-std/util\";\nvar nextPromiseId = 0;\nvar createMethodLogDecorator = (log2) => (arg0, arg1, meta) => (target, propertyKey, descriptor) => {\n  const method = descriptor.value;\n  const methodName = propertyKey;\n  descriptor.value = function(...args) {\n    const combinedMeta = {\n      F: \"\",\n      L: 0,\n      ...meta ?? {},\n      S: this\n    };\n    const formattedArgs = args.map((arg) => inspect(arg, false, 1, true)).join(\", \");\n    try {\n      const startTime = performance.now();\n      const result = method.apply(this, args);\n      if (isThenable(result)) {\n        const id = nextPromiseId++;\n        logAsyncBegin(log2, methodName, formattedArgs, id, combinedMeta);\n        result.then((resolvedValue) => {\n          logAsyncResolved(log2, methodName, resolvedValue, id, startTime, combinedMeta);\n        }, (err) => {\n          logAsyncRejected(log2, methodName, err, id, startTime, combinedMeta);\n        });\n      } else {\n        logSyncCall(log2, methodName, formattedArgs, result, combinedMeta);\n      }\n      return result;\n    } catch (err) {\n      logSyncError(log2, methodName, formattedArgs, err, combinedMeta);\n      throw err;\n    }\n  };\n  Object.defineProperty(descriptor.value, \"name\", {\n    value: methodName + \"$log\"\n  });\n};\nvar isThenable = (obj) => obj && typeof obj.then === \"function\";\nvar logSyncCall = (log2, methodName, formattedArgs, result, combinedMeta) => {\n  log2.info(`.${formatFunction(methodName)} (${formattedArgs}) ${chalk.gray(\"=>\")} ${inspect(result, false, 1, true)}`, {}, combinedMeta);\n};\nvar logSyncError = (log2, methodName, formattedArgs, err, combinedMeta) => {\n  log2.error(`.${formatFunction(methodName)} (${formattedArgs}) \\u{1F525} ${err}`, {}, combinedMeta);\n};\nvar logAsyncBegin = (log2, methodName, formattedArgs, promiseId, combinedMeta) => {\n  log2.info(`.${formatFunction(methodName)} \\u21B4 (${formattedArgs}) ${chalk.gray(\"=>\")} ${formatPromise(promiseId)}`, {}, combinedMeta);\n};\nvar logAsyncResolved = (log2, methodName, resolvedValue, promiseId, startTime, combinedMeta) => {\n  if (resolvedValue !== void 0) {\n    log2.info(`.${formatFunction(methodName)} \\u21B2 ${greenCheck} ${chalk.gray(\"resolve\")} ${formatPromise(promiseId)} ${formatTimeElapsed(startTime)} ${chalk.gray(\"=>\")} ${inspect(resolvedValue, false, 1, true)}`, {}, combinedMeta);\n  } else {\n    log2.info(`.${formatFunction(methodName)} \\u21B2 ${greenCheck} ${chalk.gray(\"resolve\")} ${formatPromise(promiseId)} ${formatTimeElapsed(startTime)}`, {}, combinedMeta);\n  }\n};\nvar logAsyncRejected = (log2, methodName, err, promiseId, startTime, combinedMeta) => {\n  log2.info(`.${formatFunction(methodName)} \\u21B2 \\u{1F525} ${chalk.gray(\"reject\")} ${formatPromise(promiseId)} ${formatTimeElapsed(startTime)} ${chalk.gray(\"=>\")} ${err}`, {}, combinedMeta);\n};\nvar greenCheck = chalk.green(\"\\u2714\");\nvar formatTimeElapsed = (startTime) => chalk.gray(`${(performance.now() - startTime).toFixed(0)}ms`);\nvar COLOR_FUNCTION = [\n  220,\n  220,\n  170\n];\nvar formatFunction = (name) => chalk.bold(chalk.rgb(...COLOR_FUNCTION)(name));\nvar formatPromise = (id) => chalk.blue(`Promise#${id}`);\n\n// packages/common/log/src/options.ts\nimport defaultsDeep from \"lodash.defaultsdeep\";\n\n// packages/common/log/src/platform/browser/index.ts\nvar loadOptions = (filepath) => {\n  try {\n    let dxlog;\n    if (typeof localStorage === \"undefined\") {\n      if (globalThis.localStorage_dxlog) {\n        dxlog = globalThis.localStorage_dxlog;\n      }\n    } else {\n      dxlog = localStorage.getItem(\"dxlog\") ?? void 0;\n    }\n    if (!dxlog) {\n      return void 0;\n    }\n    return JSON.parse(dxlog);\n  } catch (err) {\n    console.info(\"can't parse dxlog config\", err);\n    return void 0;\n  }\n};\n\n// packages/common/log/src/processors/console-stub.ts\nvar CONSOLE_PROCESSOR = () => {\n};\n\n// packages/common/log/src/processors/debug-processor.ts\nimport { inspect as inspect2 } from \"@dxos/node-std/util\";\nvar DEBUG_PROCESSOR = (config, entry) => {\n  console.log(inspect2(entry, false, null, true));\n};\n\n// packages/common/log/src/processors/browser-processor.ts\nimport { getDebugName, safariCheck } from \"@dxos/util\";\nvar getRelativeFilename = (filename) => {\n  const match = filename.match(/.+\\/(packages\\/.+\\/.+)/);\n  if (match) {\n    const [, filePath] = match;\n    return filePath;\n  }\n  return filename;\n};\nvar CONFIG = typeof mochaExecutor !== \"undefined\" ? {\n  useTestProcessor: true,\n  printFileLinks: true\n} : {\n  useTestProcessor: false,\n  printFileLinks: false\n};\nvar APP_BROWSER_PROCESSOR = (config, entry) => {\n  if (!shouldLog(entry, config.filters)) {\n    return;\n  }\n  const LOG_BROWSER_PREFIX = config.prefix ?? \"https://vscode.dev/github.com/dxos/dxos/blob/main/\";\n  const LOG_BROWSER_CSS = [];\n  let link = \"\";\n  if (entry.meta) {\n    const filename = getRelativeFilename(entry.meta.F);\n    const filepath = `${LOG_BROWSER_PREFIX.replace(/\\/$/, \"\")}/${filename}`;\n    link = `${filepath}#L${entry.meta.L}`;\n  }\n  let args = [];\n  if (entry.meta?.S) {\n    const scope = entry.meta?.S;\n    const scopeName = scope.name || getDebugName(scope);\n    const processPrefix = entry.meta.S?.hostSessionId ? \"[worker] \" : \"\";\n    args.push(`%c${processPrefix}${scopeName}`, \"color:#C026D3;font-weight:bold\");\n  }\n  args.push(entry.message);\n  const context = getContextFromEntry(entry);\n  if (context) {\n    args.push(context);\n  }\n  const levels2 = {\n    [LogLevel.ERROR]: console.error,\n    [LogLevel.WARN]: console.warn,\n    [LogLevel.DEBUG]: console.log\n  };\n  if (CONFIG.printFileLinks || safariCheck()) {\n    if (LOG_BROWSER_CSS?.length) {\n      args = [\n        `%c${link}\n%c${args.join(\" \")}`,\n        ...LOG_BROWSER_CSS\n      ];\n    } else {\n      args = [\n        link + \"\\n\",\n        ...args\n      ];\n    }\n  }\n  const level = levels2[entry.level] ?? console.log;\n  if (typeof entry.meta?.C === \"function\") {\n    entry.meta.C(level, args);\n  } else {\n    level(...args);\n  }\n};\nvar TEST_BROWSER_PROCESSOR = (config, entry) => {\n  if (!shouldLog(entry, config.filters)) {\n    return;\n  }\n  let path = \"\";\n  if (entry.meta) {\n    path = `${getRelativeFilename(entry.meta.F)}:${entry.meta.L}`;\n  }\n  let args = [];\n  const processPrefix = entry.meta?.S?.hostSessionId ? \"[worker] \" : \"\";\n  args.push(`${processPrefix}${entry.message}`);\n  const context = getContextFromEntry(entry);\n  if (context) {\n    args.push(context);\n  }\n  const levels2 = {\n    [LogLevel.ERROR]: console.error,\n    [LogLevel.WARN]: console.warn,\n    [LogLevel.DEBUG]: console.log\n  };\n  if (CONFIG.printFileLinks) {\n    args = [\n      path,\n      ...args\n    ];\n  }\n  const level = levels2[entry.level] ?? console.log;\n  if (typeof entry.meta?.C === \"function\") {\n    entry.meta.C(level, args);\n  } else {\n    level(...args);\n  }\n};\nvar BROWSER_PROCESSOR = CONFIG.useTestProcessor ? TEST_BROWSER_PROCESSOR : APP_BROWSER_PROCESSOR;\n\n// packages/common/log/src/processors/file-processor.ts\nimport { appendFileSync, mkdirSync, openSync } from \"@dxos/node-std/fs\";\nimport { dirname } from \"@dxos/node-std/path\";\nimport { jsonlogify } from \"@dxos/util\";\n\n// packages/common/log/src/processors/common.ts\nvar getRelativeFilename2 = (filename) => {\n  const match = filename.match(/.+\\/(packages\\/.+\\/.+)/);\n  if (match) {\n    const [, filePath] = match;\n    return filePath;\n  }\n  return filename;\n};\n\n// packages/common/log/src/processors/file-processor.ts\nvar EAGAIN_MAX_DURATION = 1e3;\nvar createFileProcessor = ({ pathOrFd, levels: levels2, filters }) => {\n  let fd;\n  return (config, entry) => {\n    if (levels2.length > 0 && !levels2.includes(entry.level)) {\n      return;\n    }\n    if (!shouldLog(entry, filters)) {\n      return;\n    }\n    if (typeof pathOrFd === \"number\") {\n      fd = pathOrFd;\n    } else {\n      try {\n        mkdirSync(dirname(pathOrFd));\n      } catch {\n      }\n      fd = openSync(pathOrFd, \"a\");\n    }\n    const record = {\n      ...entry,\n      timestamp: Date.now(),\n      ...entry.meta ? {\n        meta: {\n          file: getRelativeFilename2(entry.meta.F),\n          line: entry.meta.L\n        }\n      } : {},\n      context: jsonlogify(getContextFromEntry(entry))\n    };\n    let retryTS = 0;\n    while (true) {\n      try {\n        return appendFileSync(fd, JSON.stringify(record) + \"\\n\");\n      } catch (err) {\n        if (err.code !== \"EAGAIN\") {\n          throw err;\n        }\n        if (retryTS === 0) {\n          retryTS = performance.now();\n        } else {\n          if (performance.now() - retryTS > EAGAIN_MAX_DURATION) {\n            console.log(`could not write after ${EAGAIN_MAX_DURATION}ms of EAGAIN failures, giving up`);\n            throw err;\n          }\n        }\n      }\n    }\n  };\n};\nvar logFilePath;\nvar getLogFilePath = () => {\n  logFilePath ??= process.env.LOG_FILE ?? (process.env.HOME ? `${process.env.HOME}/.dxlog/${(/* @__PURE__ */ new Date()).toISOString()}.log` : void 0);\n  return logFilePath;\n};\nvar FILE_PROCESSOR = createFileProcessor({\n  pathOrFd: getLogFilePath(),\n  levels: [\n    LogLevel.ERROR,\n    LogLevel.WARN,\n    LogLevel.INFO,\n    LogLevel.TRACE\n  ]\n});\n\n// packages/common/log/src/options.ts\nvar processors = {\n  [LogProcessorType.CONSOLE]: CONSOLE_PROCESSOR,\n  [LogProcessorType.BROWSER]: BROWSER_PROCESSOR,\n  [LogProcessorType.DEBUG]: DEBUG_PROCESSOR\n};\nvar IS_BROWSER = typeof window !== \"undefined\" || typeof navigator !== \"undefined\";\nvar DEFAULT_PROCESSORS = [\n  IS_BROWSER ? BROWSER_PROCESSOR : CONSOLE_PROCESSOR\n];\nvar parseFilter = (filter) => {\n  if (typeof filter === \"number\") {\n    return [\n      {\n        level: filter\n      }\n    ];\n  }\n  const parseLogLevel = (level, defValue = LogLevel.WARN) => levels[level.toLowerCase()] ?? defValue;\n  const lines = typeof filter === \"string\" ? filter.split(/,\\s*/) : filter;\n  return lines.map((filter2) => {\n    const [pattern, level] = filter2.split(\":\");\n    return level ? {\n      level: parseLogLevel(level),\n      pattern\n    } : {\n      level: parseLogLevel(pattern)\n    };\n  });\n};\nvar getConfig = (options) => {\n  const nodeOptions = \"process\" in globalThis ? {\n    file: process.env.LOG_CONFIG,\n    filter: process.env.LOG_FILTER,\n    processor: process.env.LOG_PROCESSOR\n  } : void 0;\n  const mergedOptions = defaultsDeep({}, loadOptions(nodeOptions?.file), nodeOptions, options);\n  return {\n    options: mergedOptions,\n    filters: parseFilter(mergedOptions.filter ?? LogLevel.INFO),\n    captureFilters: parseFilter(mergedOptions.captureFilter ?? LogLevel.WARN),\n    processors: mergedOptions.processor ? [\n      processors[mergedOptions.processor]\n    ] : DEFAULT_PROCESSORS,\n    prefix: mergedOptions.prefix\n  };\n};\n\n// packages/common/log/src/log.ts\nvar createLog = () => {\n  const log2 = (...params) => processLog(LogLevel.DEBUG, ...params);\n  log2._config = getConfig();\n  Object.defineProperty(log2, \"runtimeConfig\", {\n    get: () => log2._config\n  });\n  log2.addProcessor = (processor) => {\n    if (DEFAULT_PROCESSORS.filter((p) => p === processor).length === 0) {\n      DEFAULT_PROCESSORS.push(processor);\n    }\n    if (log2._config.processors.filter((p) => p === processor).length === 0) {\n      log2._config.processors.push(processor);\n    }\n  };\n  log2.config = (options) => {\n    log2._config = getConfig(options);\n  };\n  log2.trace = (...params) => processLog(LogLevel.TRACE, ...params);\n  log2.debug = (...params) => processLog(LogLevel.DEBUG, ...params);\n  log2.info = (...params) => processLog(LogLevel.INFO, ...params);\n  log2.warn = (...params) => processLog(LogLevel.WARN, ...params);\n  log2.error = (...params) => processLog(LogLevel.ERROR, ...params);\n  log2.catch = (error, context, meta) => processLog(LogLevel.ERROR, error.message, context, meta, error);\n  log2.break = () => log2.info(\"\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\");\n  log2.stack = (message, context, meta) => processLog(LogLevel.INFO, `${message ?? \"Stack Dump\"}\n${getFormattedStackTrace()}`, context, meta);\n  log2.method = createMethodLogDecorator(log2);\n  const processLog = (level, message, context = {}, meta, error) => {\n    log2._config.processors.forEach((processor) => processor(log2._config, {\n      level,\n      message,\n      context,\n      meta,\n      error\n    }));\n  };\n  return log2;\n};\nvar log = globalThis.dx_log ??= createLog();\nvar getFormattedStackTrace = () => new Error().stack.split(\"\\n\").slice(3).join(\"\\n\");\n\n// packages/common/log/src/experimental/ownership.ts\nimport { inspect as inspect3 } from \"@dxos/node-std/util\";\nvar kOwnershipScope = Symbol(\"kOwnershipScope\");\nvar kCurrentOwnershipScope = Symbol(\"kCurrentOwnershipScope\");\nvar kDebugInfoProperties = Symbol(\"kDebugInfoProperties\");\nvar OwnershipScope = class {\n  constructor(constr, parent) {\n    this.constr = constr;\n    this.parent = parent;\n  }\n  getInfo() {\n    if (!this.instance) {\n      return {};\n    }\n    const props = this.constr.prototype[kDebugInfoProperties] ?? [];\n    const info = {};\n    for (const prop of props) {\n      info[prop] = this.instance[prop];\n    }\n    return info;\n  }\n  [inspect3.custom]() {\n    return {\n      className: this.constr.name,\n      info: this.getInfo(),\n      parent: this.parent\n    };\n  }\n};\nvar getCurrentOwnershipScope = (thisRef) => thisRef;\nexport {\n  BROWSER_PROCESSOR,\n  CONSOLE_PROCESSOR,\n  DEBUG_PROCESSOR,\n  FILE_PROCESSOR,\n  LogLevel,\n  LogProcessorType,\n  createFileProcessor,\n  gatherLogInfoFromScope,\n  getContextFromEntry,\n  getCurrentOwnershipScope,\n  levels,\n  log,\n  logInfo,\n  omit,\n  parseFilter,\n  pick,\n  shortLevelName,\n  shouldLog\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/common/context/src/context.ts\nimport { inspect } from \"@dxos/node-std/util\";\nimport { log } from \"@dxos/log\";\nimport { safeInstanceof } from \"@dxos/util\";\n\n// packages/common/context/src/context-disposed-error.ts\nvar ContextDisposedError = class extends Error {\n  constructor() {\n    super(\"Context disposed.\");\n  }\n};\n\n// packages/common/context/src/context.ts\nfunction _ts_decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nvar __dxlog_file = \"/home/runner/work/dxos/dxos/packages/common/context/src/context.ts\";\nvar MAX_SAFE_DISPOSE_CALLBACKS = 300;\nvar DEFAULT_ERROR_HANDLER = (error, ctx) => {\n  if (error instanceof ContextDisposedError) {\n    return;\n  }\n  void ctx.dispose();\n  throw error;\n};\nvar _a, _b;\nvar Context = class _Context {\n  constructor({ name, parent, attributes = {}, onError = DEFAULT_ERROR_HANDLER } = {}) {\n    this.#disposeCallbacks = [];\n    this.#name = void 0;\n    this.#parent = void 0;\n    this.#isDisposed = false;\n    this.#disposePromise = void 0;\n    this.maxSafeDisposeCallbacks = MAX_SAFE_DISPOSE_CALLBACKS;\n    this[_a] = \"Context\";\n    this[_b] = () => this.toString();\n    this.#name = name;\n    this.#parent = parent;\n    this.#attributes = attributes;\n    this.#onError = onError;\n  }\n  static {\n    _a = Symbol.toStringTag, _b = inspect.custom;\n  }\n  static default() {\n    return new _Context();\n  }\n  #disposeCallbacks;\n  #name;\n  #parent;\n  #attributes;\n  #onError;\n  #isDisposed;\n  #disposePromise;\n  get disposed() {\n    return this.#isDisposed;\n  }\n  get disposeCallbacksLength() {\n    return this.#disposeCallbacks.length;\n  }\n  /**\n  * Schedules a callback to run when the context is disposed.\n  * May be async, in this case the disposer might choose to wait for all resource to released.\n  * Throwing an error inside the callback will result in the error being logged, but not re-thrown.\n  *\n  * NOTE: Will call the callback immediately if the context is already disposed.\n  *\n  * @returns A function that can be used to remove the callback from the dispose list.\n  */\n  onDispose(callback) {\n    if (this.#isDisposed) {\n      void (async () => {\n        try {\n          await callback();\n        } catch (error) {\n          log.catch(error, void 0, {\n            F: __dxlog_file,\n            L: 88,\n            S: this,\n            C: (f, a) => f(...a)\n          });\n        }\n      })();\n    }\n    this.#disposeCallbacks.push(callback);\n    if (this.#disposeCallbacks.length > this.maxSafeDisposeCallbacks) {\n      log.warn(\"Context has a large number of dispose callbacks (this might be a memory leak).\", {\n        count: this.#disposeCallbacks.length\n      }, {\n        F: __dxlog_file,\n        L: 95,\n        S: this,\n        C: (f, a) => f(...a)\n      });\n    }\n    return () => {\n      const index = this.#disposeCallbacks.indexOf(callback);\n      if (index !== -1) {\n        this.#disposeCallbacks.splice(index, 1);\n      }\n    };\n  }\n  /**\n  * Runs all dispose callbacks.\n  * Callbacks are run in the reverse order they were added.\n  * This function never throws.\n  * It is safe to ignore the returned promise if the caller does not wish to wait for callbacks to complete.\n  * Disposing context means that onDispose will throw an error and any errors raised will be logged and not propagated.\n  */\n  async dispose(throwOnError = false) {\n    if (this.#disposePromise) {\n      return this.#disposePromise;\n    }\n    this.#isDisposed = true;\n    let resolveDispose;\n    const promise = new Promise((resolve) => {\n      resolveDispose = resolve;\n    });\n    this.#disposePromise = promise;\n    const callbacks = Array.from(this.#disposeCallbacks).reverse();\n    this.#disposeCallbacks.length = 0;\n    if (this.#name) {\n      log(\"disposing\", {\n        context: this.#name,\n        count: callbacks.length\n      }, {\n        F: __dxlog_file,\n        L: 137,\n        S: this,\n        C: (f, a) => f(...a)\n      });\n    }\n    let i = 0;\n    let clean = true;\n    const errors = [];\n    for (const callback of callbacks) {\n      try {\n        await callback();\n        i++;\n      } catch (err) {\n        clean = false;\n        if (throwOnError) {\n          errors.push(err);\n        } else {\n          log.catch(err, {\n            context: this.#name,\n            callback: i,\n            count: callbacks.length\n          }, {\n            F: __dxlog_file,\n            L: 152,\n            S: this,\n            C: (f, a) => f(...a)\n          });\n        }\n      }\n    }\n    if (errors.length > 0) {\n      throw new AggregateError(errors);\n    }\n    resolveDispose(clean);\n    if (this.#name) {\n      log(\"disposed\", {\n        context: this.#name\n      }, {\n        F: __dxlog_file,\n        L: 163,\n        S: this,\n        C: (f, a) => f(...a)\n      });\n    }\n    return clean;\n  }\n  /**\n  * Raise the error inside the context.\n  * The error will be propagated to the error handler.\n  * IF the error handler is not set, the error will dispose the context and cause an unhandled rejection.\n  */\n  raise(error) {\n    if (this.#isDisposed) {\n      return;\n    }\n    try {\n      this.#onError(error, this);\n    } catch (err) {\n      void Promise.reject(err);\n    }\n  }\n  derive({ onError, attributes } = {}) {\n    const newCtx = new _Context({\n      // TODO(dmaretskyi): Optimize to not require allocating a new closure for every context.\n      onError: async (error) => {\n        if (!onError) {\n          this.raise(error);\n        } else {\n          try {\n            await onError(error, this);\n          } catch {\n            this.raise(error);\n          }\n        }\n      },\n      attributes\n    });\n    const clearDispose = this.onDispose(() => newCtx.dispose());\n    newCtx.onDispose(clearDispose);\n    return newCtx;\n  }\n  getAttribute(key) {\n    if (key in this.#attributes) {\n      return this.#attributes[key];\n    }\n    if (this.#parent) {\n      return this.#parent.getAttribute(key);\n    }\n    return void 0;\n  }\n  toString() {\n    return `Context(${this.#isDisposed ? \"disposed\" : \"active\"})`;\n  }\n};\nContext = _ts_decorate([\n  safeInstanceof(\"Context\")\n], Context);\n\n// packages/common/context/src/promise-utils.ts\nvar rejectOnDispose = (ctx, error = new ContextDisposedError()) => new Promise((resolve, reject) => {\n  ctx.onDispose(() => reject(error));\n});\nvar cancelWithContext = (ctx, promise) => {\n  let clearDispose;\n  return Promise.race([\n    promise,\n    new Promise((resolve, reject) => {\n      clearDispose = ctx.onDispose(() => reject(new ContextDisposedError()));\n    })\n  ]).finally(() => clearDispose?.());\n};\n\n// packages/common/context/src/resource.ts\nimport { throwUnhandledError } from \"@dxos/util\";\nvar LifecycleState;\n(function(LifecycleState2) {\n  LifecycleState2[\"CLOSED\"] = \"CLOSED\";\n  LifecycleState2[\"OPEN\"] = \"OPEN\";\n  LifecycleState2[\"ERROR\"] = \"ERROR\";\n})(LifecycleState || (LifecycleState = {}));\nvar CLOSE_RESOURCE_ON_UNHANDLED_ERROR = false;\nvar Resource = class {\n  #lifecycleState = \"CLOSED\";\n  #openPromise = null;\n  #closePromise = null;\n  /**\n  * Managed internally by the resource.\n  * Recreated on close.\n  * Errors are propagated to the `_catch` method and the parent context.\n  */\n  #internalCtx = this.#createContext();\n  /**\n  * Context that is used to bubble up errors that are not handled by the resource.\n  * Provided in the open method.\n  */\n  #parentCtx = new Context({\n    name: this.#name\n  });\n  get #name() {\n    return Object.getPrototypeOf(this).constructor.name;\n  }\n  get _lifecycleState() {\n    return this.#lifecycleState;\n  }\n  get _ctx() {\n    return this.#internalCtx;\n  }\n  /**\n  * To be overridden by subclasses.\n  */\n  async _open(ctx) {\n  }\n  /**\n  * To be overridden by subclasses.\n  */\n  async _close(ctx) {\n  }\n  /**\n  * Error handler for errors that are caught by the context.\n  * By default, errors are bubbled up to the parent context which is passed to the open method.\n  */\n  async _catch(err) {\n    if (CLOSE_RESOURCE_ON_UNHANDLED_ERROR) {\n      try {\n        await this.close();\n      } catch (doubleErr) {\n        throwUnhandledError(doubleErr);\n      }\n    }\n    throw err;\n  }\n  /**\n  * Opens the resource.\n  * If the resource is already open, it does nothing.\n  * If the resource is in an error state, it throws an error.\n  * If the resource is closed, it waits for it to close and then opens it.\n  * @param ctx - Context to use for opening the resource. This context will receive errors that are not handled in `_catch`.\n  */\n  async open(ctx) {\n    switch (this.#lifecycleState) {\n      case \"OPEN\":\n        return this;\n      case \"ERROR\":\n        throw new Error(`Invalid state: ${this.#lifecycleState}`);\n      default:\n    }\n    await this.#closePromise;\n    await (this.#openPromise ??= this.#open(ctx));\n    return this;\n  }\n  /**\n  * Closes the resource.\n  * If the resource is already closed, it does nothing.\n  */\n  async close(ctx) {\n    if (this.#lifecycleState === \"CLOSED\") {\n      return this;\n    }\n    await this.#openPromise;\n    await (this.#closePromise ??= this.#close(ctx));\n    return this;\n  }\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n  async #open(ctx) {\n    this.#closePromise = null;\n    if (ctx) {\n      this.#parentCtx = ctx.derive({\n        name: this.#name\n      });\n    }\n    await this._open(this.#parentCtx);\n    this.#lifecycleState = \"OPEN\";\n  }\n  async #close(ctx = Context.default()) {\n    this.#openPromise = null;\n    await this.#internalCtx.dispose();\n    await this._close(ctx);\n    this.#internalCtx = this.#createContext();\n    this.#lifecycleState = \"CLOSED\";\n  }\n  #createContext() {\n    return new Context({\n      onError: (error) => queueMicrotask(async () => {\n        try {\n          await this._catch(error);\n        } catch (err) {\n          this.#lifecycleState = \"ERROR\";\n          this.#parentCtx.raise(err);\n        }\n      })\n    });\n  }\n};\nvar openInContext = async (ctx, resource) => {\n  await resource.open?.(ctx);\n  ctx.onDispose(() => resource.close?.());\n  return resource;\n};\nexport {\n  Context,\n  ContextDisposedError,\n  LifecycleState,\n  Resource,\n  cancelWithContext,\n  openInContext,\n  rejectOnDispose\n};\n//# sourceMappingURL=index.mjs.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Observable = void 0;\n\n// === Symbol Support ===\nconst hasSymbol = name => Boolean(Symbol[name]);\n\nconst getSymbol = name => hasSymbol(name) ? Symbol[name] : '@@' + name;\n\nconst SymbolIterator = getSymbol('iterator');\nconst SymbolObservable = getSymbol('observable');\nconst SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  let value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  let ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(() => {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  let cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      let unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  let queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (let i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  let observer = subscription._observer;\n\n  try {\n    let m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type,\n      value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type,\n      value\n    }];\n    enqueue(() => flushSubscription(subscription));\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nclass Subscription {\n  constructor(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    let self = this;\n    let subscriptionObserver = {\n      get closed() {\n        return self._state === 'closed';\n      },\n\n      next(value) {\n        onNotify(self, 'next', value);\n      },\n\n      error(value) {\n        onNotify(self, 'error', value);\n      },\n\n      complete() {\n        onNotify(self, 'complete');\n      }\n\n    };\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  get closed() {\n    return this._state === 'closed';\n  }\n\n  unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  }\n\n}\n\nclass Observable {\n  constructor(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  }\n\n  forEach(fn) {\n    return new Promise((resolve, reject) => {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      let subscription = this.subscribe({\n        next(value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n\n        error: reject,\n        complete: resolve\n      });\n    });\n  }\n\n  map(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          value = fn(value);\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(value);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  filter(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          if (!fn(value)) return;\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(value);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  reduce(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    let hasSeed = arguments.length > 1;\n    let hasValue = false;\n    let seed = arguments[1];\n    let acc = seed;\n    return new C(observer => this.subscribe({\n      next(value) {\n        let first = !hasValue;\n        hasValue = true;\n\n        if (!first || hasSeed) {\n          try {\n            acc = fn(acc, value);\n          } catch (e) {\n            return observer.error(e);\n          }\n        } else {\n          acc = value;\n        }\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n        observer.next(acc);\n        observer.complete();\n      }\n\n    }));\n  }\n\n  async all() {\n    let values = [];\n    await this.forEach(value => values.push(value));\n    return values;\n  }\n\n  concat(...sources) {\n    let C = getSpecies(this);\n    return new C(observer => {\n      let subscription;\n      let index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next(v) {\n            observer.next(v);\n          },\n\n          error(e) {\n            observer.error(e);\n          },\n\n          complete() {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n\n        });\n      }\n\n      startNext(this);\n      return () => {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  }\n\n  flatMap(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => {\n      let subscriptions = [];\n      let outer = this.subscribe({\n        next(value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          let inner = C.from(value).subscribe({\n            next(value) {\n              observer.next(value);\n            },\n\n            error(e) {\n              observer.error(e);\n            },\n\n            complete() {\n              let i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n\n          });\n          subscriptions.push(inner);\n        },\n\n        error(e) {\n          observer.error(e);\n        },\n\n        complete() {\n          completeIfDone();\n        }\n\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return () => {\n        subscriptions.forEach(s => s.unsubscribe());\n        outer.unsubscribe();\n      };\n    });\n  }\n\n  [SymbolObservable]() {\n    return this;\n  }\n\n  static from(x) {\n    let C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    let method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      let observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(observer => observable.subscribe(observer));\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(observer => {\n          enqueue(() => {\n            if (observer.closed) return;\n\n            for (let item of method.call(x)) {\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(observer => {\n        enqueue(() => {\n          if (observer.closed) return;\n\n          for (let i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  }\n\n  static of(...items) {\n    let C = typeof this === 'function' ? this : Observable;\n    return new C(observer => {\n      enqueue(() => {\n        if (observer.closed) return;\n\n        for (let i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  }\n\n  static get [SymbolSpecies]() {\n    return this;\n  }\n\n}\n\nexports.Observable = Observable;\nObject.defineProperty(Observable, Symbol('extensions'), {\n  value: {\n    symbol: SymbolObservable,\n    hostReportError\n  },\n  configurable: true\n});","module.exports = require('./lib/Observable.js').Observable;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Observable = void 0;\n\n// === Symbol Support ===\nconst hasSymbol = name => Boolean(Symbol[name]);\n\nconst getSymbol = name => hasSymbol(name) ? Symbol[name] : '@@' + name;\n\nif (!hasSymbol('observable') && Object.isExtensible(Symbol)) {\n  Symbol.observable = Symbol('observable');\n}\n\nconst SymbolIterator = getSymbol('iterator');\nconst SymbolObservable = getSymbol('observable');\nconst SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  let value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  let ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(() => {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  let cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      let unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  let queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (let i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  let observer = subscription._observer;\n\n  try {\n    let m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type,\n      value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type,\n      value\n    }];\n    enqueue(() => flushSubscription(subscription));\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nclass Subscription {\n  constructor(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    let self = this;\n    let subscriptionObserver = {\n      get closed() {\n        return self._state === 'closed';\n      },\n\n      next(value) {\n        onNotify(self, 'next', value);\n      },\n\n      error(value) {\n        onNotify(self, 'error', value);\n      },\n\n      complete() {\n        onNotify(self, 'complete');\n      }\n\n    };\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  get closed() {\n    return this._state === 'closed';\n  }\n\n  unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  }\n\n}\n\nclass Observable {\n  constructor(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  }\n\n  forEach(fn) {\n    return new Promise((resolve, reject) => {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      let subscription = this.subscribe({\n        next(value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n\n        error: reject,\n        complete: resolve\n      });\n    });\n  }\n\n  map(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          value = fn(value);\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(value);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  filter(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          if (!fn(value)) return;\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(value);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  reduce(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    let hasSeed = arguments.length > 1;\n    let hasValue = false;\n    let seed = arguments[1];\n    let acc = seed;\n    return new C(observer => this.subscribe({\n      next(value) {\n        let first = !hasValue;\n        hasValue = true;\n\n        if (!first || hasSeed) {\n          try {\n            acc = fn(acc, value);\n          } catch (e) {\n            return observer.error(e);\n          }\n        } else {\n          acc = value;\n        }\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n        observer.next(acc);\n        observer.complete();\n      }\n\n    }));\n  }\n\n  async all() {\n    let values = [];\n    await this.forEach(value => values.push(value));\n    return values;\n  }\n\n  concat(...sources) {\n    let C = getSpecies(this);\n    return new C(observer => {\n      let subscription;\n      let index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next(v) {\n            observer.next(v);\n          },\n\n          error(e) {\n            observer.error(e);\n          },\n\n          complete() {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n\n        });\n      }\n\n      startNext(this);\n      return () => {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  }\n\n  flatMap(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => {\n      let subscriptions = [];\n      let outer = this.subscribe({\n        next(value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          let inner = C.from(value).subscribe({\n            next(value) {\n              observer.next(value);\n            },\n\n            error(e) {\n              observer.error(e);\n            },\n\n            complete() {\n              let i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n\n          });\n          subscriptions.push(inner);\n        },\n\n        error(e) {\n          observer.error(e);\n        },\n\n        complete() {\n          completeIfDone();\n        }\n\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return () => {\n        subscriptions.forEach(s => s.unsubscribe());\n        outer.unsubscribe();\n      };\n    });\n  }\n\n  [SymbolObservable]() {\n    return this;\n  }\n\n  static from(x) {\n    let C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    let method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      let observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(observer => observable.subscribe(observer));\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(observer => {\n          enqueue(() => {\n            if (observer.closed) return;\n\n            for (let item of method.call(x)) {\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(observer => {\n        enqueue(() => {\n          if (observer.closed) return;\n\n          for (let i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  }\n\n  static of(...items) {\n    let C = typeof this === 'function' ? this : Observable;\n    return new C(observer => {\n      enqueue(() => {\n        if (observer.closed) return;\n\n        for (let i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  }\n\n  static get [SymbolSpecies]() {\n    return this;\n  }\n\n}\n\nexports.Observable = Observable;\nObject.defineProperty(Observable, Symbol('extensions'), {\n  value: {\n    symbol: SymbolObservable,\n    hostReportError\n  },\n  configurable: true\n});","module.exports = require('./lib/Observable.js').Observable;\n","'use strict';\n\nvar Observable = require('zen-observable');\n\nfunction send(p, message, value) {\n  if (p._observer) {\n    sendMessage(p._observer, message, value);\n  } else if (p._observers) {\n    var list = [];\n    p._observers.forEach(function(to) { list.push(to); });\n    list.forEach(function(to) { sendMessage(to, message, value); });\n  }\n}\n\nfunction sendMessage(observer, message, value) {\n  if (observer.closed) {\n    return;\n  }\n  switch (message) {\n    case 'next': return observer.next(value);\n    case 'error': return observer.error(value);\n    case 'complete': return observer.complete();\n  }\n}\n\nfunction hasObserver(p) {\n  return p._observer || p._observers && p._observers.size > 0;\n}\n\nfunction addObserver(p, observer) {\n  if (p._observers) {\n    p._observers.add(observer);\n  } else if (!p._observer) {\n    p._observer = observer;\n  } else {\n    p._observers = new Set();\n    p._observers.add(p._observer);\n    p._observers.add(observer);\n    p._observer = null;\n  }\n}\n\nfunction deleteObserver(p, observer) {\n  if (p._observers) {\n    p._observers.delete(observer);\n  } else if (p._observer === observer) {\n    p._observer = null;\n  }\n}\n\nfunction notifyStart(p, opts) {\n  !hasObserver(p) && opts && opts.start && opts.start();\n}\n\nfunction notifyPause(p, opts) {\n  !hasObserver(p) && opts && opts.pause && opts.pause();\n}\n\nclass PushStream {\n  constructor(opts) {\n    this._observer = null;\n    this._observers = null;\n    this._observable = new Observable((observer) => {\n      notifyStart(this, opts);\n      addObserver(this, observer);\n      return () => {\n        deleteObserver(this, observer);\n        notifyPause(this, opts);\n      };\n    });\n  }\n\n  get observable() {\n    return this._observable;\n  }\n\n  get observed() {\n    return hasObserver(this);\n  }\n\n  next(x) {\n    send(this, 'next', x);\n  }\n\n  error(e) {\n    send(this, 'error', e);\n  }\n\n  complete() {\n    send(this, 'complete');\n  }\n\n  static multicast(observable) {\n    let stream = new this();\n    observable.subscribe(stream);\n    return stream.observable;\n  }\n}\n\nmodule.exports = PushStream;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","module.exports = require('events').EventEmitter;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","// packages/common/async/src/callback.ts\nvar createPromiseFromCallback = (run) => new Promise((resolve, reject) => {\n  run((error, value) => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve(value);\n    }\n  });\n});\n\n// packages/common/async/src/chain.ts\nvar asyncChain = (chain) => async (elements) => {\n  let result = await elements;\n  for (const part of chain) {\n    result = await Promise.all(result.map(async (element) => await part(element)));\n  }\n  return result;\n};\n\n// packages/common/async/src/debounce.ts\nvar debounce = (cb, wait = 100) => {\n  let t;\n  return (...args) => {\n    clearTimeout(t);\n    t = setTimeout(() => cb(...args), wait);\n  };\n};\n\n// packages/common/async/src/errors.ts\nvar toError = (err) => err === void 0 || typeof err === \"string\" ? new Error(err) : err;\nvar TimeoutError = class extends Error {\n  constructor(timeout, label) {\n    super(timeout ? `Timeout [${timeout.toLocaleString()}ms]${label === void 0 ? \"\" : `: ${label}`}` : \"Timeout\");\n  }\n};\nvar observableError = (observable, err) => {\n  if (err instanceof TimeoutError) {\n    observable.callback.onTimeout?.(err);\n  } else {\n    observable.callback.onError(toError(err));\n  }\n};\n\n// packages/common/async/src/timeout.ts\nimport { ContextDisposedError } from \"@dxos/context\";\nvar sleep = (ms) => {\n  return new Promise((resolve) => {\n    const finish = Date.now() + ms;\n    const sleeper = () => {\n      const delta = finish - Date.now();\n      if (delta > 0) {\n        setTimeout(sleeper, delta);\n      } else {\n        resolve();\n      }\n    };\n    sleeper();\n  });\n};\nvar asyncTimeout = async (promise, timeout, err) => {\n  let timeoutId;\n  const throwable = err === void 0 || typeof err === \"string\" ? new TimeoutError(timeout, err) : err;\n  const timeoutPromise = new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      reject(throwable);\n    }, timeout);\n    unrefTimeout(timeoutId);\n  });\n  const conditionTimeout = typeof promise === \"function\" ? createPromiseFromCallback(promise) : promise;\n  return await Promise.race([\n    conditionTimeout,\n    timeoutPromise\n  ]).finally(() => {\n    clearTimeout(timeoutId);\n  });\n};\nvar unrefTimeout = (timeoutId) => {\n  if (typeof timeoutId === \"object\" && \"unref\" in timeoutId) {\n    timeoutId.unref();\n  }\n};\nvar sleepWithContext = (ctx, ms) => {\n  const error = new ContextDisposedError();\n  return new Promise((resolve, reject) => {\n    if (ctx.disposed) {\n      reject(error);\n      return;\n    }\n    const timeout = setTimeout(() => {\n      clearDispose();\n      resolve();\n    }, ms);\n    const clearDispose = ctx.onDispose(() => {\n      clearTimeout(timeout);\n      reject(error);\n    });\n  });\n};\n\n// packages/common/async/src/event-emitter.ts\nvar onEvent = (eventEmitter, eventName, callback) => {\n  eventEmitter.on(eventName, callback);\n  return () => eventEmitter.off(eventName, callback);\n};\nvar addListener = (eventEmitter, eventName, callback) => {\n  const off = onEvent(eventEmitter, eventName, callback);\n  return {\n    remove: () => off()\n  };\n};\nvar waitForEvent = (eventEmitter, eventName, test, timeout, error) => {\n  let off;\n  const promise = new Promise((resolve) => {\n    off = onEvent(eventEmitter, eventName, (...args) => {\n      if (!test || test(...args)) {\n        resolve(...args);\n      }\n    });\n  });\n  return timeout ? asyncTimeout(promise, timeout, error ?? new Error()).finally(off) : promise.finally(off);\n};\n\n// packages/common/async/src/events.ts\nimport { Context } from \"@dxos/context\";\nvar EventSubscriptions = class {\n  constructor() {\n    this._listeners = [];\n  }\n  add(cb) {\n    this._listeners.push(cb);\n  }\n  clear() {\n    this._listeners.forEach((cb) => cb());\n    this._listeners.length = 0;\n  }\n};\nvar Event = class _Event {\n  constructor() {\n    this._listeners = /* @__PURE__ */ new Set();\n    this._effects = /* @__PURE__ */ new Set();\n  }\n  static wrap(emitter, eventName) {\n    const event = new _Event();\n    event.addEffect(() => {\n      const onEvent2 = (data) => event.emit(data);\n      emitter.on(eventName, onEvent2);\n      return () => emitter.off(eventName, onEvent2);\n    });\n    return event;\n  }\n  /**\n  * Emit an event.\n  * In most cases should only be called by the class or entity containing the event.\n  * All listeners are called in order of subscription with persistent ones first.\n  * Listeners are called synchronously in the same stack.\n  * A thrown exception in the listener will stop the event from being emitted to the rest of the listeners.\n  *\n  * @param data param that will be passed to all listeners.\n  */\n  emit(data) {\n    for (const listener of this._listeners) {\n      void listener.trigger(data);\n      if (listener.once) {\n        this._listeners.delete(listener);\n      }\n    }\n  }\n  on(_ctx, _callback, options) {\n    const [ctx, callback] = _ctx instanceof Context ? [\n      _ctx,\n      _callback\n    ] : [\n      new Context(),\n      _ctx\n    ];\n    const weak = !!options?.weak;\n    const once = !!options?.once;\n    const listener = new EventListener(this, callback, ctx, once, weak);\n    this._addListener(listener);\n    return () => {\n      this._removeListener(listener);\n    };\n  }\n  /**\n  * Unsubscribe this callback from new events. Includes persistent and once-listeners.\n  * NOTE: It is recommended to use `Event.on`'s return value instead.\n  * If the callback is not subscribed this is no-op.\n  *\n  * @param callback\n  */\n  off(callback) {\n    for (const listener of this._listeners) {\n      if (listener.derefCallback() === callback) {\n        this._removeListener(listener);\n      }\n    }\n  }\n  once(_ctx, _callback) {\n    const [ctx, callback] = _ctx instanceof Context ? [\n      _ctx,\n      _callback\n    ] : [\n      new Context(),\n      _ctx\n    ];\n    const listener = new EventListener(this, callback, ctx, true, false);\n    this._addListener(listener);\n    return () => {\n      this._removeListener(listener);\n    };\n  }\n  /**\n  * An async iterator that iterates over events.\n  * This iterator runs indefinitely.\n  */\n  async *[Symbol.asyncIterator]() {\n    while (true) {\n      yield await new Promise((resolve) => {\n        this.once(resolve);\n      });\n    }\n  }\n  /**\n  * Returns a promise that resolves with the first event emitted that matches the provided predicate.\n  *\n  * @param predicate\n  */\n  waitFor(predicate) {\n    return new Promise((resolve) => {\n      const unsubscribe = this.on((data) => {\n        if (predicate(data)) {\n          unsubscribe();\n          resolve(data);\n        }\n      });\n    });\n  }\n  /**\n  * Returns a promise that resolves once a specific number of events was emitted since this method was called.\n  *\n  * @param expectedCount\n  */\n  waitForCount(expectedCount) {\n    let count = 0;\n    return this.waitFor(() => ++count === expectedCount);\n  }\n  /**\n  * Similar to waitFor, but the promise resolves immediately if the condition is already true.\n  */\n  // TODO(burdon): Should pass event property to predicate.\n  async waitForCondition(predicate) {\n    if (!predicate()) {\n      await this.waitFor(predicate);\n    }\n  }\n  /**\n  * Returns the number of persistent listeners.\n  */\n  listenerCount() {\n    return this._listeners.size;\n  }\n  /**\n  * Add a side effect that will be activated once the event has at least one subscriber.\n  * The provided callback can return a function that will be used to clean up after the last subscriber unsubscribes from the event.\n  * The API is similar to `useEffect` from React.\n  *\n  * ## Example:\n  * ```typescript\n  * event.addEffect(() => {\n  *   // do stuff\n  *   return () => {\n  *     // clean-up\n  *   };\n  * });\n  * ```\n  *\n  * @returns Callback that will remove this effect once called.\n  */\n  addEffect(effect) {\n    const handle = {\n      effect,\n      cleanup: void 0\n    };\n    if (this.listenerCount() > 0) {\n      handle.cleanup = handle.effect();\n    }\n    this._effects.add(handle);\n    return () => {\n      handle.cleanup?.();\n      this._effects.delete(handle);\n    };\n  }\n  /**\n  * Triggers an event with at least `timeout` milliseconds between each event.\n  * If the event is triggered more often, the event is delayed until the timeout is reached.\n  * If event is emitted for the first time or event wasn't fired for `timeout` milliseconds,\n  * the event is emitted after `timeout / 8` ms.\n  */\n  // TODO(burdon): Provide function.\n  debounce(timeout = 0) {\n    let firing;\n    let lastFired;\n    const debouncedEvent = new _Event();\n    debouncedEvent.addEffect(() => {\n      const unsubscribe = this.on(() => {\n        if (!firing) {\n          const fireIn = !lastFired || Date.now() - lastFired > timeout ? timeout / 8 : timeout;\n          firing = setTimeout(() => {\n            lastFired = Date.now();\n            firing = void 0;\n            debouncedEvent.emit();\n          }, fireIn);\n        }\n      });\n      return () => {\n        unsubscribe();\n        clearTimeout(firing);\n      };\n    });\n    return debouncedEvent;\n  }\n  /**\n  * Turn any variant of `Event<T>` into an `Event<void>` discarding the callback parameter.\n  */\n  discardParameter() {\n    return this;\n  }\n  /**\n  * Overridden to not return implementation details.\n  */\n  toJSON() {\n    return {\n      listenerCount: this.listenerCount()\n    };\n  }\n  _addListener(listener) {\n    this._listeners.add(listener);\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n  }\n  /**\n  * @internal\n  */\n  _removeListener(listener) {\n    this._listeners.delete(listener);\n    listener.remove();\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects();\n    }\n  }\n  _runEffects() {\n    for (const handle of this._effects) {\n      handle.cleanup = handle.effect();\n    }\n  }\n  _cleanupEffects() {\n    for (const handle of this._effects) {\n      handle.cleanup?.();\n      handle.cleanup = void 0;\n    }\n  }\n};\nvar EventListener = class {\n  constructor(event, listener, ctx, once, weak) {\n    this.ctx = ctx;\n    this.once = once;\n    this.weak = weak;\n    this._clearDispose = void 0;\n    this._clearDispose = ctx.onDispose(() => {\n      event._removeListener(this);\n    });\n    if (weak) {\n      this.callback = new WeakRef(listener);\n      weakListeners().registry.register(listener, {\n        event: new WeakRef(event),\n        listener: this\n      }, this);\n    } else {\n      this.callback = listener;\n    }\n  }\n  derefCallback() {\n    return this.weak ? this.callback.deref() : this.callback;\n  }\n  async trigger(data) {\n    try {\n      const callback = this.derefCallback();\n      await callback?.(data);\n    } catch (err) {\n      this.ctx.raise(err);\n    }\n  }\n  remove() {\n    this._clearDispose?.();\n    weakListeners().registry.unregister(this);\n  }\n};\nvar weakListenersState = null;\nvar weakListeners = () => {\n  weakListenersState ??= new FinalizationRegistry(({ event, listener }) => {\n    event.deref()?._removeListener(listener);\n  });\n  return {\n    registry: weakListenersState\n  };\n};\n\n// packages/common/async/src/latch.ts\nimport { invariant } from \"@dxos/invariant\";\nvar __dxlog_file = \"/home/runner/work/dxos/dxos/packages/common/async/src/latch.ts\";\nvar latch = ({ count = 1, timeout } = {}) => {\n  invariant(count >= 0, void 0, {\n    F: __dxlog_file,\n    L: 19,\n    S: void 0,\n    A: [\n      \"count >= 0\",\n      \"\"\n    ]\n  });\n  let t;\n  let doResolve;\n  let doReject;\n  const promise = new Promise((resolve, reject) => {\n    doResolve = (value) => {\n      clearTimeout(t);\n      resolve(value);\n    };\n    doReject = (err) => {\n      clearTimeout(t);\n      reject(err);\n    };\n  });\n  if (count === 0) {\n    setTimeout(() => {\n      doResolve(0);\n    });\n  } else {\n    if (timeout) {\n      t = setTimeout(() => {\n        doReject(new Error(`Timed out after ${timeout.toLocaleString()}ms`));\n      }, timeout);\n    }\n  }\n  let i = 0;\n  return [\n    async () => await promise,\n    () => {\n      if (++i === count) {\n        doResolve(i);\n      }\n      return i;\n    },\n    (err) => doReject(err)\n  ];\n};\n\n// packages/common/async/src/observable.ts\nimport Observable from \"zen-observable\";\nimport PushStream from \"zen-push\";\n\n// packages/common/async/src/trigger.ts\nvar trigger = (timeout) => {\n  let callback;\n  const promise = new Promise((resolve, reject) => {\n    if (timeout) {\n      setTimeout(() => reject(new Error(`Timed out after ${timeout.toLocaleString()}ms`)), timeout);\n    }\n    callback = resolve;\n  });\n  const provider = () => promise;\n  const resolver = (value) => callback(value);\n  return [\n    provider,\n    resolver\n  ];\n};\nvar TriggerState;\n(function(TriggerState2) {\n  TriggerState2[\"WAITING\"] = \"WAITING\";\n  TriggerState2[\"RESOLVED\"] = \"RESOLVED\";\n  TriggerState2[\"REJECTED\"] = \"REJECTED\";\n})(TriggerState || (TriggerState = {}));\nvar Trigger = class {\n  constructor(_options = {\n    autoReset: false\n  }) {\n    this._options = _options;\n    this._state = \"WAITING\";\n    this.reset();\n  }\n  get state() {\n    return this._state;\n  }\n  /**\n  * Wait until wake is called, with optional timeout.\n  */\n  async wait({ timeout } = {}) {\n    if (timeout) {\n      return asyncTimeout(this._promise, timeout, new TimeoutError(timeout));\n    } else {\n      return this._promise;\n    }\n  }\n  /**\n  * Wake blocked callers (if any).\n  * NOOP if the trigger is already resolved.\n  */\n  wake(value) {\n    this._state = \"RESOLVED\";\n    this._resolve(value);\n    if (this._options.autoReset) {\n      return this.reset();\n    }\n    return this;\n  }\n  /**\n  * Reset promise (new waiters will wait).\n  */\n  reset() {\n    this._state = \"WAITING\";\n    this._promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    this._promise.catch(() => {\n    });\n    return this;\n  }\n  /**\n  * Throw error to blocked callers (if any).\n  * NOOP if the trigger is already resolved.\n  */\n  throw(error) {\n    this._state = \"REJECTED\";\n    this._reject(error);\n    if (this._options.autoReset) {\n      return this.reset();\n    }\n    return this;\n  }\n};\n\n// packages/common/async/src/observable.ts\nvar MulticastObservable = class _MulticastObservable extends Observable {\n  constructor(subscriber, _value) {\n    super((observer) => this._subscribe(observer));\n    this._value = _value;\n    this._observers = /* @__PURE__ */ new Set();\n    this._completed = new Trigger();\n    this._handlers = {\n      next: (value) => {\n        this._value = value;\n        this._observers.forEach((observer) => observer.next?.(value));\n      },\n      error: (err) => {\n        this._observers.forEach((observer) => observer.error?.(err));\n      },\n      complete: () => {\n        this._completed.wake();\n        this._observers.forEach((observer) => observer.complete?.());\n      }\n    };\n    this._observable = typeof subscriber === \"function\" ? new Observable(subscriber) : subscriber;\n    this._observable.subscribe(this._handlers);\n  }\n  static from(value, initialValue) {\n    if (\"emit\" in value) {\n      return new _MulticastObservable((observer) => {\n        value.on((data) => {\n          observer.next(data);\n        });\n      }, initialValue);\n    }\n    const observable = Observable.from(value);\n    return new _MulticastObservable(observable, initialValue);\n  }\n  static of(...items) {\n    return new _MulticastObservable(Observable.of(...items.slice(1)), items[0]);\n  }\n  /**\n  * @returns Stable reference to an observable that always returns `undefined`.\n  */\n  static empty() {\n    return EMPTY_OBSERVABLE;\n  }\n  /**\n  * Get the current value of the observable.\n  */\n  get() {\n    if (this._value === void 0) {\n      throw new Error(\"MulticastObservable is not initialized.\");\n    }\n    return this._value;\n  }\n  /**\n  * Wait for the observable to complete.\n  *\n  * @returns Promise that resolves to the value of the observable at the time of completion.\n  */\n  async wait({ timeout } = {}) {\n    await this._completed.wait({\n      timeout\n    });\n    return this.get();\n  }\n  forEach(callback) {\n    return this._observable.forEach(callback);\n  }\n  map(callback) {\n    return new _MulticastObservable(this._observable.map(callback), this._value && callback(this._value));\n  }\n  filter(callback) {\n    return new _MulticastObservable(this._observable.filter(callback), this._value && callback(this._value) ? this._value : void 0);\n  }\n  reduce(callback, initialValue) {\n    return new _MulticastObservable(initialValue ? this._observable.reduce(callback, initialValue) : this._observable.reduce(callback), initialValue ?? this._value);\n  }\n  flatMap(callback) {\n    return new _MulticastObservable(this._observable.flatMap(callback), this._value && callback(this._value).get());\n  }\n  concat(...observables) {\n    return new _MulticastObservable(this._observable.concat(...observables), this._value);\n  }\n  /**\n  * Concatenates multicast observables without losing the current value.\n  * @param reducer reduces the values of any multicast observables being concatenated into a single value\n  * @param observables observables to concatenate\n  * @returns concatenated observable\n  */\n  losslessConcat(reducer, ...observables) {\n    const multicast = observables.filter((observable) => observable instanceof _MulticastObservable);\n    const value = reducer(this._value, multicast.map((observable) => observable.get()));\n    return new _MulticastObservable(this._observable.concat(...observables), value);\n  }\n  _subscribe(observer) {\n    if (!this._observers.has(observer)) {\n      this._observers.add(observer);\n    }\n    if (this._value !== void 0) {\n      observer.next?.(this._value);\n    }\n    return () => {\n      this._observers.delete(observer);\n    };\n  }\n};\nvar EMPTY_OBSERVABLE = MulticastObservable.of(null);\n\n// packages/common/async/src/observable-value.ts\nimport { createSetDispatch } from \"@dxos/util\";\nvar ObservableProvider = class {\n  constructor() {\n    this._handlers = /* @__PURE__ */ new Set();\n    this._proxy = createSetDispatch({\n      handlers: this._handlers\n    });\n  }\n  /**\n  * Proxy used to dispatch callbacks to each subscription.\n  */\n  get callback() {\n    return this._proxy;\n  }\n  get value() {\n    return this._value;\n  }\n  setValue(value) {\n    this._value = value;\n  }\n  subscribe(handler) {\n    this._handlers.add(handler);\n    return () => {\n      this._handlers.delete(handler);\n    };\n  }\n};\nvar CancellableObservableProvider = class extends ObservableProvider {\n  constructor(_handleCancel) {\n    super();\n    this._handleCancel = _handleCancel;\n    this._cancelled = false;\n  }\n  get cancelled() {\n    return this._cancelled;\n  }\n  async cancel() {\n    if (this._cancelled) {\n      return;\n    }\n    this._cancelled = true;\n    await this._handleCancel?.();\n    this.callback.onCancelled?.();\n  }\n};\n\n// packages/common/async/src/mutex.ts\nimport \"@dxos/util\";\nimport { warnAfterTimeout } from \"@dxos/debug\";\nvar Mutex = class {\n  constructor() {\n    this._queue = Promise.resolve();\n    this._queueLength = 0;\n    this._tag = null;\n  }\n  get tag() {\n    return this._tag;\n  }\n  isLocked() {\n    return this._queueLength > 0;\n  }\n  /**\n  * Acquires the lock.\n  * Caller is responsible for releasing the lock using the returned callback.\n  * NOTE: Using `executeSynchronized` is preferred over using `acquire` directly.\n  * @returns Release callback\n  */\n  async acquire(tag) {\n    const prev = this._queue;\n    let guard;\n    this._queueLength++;\n    this._queue = new Promise((resolve) => {\n      guard = new MutexGuard(() => {\n        this._queueLength--;\n        this._tag = null;\n        resolve();\n      });\n    });\n    await prev;\n    if (tag !== void 0) {\n      this._tag = tag;\n    }\n    return guard;\n  }\n  /**\n  * Waits for all previous executions to complete and then executes a given function.\n  * Only a single function can be executed at a time.\n  * Function are executed in the same order as `executeSynchronized` is called.\n  * WARNING: Calling `executeSynchronized` inside of `executeSynchronized` on the same lock instance is a deadlock.\n  */\n  async executeSynchronized(fun) {\n    const guard = await this.acquire();\n    try {\n      return await fun();\n    } finally {\n      guard.release();\n    }\n  }\n};\nvar MutexGuard = class {\n  constructor(_release) {\n    this._release = _release;\n  }\n  /**\n  * Releases the lock.\n  */\n  release() {\n    this._release();\n  }\n  [Symbol.dispose]() {\n    this.release();\n  }\n};\nvar classMutexSymbol = Symbol(\"class-mutex\");\nvar FORCE_DISABLE_WARNING = false;\nvar enableWarning = !FORCE_DISABLE_WARNING && globalThis.mochaExecutor;\nvar synchronized = (target, propertyName, descriptor) => {\n  const method = descriptor.value;\n  descriptor.value = async function synchronizedMethod(...args) {\n    const mutex = this[classMutexSymbol] ??= new Mutex();\n    const tag = `${target.constructor.name}.${propertyName}`;\n    let guard;\n    if (!enableWarning) {\n      guard = await mutex.acquire(tag);\n    } else {\n      guard = await warnAfterTimeout(1e4, `lock on ${tag} (taken by ${mutex.tag})`, () => mutex.acquire(tag));\n    }\n    try {\n      return await method.apply(this, args);\n    } finally {\n      guard.release();\n    }\n  };\n  Object.defineProperty(descriptor.value, \"name\", {\n    value: propertyName + \"$synchronized\"\n  });\n};\n\n// packages/common/async/src/sink.ts\nvar sink = (emitter, event, count = 1) => {\n  const [getPromise, resolve] = trigger();\n  let counter = 0;\n  const listener = () => {\n    if (++counter === count) {\n      emitter.off(event, listener);\n      resolve();\n    }\n  };\n  emitter.on(event, listener);\n  return getPromise();\n};\n\n// packages/common/async/src/stream-to-array.ts\nvar streamToArray = (stream) => {\n  let deferred;\n  if (!stream.readable) {\n    deferred = Promise.resolve([]);\n  } else {\n    deferred = new Promise((resolve, reject) => {\n      if (!stream.readable) {\n        return resolve([]);\n      }\n      let arr = [];\n      const onData = (doc) => {\n        arr?.push(doc);\n      };\n      const onEnd = (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(arr);\n        }\n        cleanup();\n      };\n      const onClose = () => {\n        resolve(arr);\n        cleanup();\n      };\n      const cleanup = () => {\n        arr = [];\n        stream.removeListener(\"data\", onData);\n        stream.removeListener(\"end\", onEnd);\n        stream.removeListener(\"error\", onEnd);\n        stream.removeListener(\"close\", onClose);\n      };\n      stream.on(\"data\", onData);\n      stream.on(\"end\", onEnd);\n      stream.on(\"error\", onEnd);\n      stream.on(\"close\", onClose);\n    });\n  }\n  return deferred;\n};\n\n// packages/common/async/src/timer.ts\nvar Timer = class {\n  constructor(_callback) {\n    this._callback = _callback;\n    this._state = new Event();\n    this._count = 0;\n  }\n  get state() {\n    return this._state;\n  }\n  get running() {\n    return !!this._timer;\n  }\n  start(options, cb) {\n    if (isNaN(options.count) || isNaN(options.interval)) {\n      throw new Error(`Invalid options: ${JSON.stringify(options)}`);\n    }\n    if (this.running) {\n      this.stop();\n    }\n    const stop = () => {\n      this.stop();\n      cb?.();\n    };\n    const run = () => {\n      if (this._count >= (options.count ?? 0)) {\n        stop();\n      } else {\n        const interval = (options.interval ?? 0) + Math.random() * (options.jitter ?? 0);\n        this._timer = setTimeout(async () => {\n          await this._callback(this._count++);\n          run();\n        }, interval);\n      }\n    };\n    this._state.emit(true);\n    this._count = 0;\n    setTimeout(run);\n    return this;\n  }\n  stop() {\n    clearInterval(this._timer);\n    this._timer = void 0;\n    this._state.emit(false);\n    return this;\n  }\n};\n\n// packages/common/async/src/testing.ts\nvar waitForCondition = ({ condition, timeout = 0, interval = 10, error }) => {\n  const stopTime = timeout ? Date.now() + timeout : 0;\n  const trigger2 = new Trigger();\n  const waiter = async () => {\n    while (!stopTime || Date.now() < stopTime) {\n      try {\n        const value = await condition();\n        if (value) {\n          trigger2.wake(value);\n          break;\n        }\n      } catch (err) {\n      }\n      await sleep(interval);\n    }\n  };\n  setTimeout(waiter, 0);\n  return timeout ? asyncTimeout(trigger2.wait(), timeout, error ?? new Error(\"Timeout\")) : trigger2.wait();\n};\n\n// packages/common/async/src/until.ts\nvar until = (cb, timeout) => {\n  return new Promise((resolve, reject) => {\n    const t = timeout && setTimeout(() => {\n      reject(new Error(`Timeout after ${t}ms`));\n    }, timeout);\n    setTimeout(async () => {\n      try {\n        await cb((value) => {\n          t && clearTimeout(t);\n          resolve(value);\n        }, (error) => {\n          t && clearTimeout(t);\n          reject(error);\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n};\nvar untilPromise = (cb) => cb();\nvar untilError = (cb) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(async () => {\n      try {\n        await cb();\n        reject(new Error(\"No error was thrown.\"));\n      } catch (err) {\n        resolve(err);\n      }\n    });\n  });\n};\n\n// packages/common/async/src/task-scheduling.ts\nimport { ContextDisposedError as ContextDisposedError2 } from \"@dxos/context\";\nimport { StackTrace as StackTrace2 } from \"@dxos/debug\";\n\n// packages/common/async/src/track-leaks.ts\nimport { StackTrace } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nvar __dxlog_file2 = \"/home/runner/work/dxos/dxos/packages/common/async/src/track-leaks.ts\";\nvar enabled = typeof process !== \"undefined\" && !!process.env.DX_TRACK_LEAKS;\nvar openResources = /* @__PURE__ */ new Set();\nvar handleSymbol = Symbol(\"checkLeaksHandle\");\nvar trackResource = (resourceProvider) => {\n  if (!enabled) {\n    return () => {\n    };\n  }\n  const resource = resourceProvider();\n  openResources.add(resource);\n  return () => {\n    openResources.delete(resource);\n  };\n};\nvar trackLeaks = (open, close) => (target) => {\n  if (!enabled) {\n    return;\n  }\n  const openMethod = target.prototype[open];\n  const closeMethod = target.prototype[close];\n  if (!openMethod || !closeMethod) {\n    throw new Error(`Cannot find ${open} or ${close} method in ${target.name}`);\n  }\n  {\n    target.prototype[open] = async function(...args) {\n      this[handleSymbol] = trackResource(() => ({\n        name: target.name,\n        openStack: new StackTrace()\n      }));\n      return openMethod.apply(this, args);\n    };\n    Object.defineProperty(target.prototype[open], \"name\", {\n      value: open + \"$checkLeaks\"\n    });\n  }\n  {\n    target.prototype[close] = async function(...args) {\n      this[handleSymbol]?.();\n      return closeMethod.apply(this, args);\n    };\n    Object.defineProperty(target.prototype[close], \"name\", {\n      value: close + \"$checkLeaks\"\n    });\n  }\n};\nvar dumpLeaks = () => {\n  if (!enabled) {\n    return;\n  }\n  log.info(`Leaked resources ${openResources.size}:`, void 0, {\n    F: __dxlog_file2,\n    L: 82,\n    S: void 0,\n    C: (f, a) => f(...a)\n  });\n  for (const resource of openResources) {\n    log.info(`- ${resource.name} at`, void 0, {\n      F: __dxlog_file2,\n      L: 84,\n      S: void 0,\n      C: (f, a) => f(...a)\n    });\n    log.info(resource.openStack.getStack(1), void 0, {\n      F: __dxlog_file2,\n      L: 85,\n      S: void 0,\n      C: (f, a) => f(...a)\n    });\n    log.info(\"\\n\", void 0, {\n      F: __dxlog_file2,\n      L: 86,\n      S: void 0,\n      C: (f, a) => f(...a)\n    });\n  }\n};\nif (enabled) {\n  global.dxDumpLeaks = dumpLeaks;\n}\n\n// packages/common/async/src/task-scheduling.ts\nvar DeferredTask = class {\n  constructor(_ctx, _callback) {\n    this._ctx = _ctx;\n    this._callback = _callback;\n    this._scheduled = false;\n    this._currentTask = null;\n    this._nextTask = new Trigger();\n  }\n  /**\n  * Schedule the task to run asynchronously.\n  */\n  schedule() {\n    if (this._scheduled) {\n      return;\n    }\n    scheduleTask(this._ctx, async () => {\n      await this._currentTask;\n      this._scheduled = false;\n      const completionTrigger = this._nextTask;\n      this._nextTask = new Trigger();\n      this._currentTask = runInContextAsync(this._ctx, () => this._callback()).then(() => {\n        completionTrigger.wake();\n      });\n    });\n    this._scheduled = true;\n  }\n  /**\n  * Schedule the task to run and wait for it to finish.\n  */\n  async runBlocking() {\n    if (this._ctx.disposed) {\n      throw new ContextDisposedError2();\n    }\n    this.schedule();\n    await this._nextTask.wait();\n  }\n  /**\n  * Waits for the current task to finish if it is running.\n  * Does not schedule a new task.\n  */\n  async join() {\n    await this._currentTask;\n  }\n};\nvar runInContext = (ctx, fn) => {\n  try {\n    fn();\n  } catch (err) {\n    ctx.raise(err);\n  }\n};\nvar runInContextAsync = async (ctx, fn) => {\n  try {\n    await fn();\n  } catch (err) {\n    ctx.raise(err);\n  }\n};\nvar scheduleMicroTask = (ctx, fn) => {\n  queueMicrotask(async () => {\n    if (ctx.disposed) {\n      return;\n    }\n    await runInContextAsync(ctx, fn);\n  });\n};\nvar scheduleTask = (ctx, fn, afterMs) => {\n  const clearTracking = trackResource(() => ({\n    name: `task (${fn.name || \"anonymous\"})`,\n    openStack: new StackTrace2()\n  }));\n  const timeout = setTimeout(async () => {\n    clearDispose();\n    await runInContextAsync(ctx, fn);\n    clearTracking();\n  }, afterMs);\n  const clearDispose = ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeout);\n  });\n};\nvar scheduleTaskInterval = (ctx, task, interval) => {\n  const clearTracking = trackResource(() => ({\n    name: `repeating task (${task.name || \"anonymous\"})`,\n    openStack: new StackTrace2()\n  }));\n  let timeoutId;\n  const run = async () => {\n    await runInContextAsync(ctx, task);\n    if (ctx.disposed) {\n      return;\n    }\n    timeoutId = setTimeout(run, interval);\n  };\n  timeoutId = setTimeout(run, interval);\n  ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeoutId);\n  });\n};\nvar scheduleExponentialBackoffTaskInterval = (ctx, task, initialInterval) => {\n  const clearTracking = trackResource(() => ({\n    name: `repeating task (${task.name || \"anonymous\"})`,\n    openStack: new StackTrace2()\n  }));\n  let timeoutId;\n  let interval = initialInterval;\n  const repeat = async () => {\n    await runInContextAsync(ctx, task);\n    if (ctx.disposed) {\n      return;\n    }\n    interval *= 2;\n    timeoutId = setTimeout(repeat, interval);\n  };\n  timeoutId = setTimeout(repeat, interval);\n  ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeoutId);\n  });\n};\n\n// packages/common/async/src/test-stream.ts\nimport { Duplex } from \"@dxos/node-std/stream\";\nvar TestStream = class extends Duplex {\n  constructor() {\n    super(...arguments);\n    this._received = Buffer.alloc(0);\n    this._onWrite = new Event();\n  }\n  static async assertConnectivity(stream1, stream2, { timeout = 200 } = {}) {\n    stream1.push(\"ping\");\n    stream2.push(\"pong\");\n    await Promise.all([\n      stream2.assertReceivedAsync(\"ping\", {\n        timeout\n      }),\n      stream1.assertReceivedAsync(\"pong\", {\n        timeout\n      })\n    ]);\n  }\n  _write(chunk, encoding, callback) {\n    this._received = Buffer.concat([\n      this._received,\n      chunk\n    ]);\n    this._onWrite.emit();\n    callback();\n  }\n  _read(size) {\n  }\n  assertReceivedAsync(data, { timeout = 200 } = {}) {\n    const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data);\n    return asyncTimeout(this._onWrite.waitForCondition(() => this._received.equals(dataBuffer)), timeout);\n  }\n};\n\n// packages/common/async/src/update-scheduler.ts\nvar TIME_PERIOD = 1e3;\nvar UpdateScheduler = class {\n  constructor(_ctx, _callback, _params = {}) {\n    this._ctx = _ctx;\n    this._callback = _callback;\n    this._params = _params;\n    this._promise = null;\n    this._scheduled = false;\n    this._lastUpdateTime = -TIME_PERIOD;\n    _ctx.onDispose(async () => {\n      await this._promise;\n    });\n  }\n  trigger() {\n    if (this._scheduled) {\n      return;\n    }\n    scheduleMicroTask(this._ctx, async () => {\n      await this._promise;\n      if (this._params.maxFrequency) {\n        const now = performance.now();\n        const delay = this._lastUpdateTime + TIME_PERIOD / this._params.maxFrequency - now;\n        if (delay > 0) {\n          await new Promise((resolve) => {\n            const clearContext = this._ctx.onDispose(() => {\n              clearTimeout(timeoutId);\n              resolve();\n            });\n            const timeoutId = setTimeout(() => {\n              clearContext();\n              resolve();\n            }, delay);\n          });\n        }\n      }\n      if (this._ctx.disposed) {\n        return;\n      }\n      this._lastUpdateTime = performance.now();\n      this._scheduled = false;\n      this._promise = this._callback().then(() => {\n        this._promise = null;\n      }, (error) => {\n        this._promise = null;\n        this._ctx.raise(error);\n      });\n    });\n    this._scheduled = true;\n  }\n  forceTrigger() {\n    scheduleMicroTask(this._ctx, async () => {\n      this._callback().catch((err) => this._ctx.raise(err));\n    });\n  }\n};\nexport {\n  CancellableObservableProvider,\n  DeferredTask,\n  Event,\n  EventSubscriptions,\n  MulticastObservable,\n  Mutex,\n  MutexGuard,\n  Observable,\n  ObservableProvider,\n  PushStream,\n  TestStream,\n  TimeoutError,\n  Timer,\n  Trigger,\n  TriggerState,\n  UpdateScheduler,\n  addListener,\n  asyncChain,\n  asyncTimeout,\n  createPromiseFromCallback,\n  debounce,\n  dumpLeaks,\n  latch,\n  observableError,\n  onEvent,\n  runInContext,\n  runInContextAsync,\n  scheduleExponentialBackoffTaskInterval,\n  scheduleMicroTask,\n  scheduleTask,\n  scheduleTaskInterval,\n  sink,\n  sleep,\n  sleepWithContext,\n  streamToArray,\n  synchronized,\n  toError,\n  trackLeaks,\n  trackResource,\n  trigger,\n  unrefTimeout,\n  until,\n  untilError,\n  untilPromise,\n  waitForCondition,\n  waitForEvent\n};\n//# sourceMappingURL=index.mjs.map\n","//\n// Copyright 2023 DXOS.org\n//\nimport { reconstructError } from './helpers';\nexport const encodeError = (err) => {\n    if (typeof err === 'object' && err?.message) {\n        return {\n            name: err.name,\n            message: err.message,\n            context: err.context,\n            stack: err.stack,\n        };\n    }\n    else if (typeof err === 'string') {\n        return {\n            message: err,\n        };\n    }\n    else {\n        return {\n            message: JSON.stringify(err),\n        };\n    }\n};\nexport const decodeError = (err, { appendStack } = {}) => {\n    const error = reconstructError(err);\n    if (appendStack) {\n        error.stack = (err.stack ?? `${error.message}\\n`) + appendStack;\n    }\n    else {\n        error.stack = err.stack;\n    }\n    return error;\n};\n//# sourceMappingURL=encoding.js.map","//\n// Copyright 2021 DXOS.org\n//\nimport { PublicKey } from '@dxos/keys';\nimport { ApiError, DatabaseError, SystemError, BaseError } from './base-errors';\nimport { registerError, registerErrorMessageContext, registerErrorNoArgs } from './helpers';\n/**\n * Thrown when request was terminated because the RPC endpoint has been closed.\n */\nexport class RpcClosedError extends SystemError {\n    constructor() {\n        super('RPC_CLOSED', 'Request was terminated because the RPC endpoint is closed.');\n    }\n}\nregisterErrorNoArgs('RPC_CLOSED', RpcClosedError);\n/**\n * Thrown when `request` is called when RPC has not been opened.\n */\nexport class RpcNotOpenError extends SystemError {\n    constructor() {\n        super('RPC_NOT_OPEN', 'RPC has not been opened.');\n    }\n}\nregisterErrorNoArgs('RPC_NOT_OPEN', RpcNotOpenError);\nexport class CancelledError extends SystemError {\n    constructor(message, context) {\n        super('CANCELLED', message, context);\n    }\n}\nregisterErrorMessageContext('CANCELLED', CancelledError);\nexport class InvalidConfigError extends ApiError {\n    constructor(message, context) {\n        super('INVALID_CONFIG', message, context);\n    }\n}\nregisterErrorMessageContext('INVALID_CONFIG', InvalidConfigError);\n/**\n * Explicit failure to connect with remote client services.\n */\nexport class RemoteServiceConnectionError extends ApiError {\n    constructor(message, context) {\n        super('REMOTE_SERVICE_CONNECTION_ERROR', message, context);\n    }\n}\nregisterErrorMessageContext('REMOTE_SERVICE_CONNECTION_ERROR', RemoteServiceConnectionError);\n/**\n * Failed to open a connection to remote client services.\n */\nexport class RemoteServiceConnectionTimeout extends ApiError {\n    constructor(message, context) {\n        super('REMOTE_SERVICE_CONNECTION_TIMEOUT', message, context);\n    }\n}\nregisterErrorMessageContext('REMOTE_SERVICE_CONNECTION_TIMEOUT', RemoteServiceConnectionTimeout);\nexport class DataCorruptionError extends SystemError {\n    constructor(message, context) {\n        super('DATA_CORRUPTION', message, context);\n    }\n}\nregisterErrorMessageContext('DATA_CORRUPTION', DataCorruptionError);\nexport class InvalidInvitationExtensionRoleError extends SystemError {\n    constructor(message, context) {\n        super('INVALID_INVITATION_EXTENSION_ROLE', message, context);\n    }\n}\nregisterErrorMessageContext('INVALID_INVITATION_EXTENSION_ROLE', InvalidInvitationExtensionRoleError);\nexport class IdentityNotInitializedError extends DatabaseError {\n    constructor(message, context) {\n        super('IDENTITY_NOT_INITIALIZED', message, context);\n    }\n}\nregisterErrorMessageContext('IDENTITY_NOT_INITIALIZED', IdentityNotInitializedError);\nexport class InvalidInvitationError extends DatabaseError {\n    constructor(message, context) {\n        super('INVALID_INVITATION', message, context);\n    }\n}\nregisterErrorMessageContext('INVALID_INVITATION', InvalidInvitationError);\nexport class AlreadyJoinedError extends DatabaseError {\n    constructor(message, context) {\n        super('ALREADY_JOINED', message, context);\n    }\n}\nregisterErrorMessageContext('ALREADY_JOINED', AlreadyJoinedError);\nexport class ConnectionResetError extends BaseError {\n    constructor(message, context) {\n        super('CONNECTION_RESET', message, context);\n    }\n}\nregisterErrorMessageContext('CONNECTION_RESET', ConnectionResetError);\nexport class TimeoutError extends BaseError {\n    constructor(message, context) {\n        super('TIMEOUT', message, context);\n    }\n}\nregisterErrorMessageContext('TIMEOUT', TimeoutError);\n// General protocol error.\nexport class ProtocolError extends BaseError {\n    constructor(message, context) {\n        super('PROTOCOL_ERROR', message, context);\n    }\n}\nregisterErrorMessageContext('PROTOCOL_ERROR', ProtocolError);\n// General connectivity errors.\nexport class ConnectivityError extends BaseError {\n    constructor(message, context) {\n        super('CONNECTIVITY_ERROR', message, context);\n    }\n}\nregisterErrorMessageContext('CONNECTIVITY_ERROR', ConnectivityError);\nexport class RateLimitExceededError extends BaseError {\n    constructor(message, context) {\n        super('RATE_LIMIT_EXCEEDED', message, context);\n    }\n}\nregisterErrorMessageContext('RATE_LIMIT_EXCEEDED', RateLimitExceededError);\n// TODO(nf): Rename? the protocol isn't what's unknown...\nexport class UnknownProtocolError extends BaseError {\n    constructor(message, innerError) {\n        super('UNKNOWN_PROTOCOL_ERROR', message, innerError);\n    }\n}\nregisterErrorMessageContext('UNKNOWN_PROTOCOL_ERROR', UnknownProtocolError);\nexport class InvalidStorageVersionError extends DatabaseError {\n    constructor(expected, actual) {\n        super('INVALID_STORAGE_VERSION', 'Invalid storage version.', { expected, actual });\n    }\n}\nregisterError('INVALID_STORAGE_VERSION', (_, context) => {\n    return new InvalidStorageVersionError(context.expected ?? NaN, context.actual ?? NaN);\n});\nexport class SpaceNotFoundError extends DatabaseError {\n    constructor(spaceKey) {\n        super('SPACE_NOT_FOUND', 'Space not found.', { spaceKey });\n    }\n}\nregisterError('SPACE_NOT_FOUND', (_, context) => {\n    return new SpaceNotFoundError(PublicKey.safeFrom(context.spaceKey) ?? PublicKey.from('00'));\n});\nexport class EntityNotFoundError extends DatabaseError {\n    constructor(entityId) {\n        super('ITEM_NOT_FOUND', 'Item not found.', { entityId });\n    }\n}\nregisterError('ITEM_NOT_FOUND', (_, context) => {\n    return new EntityNotFoundError(context.entityId);\n});\nexport class UnknownModelError extends DatabaseError {\n    constructor(model) {\n        super('UNKNOWN_MODEL', 'Unknown model.', { model });\n    }\n}\nregisterError('UNKNOWN_MODEL', (_, context) => {\n    return new UnknownModelError(context.model);\n});\nexport class AuthorizationError extends ApiError {\n    constructor(message, context) {\n        super('AUTHORIZATION_ERROR', message, context);\n    }\n}\nregisterErrorMessageContext('AUTHORIZATION_ERROR', AuthorizationError);\n//# sourceMappingURL=errors.js.map","\"use strict\";\r\nmodule.exports = codegen;\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @param {string[]} functionParams Function parameter names\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n */\r\nfunction codegen(functionParams, functionName) {\r\n\r\n    /* istanbul ignore if */\r\n    if (typeof functionParams === \"string\") {\r\n        functionName = functionParams;\r\n        functionParams = undefined;\r\n    }\r\n\r\n    var body = [];\r\n\r\n    /**\r\n     * Appends code to the function's body or finishes generation.\r\n     * @typedef Codegen\r\n     * @type {function}\r\n     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any\r\n     * @param {...*} [formatParams] Format parameters\r\n     * @returns {Codegen|Function} Itself or the generated function if finished\r\n     * @throws {Error} If format parameter counts do not match\r\n     */\r\n\r\n    function Codegen(formatStringOrScope) {\r\n        // note that explicit array handling below makes this ~50% faster\r\n\r\n        // finish the function\r\n        if (typeof formatStringOrScope !== \"string\") {\r\n            var source = toString();\r\n            if (codegen.verbose)\r\n                console.log(\"codegen: \" + source); // eslint-disable-line no-console\r\n            source = \"return \" + source;\r\n            if (formatStringOrScope) {\r\n                var scopeKeys   = Object.keys(formatStringOrScope),\r\n                    scopeParams = new Array(scopeKeys.length + 1),\r\n                    scopeValues = new Array(scopeKeys.length),\r\n                    scopeOffset = 0;\r\n                while (scopeOffset < scopeKeys.length) {\r\n                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];\r\n                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];\r\n                }\r\n                scopeParams[scopeOffset] = source;\r\n                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func\r\n            }\r\n            return Function(source)(); // eslint-disable-line no-new-func\r\n        }\r\n\r\n        // otherwise append to body\r\n        var formatParams = new Array(arguments.length - 1),\r\n            formatOffset = 0;\r\n        while (formatOffset < formatParams.length)\r\n            formatParams[formatOffset] = arguments[++formatOffset];\r\n        formatOffset = 0;\r\n        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {\r\n            var value = formatParams[formatOffset++];\r\n            switch ($1) {\r\n                case \"d\": case \"f\": return String(Number(value));\r\n                case \"i\": return String(Math.floor(value));\r\n                case \"j\": return JSON.stringify(value);\r\n                case \"s\": return String(value);\r\n            }\r\n            return \"%\";\r\n        });\r\n        if (formatOffset !== formatParams.length)\r\n            throw Error(\"parameter count mismatch\");\r\n        body.push(formatStringOrScope);\r\n        return Codegen;\r\n    }\r\n\r\n    function toString(functionNameOverride) {\r\n        return \"function \" + (functionNameOverride || functionName || \"\") + \"(\" + (functionParams && functionParams.join(\",\") || \"\") + \"){\\n  \" + body.join(\"\\n  \") + \"\\n}\";\r\n    }\r\n\r\n    Codegen.toString = toString;\r\n    return Codegen;\r\n}\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @function codegen\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * When set to `true`, codegen will log generated code to console. Useful for debugging.\r\n * @name util.codegen.verbose\r\n * @type {boolean}\r\n */\r\ncodegen.verbose = false;\r\n","\"use strict\";\r\nmodule.exports = fetch;\r\n\r\nvar asPromise = require(\"@protobufjs/aspromise\"),\r\n    inquire   = require(\"@protobufjs/inquire\");\r\n\r\nvar fs = inquire(\"fs\");\r\n\r\n/**\r\n * Node-style callback as used by {@link util.fetch}.\r\n * @typedef FetchCallback\r\n * @type {function}\r\n * @param {?Error} error Error, if any, otherwise `null`\r\n * @param {string} [contents] File contents, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Options as used by {@link util.fetch}.\r\n * @typedef FetchOptions\r\n * @type {Object}\r\n * @property {boolean} [binary=false] Whether expecting a binary response\r\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @memberof util\r\n * @param {string} filename File path or url\r\n * @param {FetchOptions} options Fetch options\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\r\nfunction fetch(filename, options, callback) {\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    } else if (!options)\r\n        options = {};\r\n\r\n    if (!callback)\r\n        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\r\n\r\n    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\r\n    if (!options.xhr && fs && fs.readFile)\r\n        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\r\n            return err && typeof XMLHttpRequest !== \"undefined\"\r\n                ? fetch.xhr(filename, options, callback)\r\n                : err\r\n                ? callback(err)\r\n                : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\r\n        });\r\n\r\n    // use the XHR version otherwise.\r\n    return fetch.xhr(filename, options, callback);\r\n}\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchOptions} [options] Fetch options\r\n * @returns {Promise<string|Uint8Array>} Promise\r\n * @variation 3\r\n */\r\n\r\n/**/\r\nfetch.xhr = function fetch_xhr(filename, options, callback) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {\r\n\r\n        if (xhr.readyState !== 4)\r\n            return undefined;\r\n\r\n        // local cors security errors return status 0 / empty string, too. afaik this cannot be\r\n        // reliably distinguished from an actually empty file for security reasons. feel free\r\n        // to send a pull request if you are aware of a solution.\r\n        if (xhr.status !== 0 && xhr.status !== 200)\r\n            return callback(Error(\"status \" + xhr.status));\r\n\r\n        // if binary data is expected, make sure that some sort of array is returned, even if\r\n        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\r\n        if (options.binary) {\r\n            var buffer = xhr.response;\r\n            if (!buffer) {\r\n                buffer = [];\r\n                for (var i = 0; i < xhr.responseText.length; ++i)\r\n                    buffer.push(xhr.responseText.charCodeAt(i) & 255);\r\n            }\r\n            return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\r\n        }\r\n        return callback(null, xhr.responseText);\r\n    };\r\n\r\n    if (options.binary) {\r\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\r\n        if (\"overrideMimeType\" in xhr)\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n        xhr.responseType = \"arraybuffer\";\r\n    }\r\n\r\n    xhr.open(\"GET\", filename);\r\n    xhr.send();\r\n};\r\n","\"use strict\";\r\nmodule.exports = tokenize;\r\n\r\nvar delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\r\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\r\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\r\n\r\nvar setCommentRe = /^ *[*/]+ */,\r\n    setCommentAltRe = /^\\s*\\*?\\/*/,\r\n    setCommentSplitRe = /\\n/g,\r\n    whitespaceRe = /\\s/,\r\n    unescapeRe = /\\\\(.?)/g;\r\n\r\nvar unescapeMap = {\r\n    \"0\": \"\\0\",\r\n    \"r\": \"\\r\",\r\n    \"n\": \"\\n\",\r\n    \"t\": \"\\t\"\r\n};\r\n\r\n/**\r\n * Unescapes a string.\r\n * @param {string} str String to unescape\r\n * @returns {string} Unescaped string\r\n * @property {Object.<string,string>} map Special characters map\r\n * @memberof tokenize\r\n */\r\nfunction unescape(str) {\r\n    return str.replace(unescapeRe, function($0, $1) {\r\n        switch ($1) {\r\n            case \"\\\\\":\r\n            case \"\":\r\n                return $1;\r\n            default:\r\n                return unescapeMap[$1] || \"\";\r\n        }\r\n    });\r\n}\r\n\r\ntokenize.unescape = unescape;\r\n\r\n/**\r\n * Gets the next token and advances.\r\n * @typedef TokenizerHandleNext\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\r\n\r\n/**\r\n * Peeks for the next token.\r\n * @typedef TokenizerHandlePeek\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\r\n\r\n/**\r\n * Pushes a token back to the stack.\r\n * @typedef TokenizerHandlePush\r\n * @type {function}\r\n * @param {string} token Token\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Skips the next token.\r\n * @typedef TokenizerHandleSkip\r\n * @type {function}\r\n * @param {string} expected Expected token\r\n * @param {boolean} [optional=false] If optional\r\n * @returns {boolean} Whether the token matched\r\n * @throws {Error} If the token didn't match and is not optional\r\n */\r\n\r\n/**\r\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\r\n * @typedef TokenizerHandleCmnt\r\n * @type {function}\r\n * @param {number} [line] Line number\r\n * @returns {string|null} Comment text or `null` if none\r\n */\r\n\r\n/**\r\n * Handle object returned from {@link tokenize}.\r\n * @interface ITokenizerHandle\r\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\r\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\r\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\r\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\r\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\r\n * @property {number} line Current line number\r\n */\r\n\r\n/**\r\n * Tokenizes the given .proto source and returns an object with useful utility functions.\r\n * @param {string} source Source contents\r\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\r\n * @returns {ITokenizerHandle} Tokenizer handle\r\n */\r\nfunction tokenize(source, alternateCommentMode) {\r\n    /* eslint-disable callback-return */\r\n    source = source.toString();\r\n\r\n    var offset = 0,\r\n        length = source.length,\r\n        line = 1,\r\n        lastCommentLine = 0,\r\n        comments = {};\r\n\r\n    var stack = [];\r\n\r\n    var stringDelim = null;\r\n\r\n    /* istanbul ignore next */\r\n    /**\r\n     * Creates an error for illegal syntax.\r\n     * @param {string} subject Subject\r\n     * @returns {Error} Error created\r\n     * @inner\r\n     */\r\n    function illegal(subject) {\r\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\r\n    }\r\n\r\n    /**\r\n     * Reads a string till its end.\r\n     * @returns {string} String read\r\n     * @inner\r\n     */\r\n    function readString() {\r\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\r\n        re.lastIndex = offset - 1;\r\n        var match = re.exec(source);\r\n        if (!match)\r\n            throw illegal(\"string\");\r\n        offset = re.lastIndex;\r\n        push(stringDelim);\r\n        stringDelim = null;\r\n        return unescape(match[1]);\r\n    }\r\n\r\n    /**\r\n     * Gets the character at `pos` within the source.\r\n     * @param {number} pos Position\r\n     * @returns {string} Character\r\n     * @inner\r\n     */\r\n    function charAt(pos) {\r\n        return source.charAt(pos);\r\n    }\r\n\r\n    /**\r\n     * Sets the current comment text.\r\n     * @param {number} start Start offset\r\n     * @param {number} end End offset\r\n     * @param {boolean} isLeading set if a leading comment\r\n     * @returns {undefined}\r\n     * @inner\r\n     */\r\n    function setComment(start, end, isLeading) {\r\n        var comment = {\r\n            type: source.charAt(start++),\r\n            lineEmpty: false,\r\n            leading: isLeading,\r\n        };\r\n        var lookback;\r\n        if (alternateCommentMode) {\r\n            lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\r\n        } else {\r\n            lookback = 3;  // \"///\" or \"/**\"\r\n        }\r\n        var commentOffset = start - lookback,\r\n            c;\r\n        do {\r\n            if (--commentOffset < 0 ||\r\n                    (c = source.charAt(commentOffset)) === \"\\n\") {\r\n                comment.lineEmpty = true;\r\n                break;\r\n            }\r\n        } while (c === \" \" || c === \"\\t\");\r\n        var lines = source\r\n            .substring(start, end)\r\n            .split(setCommentSplitRe);\r\n        for (var i = 0; i < lines.length; ++i)\r\n            lines[i] = lines[i]\r\n                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\r\n                .trim();\r\n        comment.text = lines\r\n            .join(\"\\n\")\r\n            .trim();\r\n\r\n        comments[line] = comment;\r\n        lastCommentLine = line;\r\n    }\r\n\r\n    function isDoubleSlashCommentLine(startOffset) {\r\n        var endOffset = findEndOfLine(startOffset);\r\n\r\n        // see if remaining line matches comment pattern\r\n        var lineText = source.substring(startOffset, endOffset);\r\n        var isComment = /^\\s*\\/\\//.test(lineText);\r\n        return isComment;\r\n    }\r\n\r\n    function findEndOfLine(cursor) {\r\n        // find end of cursor's line\r\n        var endOffset = cursor;\r\n        while (endOffset < length && charAt(endOffset) !== \"\\n\") {\r\n            endOffset++;\r\n        }\r\n        return endOffset;\r\n    }\r\n\r\n    /**\r\n     * Obtains the next token.\r\n     * @returns {string|null} Next token or `null` on eof\r\n     * @inner\r\n     */\r\n    function next() {\r\n        if (stack.length > 0)\r\n            return stack.shift();\r\n        if (stringDelim)\r\n            return readString();\r\n        var repeat,\r\n            prev,\r\n            curr,\r\n            start,\r\n            isDoc,\r\n            isLeadingComment = offset === 0;\r\n        do {\r\n            if (offset === length)\r\n                return null;\r\n            repeat = false;\r\n            while (whitespaceRe.test(curr = charAt(offset))) {\r\n                if (curr === \"\\n\") {\r\n                    isLeadingComment = true;\r\n                    ++line;\r\n                }\r\n                if (++offset === length)\r\n                    return null;\r\n            }\r\n\r\n            if (charAt(offset) === \"/\") {\r\n                if (++offset === length) {\r\n                    throw illegal(\"comment\");\r\n                }\r\n                if (charAt(offset) === \"/\") { // Line\r\n                    if (!alternateCommentMode) {\r\n                        // check for triple-slash comment\r\n                        isDoc = charAt(start = offset + 1) === \"/\";\r\n\r\n                        while (charAt(++offset) !== \"\\n\") {\r\n                            if (offset === length) {\r\n                                return null;\r\n                            }\r\n                        }\r\n                        ++offset;\r\n                        if (isDoc) {\r\n                            setComment(start, offset - 1, isLeadingComment);\r\n                            // Trailing comment cannot not be multi-line,\r\n                            // so leading comment state should be reset to handle potential next comments\r\n                            isLeadingComment = true;\r\n                        }\r\n                        ++line;\r\n                        repeat = true;\r\n                    } else {\r\n                        // check for double-slash comments, consolidating consecutive lines\r\n                        start = offset;\r\n                        isDoc = false;\r\n                        if (isDoubleSlashCommentLine(offset - 1)) {\r\n                            isDoc = true;\r\n                            do {\r\n                                offset = findEndOfLine(offset);\r\n                                if (offset === length) {\r\n                                    break;\r\n                                }\r\n                                offset++;\r\n                                if (!isLeadingComment) {\r\n                                    // Trailing comment cannot not be multi-line\r\n                                    break;\r\n                                }\r\n                            } while (isDoubleSlashCommentLine(offset));\r\n                        } else {\r\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\r\n                        }\r\n                        if (isDoc) {\r\n                            setComment(start, offset, isLeadingComment);\r\n                            isLeadingComment = true;\r\n                        }\r\n                        line++;\r\n                        repeat = true;\r\n                    }\r\n                } else if ((curr = charAt(offset)) === \"*\") { /* Block */\r\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\r\n                    start = offset + 1;\r\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\r\n                    do {\r\n                        if (curr === \"\\n\") {\r\n                            ++line;\r\n                        }\r\n                        if (++offset === length) {\r\n                            throw illegal(\"comment\");\r\n                        }\r\n                        prev = curr;\r\n                        curr = charAt(offset);\r\n                    } while (prev !== \"*\" || curr !== \"/\");\r\n                    ++offset;\r\n                    if (isDoc) {\r\n                        setComment(start, offset - 2, isLeadingComment);\r\n                        isLeadingComment = true;\r\n                    }\r\n                    repeat = true;\r\n                } else {\r\n                    return \"/\";\r\n                }\r\n            }\r\n        } while (repeat);\r\n\r\n        // offset !== length if we got here\r\n\r\n        var end = offset;\r\n        delimRe.lastIndex = 0;\r\n        var delim = delimRe.test(charAt(end++));\r\n        if (!delim)\r\n            while (end < length && !delimRe.test(charAt(end)))\r\n                ++end;\r\n        var token = source.substring(offset, offset = end);\r\n        if (token === \"\\\"\" || token === \"'\")\r\n            stringDelim = token;\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Pushes a token back to the stack.\r\n     * @param {string} token Token\r\n     * @returns {undefined}\r\n     * @inner\r\n     */\r\n    function push(token) {\r\n        stack.push(token);\r\n    }\r\n\r\n    /**\r\n     * Peeks for the next token.\r\n     * @returns {string|null} Token or `null` on eof\r\n     * @inner\r\n     */\r\n    function peek() {\r\n        if (!stack.length) {\r\n            var token = next();\r\n            if (token === null)\r\n                return null;\r\n            push(token);\r\n        }\r\n        return stack[0];\r\n    }\r\n\r\n    /**\r\n     * Skips a token.\r\n     * @param {string} expected Expected token\r\n     * @param {boolean} [optional=false] Whether the token is optional\r\n     * @returns {boolean} `true` when skipped, `false` if not\r\n     * @throws {Error} When a required token is not present\r\n     * @inner\r\n     */\r\n    function skip(expected, optional) {\r\n        var actual = peek(),\r\n            equals = actual === expected;\r\n        if (equals) {\r\n            next();\r\n            return true;\r\n        }\r\n        if (!optional)\r\n            throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a comment.\r\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\r\n     * @returns {string|null} Comment text\r\n     * @inner\r\n     */\r\n    function cmnt(trailingLine) {\r\n        var ret = null;\r\n        var comment;\r\n        if (trailingLine === undefined) {\r\n            comment = comments[line - 1];\r\n            delete comments[line - 1];\r\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\r\n                ret = comment.leading ? comment.text : null;\r\n            }\r\n        } else {\r\n            /* istanbul ignore else */\r\n            if (lastCommentLine < trailingLine) {\r\n                peek();\r\n            }\r\n            comment = comments[trailingLine];\r\n            delete comments[trailingLine];\r\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\r\n                ret = comment.leading ? null : comment.text;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    return Object.defineProperty({\r\n        next: next,\r\n        peek: peek,\r\n        push: push,\r\n        skip: skip,\r\n        cmnt: cmnt\r\n    }, \"line\", {\r\n        get: function() { return line; }\r\n    });\r\n    /* eslint-enable callback-return */\r\n}\r\n","\"use strict\";\r\nmodule.exports = parse;\r\n\r\nparse.filename = null;\r\nparse.defaults = { keepCase: false };\r\n\r\nvar tokenize  = require(\"./tokenize\"),\r\n    Root      = require(\"./root\"),\r\n    Type      = require(\"./type\"),\r\n    Field     = require(\"./field\"),\r\n    MapField  = require(\"./mapfield\"),\r\n    OneOf     = require(\"./oneof\"),\r\n    Enum      = require(\"./enum\"),\r\n    Service   = require(\"./service\"),\r\n    Method    = require(\"./method\"),\r\n    types     = require(\"./types\"),\r\n    util      = require(\"./util\");\r\n\r\nvar base10Re    = /^[1-9][0-9]*$/,\r\n    base10NegRe = /^-?[1-9][0-9]*$/,\r\n    base16Re    = /^0[x][0-9a-fA-F]+$/,\r\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\r\n    base8Re     = /^0[0-7]+$/,\r\n    base8NegRe  = /^-?0[0-7]+$/,\r\n    numberRe    = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\r\n    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\r\n    typeRefRe   = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\r\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\r\n\r\n/**\r\n * Result object returned from {@link parse}.\r\n * @interface IParserResult\r\n * @property {string|undefined} package Package name, if declared\r\n * @property {string[]|undefined} imports Imports, if any\r\n * @property {string[]|undefined} weakImports Weak imports, if any\r\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\r\n * @property {Root} root Populated root instance\r\n */\r\n\r\n/**\r\n * Options modifying the behavior of {@link parse}.\r\n * @interface IParseOptions\r\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\r\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\r\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\r\n */\r\n\r\n/**\r\n * Options modifying the behavior of JSON serialization.\r\n * @interface IToJSONOptions\r\n * @property {boolean} [keepComments=false] Serializes comments.\r\n */\r\n\r\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @param {string} source Source contents\r\n * @param {Root} root Root to populate\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n */\r\nfunction parse(source, root, options) {\r\n    /* eslint-disable callback-return */\r\n    if (!(root instanceof Root)) {\r\n        options = root;\r\n        root = new Root();\r\n    }\r\n    if (!options)\r\n        options = parse.defaults;\r\n\r\n    var preferTrailingComment = options.preferTrailingComment || false;\r\n    var tn = tokenize(source, options.alternateCommentMode || false),\r\n        next = tn.next,\r\n        push = tn.push,\r\n        peek = tn.peek,\r\n        skip = tn.skip,\r\n        cmnt = tn.cmnt;\r\n\r\n    var head = true,\r\n        pkg,\r\n        imports,\r\n        weakImports,\r\n        syntax,\r\n        isProto3 = false;\r\n\r\n    var ptr = root;\r\n\r\n    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;\r\n\r\n    /* istanbul ignore next */\r\n    function illegal(token, name, insideTryCatch) {\r\n        var filename = parse.filename;\r\n        if (!insideTryCatch)\r\n            parse.filename = null;\r\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\r\n    }\r\n\r\n    function readString() {\r\n        var values = [],\r\n            token;\r\n        do {\r\n            /* istanbul ignore if */\r\n            if ((token = next()) !== \"\\\"\" && token !== \"'\")\r\n                throw illegal(token);\r\n\r\n            values.push(next());\r\n            skip(token);\r\n            token = peek();\r\n        } while (token === \"\\\"\" || token === \"'\");\r\n        return values.join(\"\");\r\n    }\r\n\r\n    function readValue(acceptTypeRef) {\r\n        var token = next();\r\n        switch (token) {\r\n            case \"'\":\r\n            case \"\\\"\":\r\n                push(token);\r\n                return readString();\r\n            case \"true\": case \"TRUE\":\r\n                return true;\r\n            case \"false\": case \"FALSE\":\r\n                return false;\r\n        }\r\n        try {\r\n            return parseNumber(token, /* insideTryCatch */ true);\r\n        } catch (e) {\r\n\r\n            /* istanbul ignore else */\r\n            if (acceptTypeRef && typeRefRe.test(token))\r\n                return token;\r\n\r\n            /* istanbul ignore next */\r\n            throw illegal(token, \"value\");\r\n        }\r\n    }\r\n\r\n    function readRanges(target, acceptStrings) {\r\n        var token, start;\r\n        do {\r\n            if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\"))\r\n                target.push(readString());\r\n            else\r\n                target.push([ start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start ]);\r\n        } while (skip(\",\", true));\r\n        var dummy = {options: undefined};\r\n        dummy.setOption = function(name, value) {\r\n          if (this.options === undefined) this.options = {};\r\n          this.options[name] = value;\r\n        };\r\n        ifBlock(\r\n            dummy,\r\n            function parseRange_block(token) {\r\n              /* istanbul ignore else */\r\n              if (token === \"option\") {\r\n                parseOption(dummy, token);  // skip\r\n                skip(\";\");\r\n              } else\r\n                throw illegal(token);\r\n            },\r\n            function parseRange_line() {\r\n              parseInlineOptions(dummy);  // skip\r\n            });\r\n    }\r\n\r\n    function parseNumber(token, insideTryCatch) {\r\n        var sign = 1;\r\n        if (token.charAt(0) === \"-\") {\r\n            sign = -1;\r\n            token = token.substring(1);\r\n        }\r\n        switch (token) {\r\n            case \"inf\": case \"INF\": case \"Inf\":\r\n                return sign * Infinity;\r\n            case \"nan\": case \"NAN\": case \"Nan\": case \"NaN\":\r\n                return NaN;\r\n            case \"0\":\r\n                return 0;\r\n        }\r\n        if (base10Re.test(token))\r\n            return sign * parseInt(token, 10);\r\n        if (base16Re.test(token))\r\n            return sign * parseInt(token, 16);\r\n        if (base8Re.test(token))\r\n            return sign * parseInt(token, 8);\r\n\r\n        /* istanbul ignore else */\r\n        if (numberRe.test(token))\r\n            return sign * parseFloat(token);\r\n\r\n        /* istanbul ignore next */\r\n        throw illegal(token, \"number\", insideTryCatch);\r\n    }\r\n\r\n    function parseId(token, acceptNegative) {\r\n        switch (token) {\r\n            case \"max\": case \"MAX\": case \"Max\":\r\n                return 536870911;\r\n            case \"0\":\r\n                return 0;\r\n        }\r\n\r\n        /* istanbul ignore if */\r\n        if (!acceptNegative && token.charAt(0) === \"-\")\r\n            throw illegal(token, \"id\");\r\n\r\n        if (base10NegRe.test(token))\r\n            return parseInt(token, 10);\r\n        if (base16NegRe.test(token))\r\n            return parseInt(token, 16);\r\n\r\n        /* istanbul ignore else */\r\n        if (base8NegRe.test(token))\r\n            return parseInt(token, 8);\r\n\r\n        /* istanbul ignore next */\r\n        throw illegal(token, \"id\");\r\n    }\r\n\r\n    function parsePackage() {\r\n\r\n        /* istanbul ignore if */\r\n        if (pkg !== undefined)\r\n            throw illegal(\"package\");\r\n\r\n        pkg = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(pkg))\r\n            throw illegal(pkg, \"name\");\r\n\r\n        ptr = ptr.define(pkg);\r\n        skip(\";\");\r\n    }\r\n\r\n    function parseImport() {\r\n        var token = peek();\r\n        var whichImports;\r\n        switch (token) {\r\n            case \"weak\":\r\n                whichImports = weakImports || (weakImports = []);\r\n                next();\r\n                break;\r\n            case \"public\":\r\n                next();\r\n                // eslint-disable-next-line no-fallthrough\r\n            default:\r\n                whichImports = imports || (imports = []);\r\n                break;\r\n        }\r\n        token = readString();\r\n        skip(\";\");\r\n        whichImports.push(token);\r\n    }\r\n\r\n    function parseSyntax() {\r\n        skip(\"=\");\r\n        syntax = readString();\r\n        isProto3 = syntax === \"proto3\";\r\n\r\n        /* istanbul ignore if */\r\n        if (!isProto3 && syntax !== \"proto2\")\r\n            throw illegal(syntax, \"syntax\");\r\n\r\n        skip(\";\");\r\n    }\r\n\r\n    function parseCommon(parent, token) {\r\n        switch (token) {\r\n\r\n            case \"option\":\r\n                parseOption(parent, token);\r\n                skip(\";\");\r\n                return true;\r\n\r\n            case \"message\":\r\n                parseType(parent, token);\r\n                return true;\r\n\r\n            case \"enum\":\r\n                parseEnum(parent, token);\r\n                return true;\r\n\r\n            case \"service\":\r\n                parseService(parent, token);\r\n                return true;\r\n\r\n            case \"extend\":\r\n                parseExtension(parent, token);\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function ifBlock(obj, fnIf, fnElse) {\r\n        var trailingLine = tn.line;\r\n        if (obj) {\r\n            if(typeof obj.comment !== \"string\") {\r\n              obj.comment = cmnt(); // try block-type comment\r\n            }\r\n            obj.filename = parse.filename;\r\n        }\r\n        if (skip(\"{\", true)) {\r\n            var token;\r\n            while ((token = next()) !== \"}\")\r\n                fnIf(token);\r\n            skip(\";\", true);\r\n        } else {\r\n            if (fnElse)\r\n                fnElse();\r\n            skip(\";\");\r\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment))\r\n                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\r\n        }\r\n    }\r\n\r\n    function parseType(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"type name\");\r\n\r\n        var type = new Type(token);\r\n        ifBlock(type, function parseType_block(token) {\r\n            if (parseCommon(type, token))\r\n                return;\r\n\r\n            switch (token) {\r\n\r\n                case \"map\":\r\n                    parseMapField(type, token);\r\n                    break;\r\n\r\n                case \"required\":\r\n                case \"repeated\":\r\n                    parseField(type, token);\r\n                    break;\r\n\r\n                case \"optional\":\r\n                    /* istanbul ignore if */\r\n                    if (isProto3) {\r\n                        parseField(type, \"proto3_optional\");\r\n                    } else {\r\n                        parseField(type, \"optional\");\r\n                    }\r\n                    break;\r\n\r\n                case \"oneof\":\r\n                    parseOneOf(type, token);\r\n                    break;\r\n\r\n                case \"extensions\":\r\n                    readRanges(type.extensions || (type.extensions = []));\r\n                    break;\r\n\r\n                case \"reserved\":\r\n                    readRanges(type.reserved || (type.reserved = []), true);\r\n                    break;\r\n\r\n                default:\r\n                    /* istanbul ignore if */\r\n                    if (!isProto3 || !typeRefRe.test(token))\r\n                        throw illegal(token);\r\n\r\n                    push(token);\r\n                    parseField(type, \"optional\");\r\n                    break;\r\n            }\r\n        });\r\n        parent.add(type);\r\n    }\r\n\r\n    function parseField(parent, rule, extend) {\r\n        var type = next();\r\n        if (type === \"group\") {\r\n            parseGroup(parent, rule);\r\n            return;\r\n        }\r\n        // Type names can consume multiple tokens, in multiple variants:\r\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\r\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\r\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\r\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\r\n        // Keep reading tokens until we get a type name with no period at the end,\r\n        // and the next token does not start with a period.\r\n        while (type.endsWith(\".\") || peek().startsWith(\".\")) {\r\n            type += next();\r\n        }\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(type))\r\n            throw illegal(type, \"type\");\r\n\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        name = applyCase(name);\r\n        skip(\"=\");\r\n\r\n        var field = new Field(name, parseId(next()), type, rule, extend);\r\n        ifBlock(field, function parseField_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(field, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseField_line() {\r\n            parseInlineOptions(field);\r\n        });\r\n\r\n        if (rule === \"proto3_optional\") {\r\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\r\n            var oneof = new OneOf(\"_\" + name);\r\n            field.setOption(\"proto3_optional\", true);\r\n            oneof.add(field);\r\n            parent.add(oneof);\r\n        } else {\r\n            parent.add(field);\r\n        }\r\n\r\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\r\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\r\n        // all known packable types and anything that could be an enum (= is not a basic type).\r\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))\r\n            field.setOption(\"packed\", false, /* ifNotSet */ true);\r\n    }\r\n\r\n    function parseGroup(parent, rule) {\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        var fieldName = util.lcFirst(name);\r\n        if (name === fieldName)\r\n            name = util.ucFirst(name);\r\n        skip(\"=\");\r\n        var id = parseId(next());\r\n        var type = new Type(name);\r\n        type.group = true;\r\n        var field = new Field(fieldName, id, name, rule);\r\n        field.filename = parse.filename;\r\n        ifBlock(type, function parseGroup_block(token) {\r\n            switch (token) {\r\n\r\n                case \"option\":\r\n                    parseOption(type, token);\r\n                    skip(\";\");\r\n                    break;\r\n\r\n                case \"required\":\r\n                case \"repeated\":\r\n                    parseField(type, token);\r\n                    break;\r\n\r\n                case \"optional\":\r\n                    /* istanbul ignore if */\r\n                    if (isProto3) {\r\n                        parseField(type, \"proto3_optional\");\r\n                    } else {\r\n                        parseField(type, \"optional\");\r\n                    }\r\n                    break;\r\n\r\n                case \"message\":\r\n                    parseType(type, token);\r\n                    break;\r\n\r\n                case \"enum\":\r\n                    parseEnum(type, token);\r\n                    break;\r\n\r\n                /* istanbul ignore next */\r\n                default:\r\n                    throw illegal(token); // there are no groups with proto3 semantics\r\n            }\r\n        });\r\n        parent.add(type)\r\n              .add(field);\r\n    }\r\n\r\n    function parseMapField(parent) {\r\n        skip(\"<\");\r\n        var keyType = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (types.mapKey[keyType] === undefined)\r\n            throw illegal(keyType, \"type\");\r\n\r\n        skip(\",\");\r\n        var valueType = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(valueType))\r\n            throw illegal(valueType, \"type\");\r\n\r\n        skip(\">\");\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        skip(\"=\");\r\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\r\n        ifBlock(field, function parseMapField_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(field, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseMapField_line() {\r\n            parseInlineOptions(field);\r\n        });\r\n        parent.add(field);\r\n    }\r\n\r\n    function parseOneOf(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var oneof = new OneOf(applyCase(token));\r\n        ifBlock(oneof, function parseOneOf_block(token) {\r\n            if (token === \"option\") {\r\n                parseOption(oneof, token);\r\n                skip(\";\");\r\n            } else {\r\n                push(token);\r\n                parseField(oneof, \"optional\");\r\n            }\r\n        });\r\n        parent.add(oneof);\r\n    }\r\n\r\n    function parseEnum(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var enm = new Enum(token);\r\n        ifBlock(enm, function parseEnum_block(token) {\r\n          switch(token) {\r\n            case \"option\":\r\n              parseOption(enm, token);\r\n              skip(\";\");\r\n              break;\r\n\r\n            case \"reserved\":\r\n              readRanges(enm.reserved || (enm.reserved = []), true);\r\n              break;\r\n\r\n            default:\r\n              parseEnumValue(enm, token);\r\n          }\r\n        });\r\n        parent.add(enm);\r\n    }\r\n\r\n    function parseEnumValue(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token))\r\n            throw illegal(token, \"name\");\r\n\r\n        skip(\"=\");\r\n        var value = parseId(next(), true),\r\n            dummy = {\r\n                options: undefined\r\n            };\r\n        dummy.setOption = function(name, value) {\r\n            if (this.options === undefined)\r\n                this.options = {};\r\n            this.options[name] = value;\r\n        };\r\n        ifBlock(dummy, function parseEnumValue_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(dummy, token); // skip\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseEnumValue_line() {\r\n            parseInlineOptions(dummy); // skip\r\n        });\r\n        parent.add(token, value, dummy.comment, dummy.options);\r\n    }\r\n\r\n    function parseOption(parent, token) {\r\n        var isCustom = skip(\"(\", true);\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var name = token;\r\n        var option = name;\r\n        var propName;\r\n\r\n        if (isCustom) {\r\n            skip(\")\");\r\n            name = \"(\" + name + \")\";\r\n            option = name;\r\n            token = peek();\r\n            if (fqTypeRefRe.test(token)) {\r\n                propName = token.slice(1); //remove '.' before property name\r\n                name += token;\r\n                next();\r\n            }\r\n        }\r\n        skip(\"=\");\r\n        var optionValue = parseOptionValue(parent, name);\r\n        setParsedOption(parent, option, optionValue, propName);\r\n    }\r\n\r\n    function parseOptionValue(parent, name) {\r\n        // { a: \"foo\" b { c: \"bar\" } }\r\n        if (skip(\"{\", true)) {\r\n            var objectResult = {};\r\n\r\n            while (!skip(\"}\", true)) {\r\n                /* istanbul ignore if */\r\n                if (!nameRe.test(token = next())) {\r\n                    throw illegal(token, \"name\");\r\n                }\r\n                if (token === null) {\r\n                  throw illegal(token, \"end of input\");\r\n                }\r\n\r\n                var value;\r\n                var propName = token;\r\n\r\n                skip(\":\", true);\r\n\r\n                if (peek() === \"{\")\r\n                    value = parseOptionValue(parent, name + \".\" + token);\r\n                else if (peek() === \"[\") {\r\n                    // option (my_option) = {\r\n                    //     repeated_value: [ \"foo\", \"bar\" ]\r\n                    // };\r\n                    value = [];\r\n                    var lastValue;\r\n                    if (skip(\"[\", true)) {\r\n                        do {\r\n                            lastValue = readValue(true);\r\n                            value.push(lastValue);\r\n                        } while (skip(\",\", true));\r\n                        skip(\"]\");\r\n                        if (typeof lastValue !== \"undefined\") {\r\n                            setOption(parent, name + \".\" + token, lastValue);\r\n                        }\r\n                    }\r\n                } else {\r\n                    value = readValue(true);\r\n                    setOption(parent, name + \".\" + token, value);\r\n                }\r\n\r\n                var prevValue = objectResult[propName];\r\n\r\n                if (prevValue)\r\n                    value = [].concat(prevValue).concat(value);\r\n\r\n                objectResult[propName] = value;\r\n\r\n                // Semicolons and commas can be optional\r\n                skip(\",\", true);\r\n                skip(\";\", true);\r\n            }\r\n\r\n            return objectResult;\r\n        }\r\n\r\n        var simpleValue = readValue(true);\r\n        setOption(parent, name, simpleValue);\r\n        return simpleValue;\r\n        // Does not enforce a delimiter to be universal\r\n    }\r\n\r\n    function setOption(parent, name, value) {\r\n        if (parent.setOption)\r\n            parent.setOption(name, value);\r\n    }\r\n\r\n    function setParsedOption(parent, name, value, propName) {\r\n        if (parent.setParsedOption)\r\n            parent.setParsedOption(name, value, propName);\r\n    }\r\n\r\n    function parseInlineOptions(parent) {\r\n        if (skip(\"[\", true)) {\r\n            do {\r\n                parseOption(parent, \"option\");\r\n            } while (skip(\",\", true));\r\n            skip(\"]\");\r\n        }\r\n        return parent;\r\n    }\r\n\r\n    function parseService(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"service name\");\r\n\r\n        var service = new Service(token);\r\n        ifBlock(service, function parseService_block(token) {\r\n            if (parseCommon(service, token))\r\n                return;\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"rpc\")\r\n                parseMethod(service, token);\r\n            else\r\n                throw illegal(token);\r\n        });\r\n        parent.add(service);\r\n    }\r\n\r\n    function parseMethod(parent, token) {\r\n        // Get the comment of the preceding line now (if one exists) in case the\r\n        // method is defined across multiple lines.\r\n        var commentText = cmnt();\r\n\r\n        var type = token;\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var name = token,\r\n            requestType, requestStream,\r\n            responseType, responseStream;\r\n\r\n        skip(\"(\");\r\n        if (skip(\"stream\", true))\r\n            requestStream = true;\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token);\r\n\r\n        requestType = token;\r\n        skip(\")\"); skip(\"returns\"); skip(\"(\");\r\n        if (skip(\"stream\", true))\r\n            responseStream = true;\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token);\r\n\r\n        responseType = token;\r\n        skip(\")\");\r\n\r\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\r\n        method.comment = commentText;\r\n        ifBlock(method, function parseMethod_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(method, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        });\r\n        parent.add(method);\r\n    }\r\n\r\n    function parseExtension(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token, \"reference\");\r\n\r\n        var reference = token;\r\n        ifBlock(null, function parseExtension_block(token) {\r\n            switch (token) {\r\n\r\n                case \"required\":\r\n                case \"repeated\":\r\n                    parseField(parent, token, reference);\r\n                    break;\r\n\r\n                case \"optional\":\r\n                    /* istanbul ignore if */\r\n                    if (isProto3) {\r\n                        parseField(parent, \"proto3_optional\", reference);\r\n                    } else {\r\n                        parseField(parent, \"optional\", reference);\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    /* istanbul ignore if */\r\n                    if (!isProto3 || !typeRefRe.test(token))\r\n                        throw illegal(token);\r\n                    push(token);\r\n                    parseField(parent, \"optional\", reference);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    var token;\r\n    while ((token = next()) !== null) {\r\n        switch (token) {\r\n\r\n            case \"package\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parsePackage();\r\n                break;\r\n\r\n            case \"import\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parseImport();\r\n                break;\r\n\r\n            case \"syntax\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parseSyntax();\r\n                break;\r\n\r\n            case \"option\":\r\n\r\n                parseOption(ptr, token);\r\n                skip(\";\");\r\n                break;\r\n\r\n            default:\r\n\r\n                /* istanbul ignore else */\r\n                if (parseCommon(ptr, token)) {\r\n                    head = false;\r\n                    continue;\r\n                }\r\n\r\n                /* istanbul ignore next */\r\n                throw illegal(token);\r\n        }\r\n    }\r\n\r\n    parse.filename = null;\r\n    return {\r\n        \"package\"     : pkg,\r\n        \"imports\"     : imports,\r\n         weakImports  : weakImports,\r\n         syntax       : syntax,\r\n         root         : root\r\n    };\r\n}\r\n\r\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @name parse\r\n * @function\r\n * @param {string} source Source contents\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n * @variation 2\r\n */\r\n","import \"@dxos/node-std/globals\";\n\n// inject-globals:@inject-globals\nimport {\n  global,\n  Buffer,\n  process\n} from \"@dxos/node-std/inject-globals\";\n\n// packages/common/codec-protobuf/src/buffer-patch.ts\nimport { arrayToBuffer } from \"@dxos/util\";\nvar patchBufferCodec = (codec) => ({\n  encode: (x) => arrayToBuffer(codec.encode(x)),\n  decode: codec.decode.bind(codec)\n});\n\n// packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\nimport * as pb from \"protobufjs\";\nimport { invariant } from \"@dxos/invariant\";\n\n// packages/common/codec-protobuf/src/precompiled-mapping/codegen.ts\nvar Ref = Symbol(\"Ref\");\nvar ref = (value) => ({\n  [Ref]: true,\n  value\n});\nvar isRef = (value) => value[Ref] === true;\nvar codegen = (name, args, gen, ctx = {}) => {\n  const newCtx = {\n    ...ctx\n  };\n  let nextAnnon = 1;\n  let buf = \"\";\n  gen((parts, ...args2) => {\n    const preprocessArg = (arg) => {\n      if (isRef(arg)) {\n        const name2 = `anon${nextAnnon++}`;\n        newCtx[name2] = arg.value;\n        return name2;\n      } else {\n        return arg;\n      }\n    };\n    buf += parts.map((s, i) => s + (i < args2.length ? preprocessArg(args2[i]) : \"\")).join(\"\") + \"\\n\";\n  });\n  const code = `return function ${name}(${args.join(\", \")}) {\n${buf}\n}`;\n  return Function(...Object.keys(newCtx), code)(...Object.values(newCtx));\n};\n\n// packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\nvar __dxlog_file = \"/home/runner/work/dxos/dxos/packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\";\nvar createMessageMapper = (type, substitutions) => createMessageMapperCached(type, substitutions, {}).map;\nvar createMessageMapperCached = (type, substitutions, cache) => {\n  if (!cache[type.fullName]) {\n    cache[type.fullName] = {};\n    cache[type.fullName].map = codegen(`${type.name}$map`, [\n      \"obj\",\n      \"extraArgs\"\n    ], (c) => {\n      c`const res = {};`;\n      for (const field of type.fieldsArray) {\n        field.resolve();\n        c`if(obj.${field.name} !== undefined && obj.${field.name} !== null) {`;\n        {\n          const genMapScalar = (value) => {\n            const substitution = field.resolvedType && substitutions[field.resolvedType.fullName.slice(1)];\n            if (substitution) {\n              const context = {\n                messageName: type.fullName.slice(1),\n                fieldName: field.name\n              };\n              c`${ref(substitution)}(${value}, ${ref(context)}, ...extraArgs)`;\n            } else if (field.resolvedType && field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`${ref(mapper)}.map(${value}, extraArgs)`;\n            } else {\n              c`${value}`;\n            }\n          };\n          if (field.repeated) {\n            c`res.${field.name} = obj.${field.name}.map(item => `;\n            genMapScalar(\"item\");\n            c`);`;\n          } else if (field.map) {\n            invariant(field instanceof pb.MapField, void 0, {\n              F: __dxlog_file,\n              L: 52,\n              S: void 0,\n              A: [\n                \"field instanceof pb.MapField\",\n                \"\"\n              ]\n            });\n            c`res.${field.name} = {};`;\n            c`for(const key of Object.keys(obj.${field.name})) {`;\n            {\n              c`res.${field.name}[key] = `;\n              genMapScalar(`obj.${field.name}[key]`);\n              c`;`;\n            }\n            c`}`;\n          } else {\n            c`res.${field.name} = `;\n            genMapScalar(`obj.${field.name}`);\n            c`;`;\n          }\n        }\n        c`}`;\n        if (!field.getOption(\"proto3_optional\") && !field.repeated && !field.map && !field.partOf) {\n          c`else {`;\n          {\n            if (field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`res.${field.name} = ${ref(mapper)}.map({}, extraArgs);`;\n            } else if (field.resolvedType instanceof pb.Enum) {\n              `res.${field.name} = 0;`;\n            } else {\n              c`res.${field.name} = ${getDefaultValue(field.type)};`;\n            }\n          }\n          c`}`;\n        }\n      }\n      c`return res;`;\n    });\n  }\n  return cache[type.fullName];\n};\nvar getDefaultValue = (type) => {\n  switch (type) {\n    case \"double\":\n    case \"float\":\n    case \"int32\":\n    case \"sfixed32\":\n    case \"uint32\":\n    case \"sint32\":\n    case \"fixed32\":\n      return \"0\";\n    case \"sint64\":\n    case \"int64\":\n    case \"uint64\":\n    case \"fixed64\":\n    case \"sfixed64\":\n      return '\"0\"';\n    case \"bool\":\n      return \"false\";\n    case \"string\":\n      return '\"\"';\n    case \"bytes\":\n      return \"new Uint8Array()\";\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n};\n\n// packages/common/codec-protobuf/src/codec.ts\nvar OBJECT_CONVERSION_OPTIONS = {\n  // Represent long integers as strings.\n  longs: String,\n  // Will set empty repeated fields to [] instead of undefined.\n  arrays: true\n};\nvar ProtoCodec = class {\n  constructor(_type, _mapping, _schema) {\n    this._type = _type;\n    this._mapping = _mapping;\n    this._schema = _schema;\n    this._encodeMapper = createMessageMapper(this._type, this._mapping.encode);\n    this._decodeMapper = createMessageMapper(this._type, this._mapping.decode);\n  }\n  /**\n  * Underlying protobuf.js type descriptor.\n  */\n  get protoType() {\n    return this._type;\n  }\n  get substitutionMappings() {\n    return this._mapping;\n  }\n  /**\n  * Reference to the protobuf schema this codec was created from.\n  */\n  get schema() {\n    return this._schema;\n  }\n  encode(value, options = {}) {\n    const sub = this._encodeMapper(value, [\n      this._schema,\n      options\n    ]);\n    return this._type.encode(sub).finish();\n  }\n  decode(data, options = {}) {\n    const obj = this._type.toObject(this._type.decode(data), OBJECT_CONVERSION_OPTIONS);\n    return this._decodeMapper(obj, [\n      this._schema,\n      options\n    ]);\n  }\n  encodeAsAny(value, options = {}) {\n    return {\n      \"@type\": \"google.protobuf.Any\",\n      type_url: this._type.fullName.slice(1),\n      value: this.encode(value, options)\n    };\n  }\n  fromObject(obj) {\n    return this._decodeMapper(this._type.fromObject(obj).toJSON(), [\n      this._schema\n    ]);\n  }\n  /**\n  * Dynamically add new definitions to this codec. Mutates the underlying schema.\n  */\n  addJson(schema) {\n    this._schema.addJson(schema);\n  }\n};\n\n// packages/common/codec-protobuf/src/encoding.ts\nimport * as protobuf from \"protobufjs\";\nvar encodeProtobuf = (root) => root.toJSON();\nvar decodeProtobuf = (struct) => protobuf.Root.fromJSON(struct);\n\n// packages/common/codec-protobuf/src/mapping.ts\nimport protobufjs from \"protobufjs\";\nimport { invariant as invariant2 } from \"@dxos/invariant\";\nvar __dxlog_file2 = \"/home/runner/work/dxos/dxos/packages/common/codec-protobuf/src/mapping.ts\";\nvar createMappingDescriptors = (substitutions) => {\n  const encode = {};\n  const decode = {};\n  for (const type of Object.keys(substitutions)) {\n    encode[type] = substitutions[type].encode;\n    decode[type] = substitutions[type].decode;\n  }\n  return {\n    encode,\n    decode\n  };\n};\nvar mapMessage = async (type, mapper, obj) => {\n  const res = {};\n  for (const field of type.fieldsArray) {\n    if (!(field.name in obj)) {\n      continue;\n    }\n    res[field.name] = await mapField(field, mapper, obj[field.name]);\n  }\n  return res;\n};\nvar mapField = async (field, mapper, value) => {\n  if (!field.required && (value === null || value === void 0)) {\n    return value;\n  } else if (field.repeated) {\n    return await Promise.all(value.map((value2) => mapScalarField(field, mapper, value2)));\n  } else if (field.map) {\n    invariant2(field instanceof protobufjs.MapField, void 0, {\n      F: __dxlog_file2,\n      L: 62,\n      S: void 0,\n      A: [\n        \"field instanceof protobufjs.MapField\",\n        \"\"\n      ]\n    });\n    return await asyncObjectMap((value2) => mapScalarField(field, mapper, value2), value);\n  } else {\n    return mapScalarField(field, mapper, value);\n  }\n};\nvar mapScalarField = async (field, mapper, value) => {\n  if (!field.resolved) {\n    field.resolve();\n  }\n  const typeName = field.resolvedType?.fullName.slice(1);\n  if (typeName) {\n    return await mapper(value, typeName);\n  }\n  if (field.resolvedType && field.resolvedType instanceof protobufjs.Type) {\n    return await mapMessage(field.resolvedType, mapper, value);\n  }\n  return value;\n};\nvar asyncObjectMap = async (map, record) => {\n  const res = {};\n  await Promise.all(Object.entries(record).map(async ([key, value]) => {\n    res[key] = await map(value, key);\n  }));\n  return res;\n};\n\n// packages/common/codec-protobuf/src/sanitizer.ts\nimport { Enum as Enum2, Type as Type2 } from \"protobufjs\";\nvar sanitize = (type, value, path, context) => {\n  if (!value) {\n    return;\n  }\n  for (const key of Object.keys(value)) {\n    if (!type.fields[key]) {\n      continue;\n    }\n    const field = type.fields[key];\n    if (field.repeated) {\n      continue;\n    }\n    field.resolve();\n    if (!field.resolvedType) {\n      continue;\n    }\n    if (field.resolvedType instanceof Type2) {\n      sanitize(field.resolvedType, value[key], `${path}.${key}`, context);\n    } else if (field.resolvedType instanceof Enum2) {\n      value[key] = sanitizeEnum(field.resolvedType, value[key], `${path}.${key}`, context);\n    }\n  }\n};\nvar sanitizeEnum = (type, value, path, context) => {\n  if (type.valuesById[value]) {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    const normalizedValue = value.toLowerCase();\n    for (const [name, tag] of Object.entries(type.values)) {\n      if (name.toLowerCase() === normalizedValue) {\n        return tag;\n      }\n    }\n  }\n  context.errors.push(`Invalid enum value: value=${JSON.stringify(value)} enum=${type.fullName} path=${path}`);\n  return value;\n};\n\n// packages/common/codec-protobuf/src/schema.ts\nimport merge from \"lodash.merge\";\nimport protobufjs2, { Root as Root2 } from \"protobufjs\";\n\n// packages/common/codec-protobuf/src/service.ts\nimport { invariant as invariant4 } from \"@dxos/invariant\";\nimport { getAsyncValue } from \"@dxos/util\";\n\n// packages/common/codec-protobuf/src/stream.ts\nimport { Context } from \"@dxos/context\";\nimport { invariant as invariant3 } from \"@dxos/invariant\";\nimport { log } from \"@dxos/log\";\nimport { throwUnhandledError } from \"@dxos/util\";\nvar __dxlog_file3 = \"/home/runner/work/dxos/dxos/packages/common/codec-protobuf/src/stream.ts\";\nvar Stream = class _Stream {\n  constructor(producer) {\n    this._messageHandler = void 0;\n    this._closeHandler = void 0;\n    this._readyHandler = void 0;\n    this._isClosed = false;\n    this._closeError = void 0;\n    this._producerCleanup = void 0;\n    this._isReady = false;\n    /**\n    * Buffer messages before subscription. Set to null when buffer is no longer needed.\n    */\n    this._buffer = [];\n    this._readyPromise = new Promise((resolve) => {\n      this._resolveReadyPromise = resolve;\n    });\n    this._ctx = new Context({\n      onError: (err) => {\n        if (this._isClosed) {\n          return;\n        }\n        this._isClosed = true;\n        this._closeError = err;\n        this._producerCleanup?.(err);\n        this._closeHandler?.(err);\n        void this._ctx.dispose();\n      }\n    });\n    this._ctx.onDispose(() => this.close());\n    try {\n      const producerCleanup = producer({\n        ctx: this._ctx,\n        ready: () => {\n          this._markAsReady();\n        },\n        next: (msg) => {\n          if (this._isClosed) {\n            log(\"Stream is closed, dropping message.\", void 0, {\n              F: __dxlog_file3,\n              L: 207,\n              S: this,\n              C: (f, a) => f(...a)\n            });\n            return;\n          }\n          this._markAsReady();\n          if (this._messageHandler) {\n            try {\n              this._messageHandler(msg);\n            } catch (err) {\n              throwUnhandledError(err);\n            }\n          } else {\n            invariant3(this._buffer, void 0, {\n              F: __dxlog_file3,\n              L: 221,\n              S: this,\n              A: [\n                \"this._buffer\",\n                \"\"\n              ]\n            });\n            this._buffer.push(msg);\n          }\n        },\n        close: (err) => {\n          if (this._isClosed) {\n            return;\n          }\n          this._isClosed = true;\n          this._closeError = err;\n          this._producerCleanup?.(err);\n          try {\n            this._closeHandler?.(err);\n          } catch (err2) {\n            throwUnhandledError(err2);\n          }\n          void this._ctx.dispose();\n        }\n      });\n      if (producerCleanup) {\n        this._producerCleanup = producerCleanup;\n      }\n    } catch (err) {\n      this._ctx.raise(err);\n    }\n  }\n  /**\n  * Consumes the entire stream to the end until it closes and returns a promise with the resulting items.\n  */\n  static consume(stream) {\n    return new Promise((resolve) => {\n      const items = [];\n      stream.onReady(() => {\n        items.push({\n          ready: true\n        });\n      });\n      stream.subscribe((data) => {\n        items.push({\n          data\n        });\n      }, (error) => {\n        if (error) {\n          items.push({\n            closed: true,\n            error\n          });\n        } else {\n          items.push({\n            closed: true\n          });\n        }\n        resolve(items);\n      });\n    });\n  }\n  static async consumeData(stream) {\n    const entries = await _Stream.consume(stream);\n    const res = [];\n    for (const entry of entries) {\n      if (\"data\" in entry) {\n        res.push(entry.data);\n      } else if (\"closed\" in entry && entry.closed === true) {\n        if (entry.error) {\n          throw entry.error;\n        } else {\n          break;\n        }\n      }\n    }\n    return res;\n  }\n  static async first(stream) {\n    return new Promise((resolve, reject) => {\n      stream.subscribe((data) => {\n        resolve(data);\n        void stream.close();\n      }, (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(void 0);\n        }\n      });\n    });\n  }\n  /**\n  * Maps all data coming through the stream.\n  */\n  static map(source, map) {\n    return new _Stream(({ ready, next, close }) => {\n      source.onReady(ready);\n      source.subscribe((data) => next(map(data)), close);\n      return () => source.close();\n    });\n  }\n  /**\n  * Converts Promise<Stream<T>> to Stream<T>.\n  */\n  static unwrapPromise(streamPromise) {\n    if (streamPromise instanceof _Stream) {\n      return streamPromise;\n    }\n    return new _Stream(({ ready, next, close }) => {\n      streamPromise.then((stream) => {\n        stream.onReady(ready);\n        stream.subscribe(next, close);\n      }, (err) => {\n        close(err);\n      });\n      return () => {\n        streamPromise.then(\n          (stream) => stream.close(),\n          // eslint-disable-next-line n/handle-callback-err\n          (err) => {\n          }\n        );\n      };\n    });\n  }\n  _markAsReady() {\n    if (!this._isReady) {\n      this._isReady = true;\n      this._readyHandler?.();\n      this._resolveReadyPromise();\n    }\n  }\n  // TODO(burdon): Can this be cancelled?\n  subscribe(onMessage, onClose) {\n    invariant3(!this._messageHandler, \"Stream is already subscribed to.\", {\n      F: __dxlog_file3,\n      L: 262,\n      S: this,\n      A: [\n        \"!this._messageHandler\",\n        \"'Stream is already subscribed to.'\"\n      ]\n    });\n    invariant3(!this._closeHandler, \"Stream is already subscribed to.\", {\n      F: __dxlog_file3,\n      L: 263,\n      S: this,\n      A: [\n        \"!this._closeHandler\",\n        \"'Stream is already subscribed to.'\"\n      ]\n    });\n    invariant3(this._buffer, void 0, {\n      F: __dxlog_file3,\n      L: 264,\n      S: this,\n      A: [\n        \"this._buffer\",\n        \"\"\n      ]\n    });\n    for (const message of this._buffer) {\n      try {\n        onMessage(message);\n      } catch (err) {\n        throwUnhandledError(err);\n      }\n    }\n    this._buffer = null;\n    if (this._isClosed) {\n      onClose?.(this._closeError);\n      return;\n    }\n    this._messageHandler = onMessage;\n    this._closeHandler = onClose;\n  }\n  /**\n  * Resolves when stream is ready.\n  */\n  // TODO(burdon): Gather all callbacks into single observer.\n  waitUntilReady() {\n    return this._readyPromise;\n  }\n  /**\n  * Registers a callback to be called when stream is ready.\n  */\n  onReady(onReady) {\n    invariant3(!this._readyHandler, \"Stream already has a handler for the ready event.\", {\n      F: __dxlog_file3,\n      L: 299,\n      S: this,\n      A: [\n        \"!this._readyHandler\",\n        \"'Stream already has a handler for the ready event.'\"\n      ]\n    });\n    this._readyHandler = onReady;\n    if (this._isReady) {\n      onReady();\n    }\n  }\n  /**\n  * Close the stream and dispose of any resources.\n  */\n  async close() {\n    if (this._isClosed) {\n      return;\n    }\n    this._isClosed = true;\n    this._producerCleanup?.();\n    this._closeHandler?.(void 0);\n    await this._ctx.dispose();\n    this._messageHandler = void 0;\n    this._closeHandler = void 0;\n    this._producerCleanup = void 0;\n  }\n};\n\n// packages/common/codec-protobuf/src/service.ts\nvar __dxlog_file4 = \"/home/runner/work/dxos/dxos/packages/common/codec-protobuf/src/service.ts\";\nvar ServiceDescriptor = class {\n  // prettier-ignore\n  constructor(_service, _schema) {\n    this._service = _service;\n    this._schema = _schema;\n  }\n  get serviceProto() {\n    return this._service;\n  }\n  get name() {\n    return this._service.fullName.slice(1);\n  }\n  createClient(backend, encodingOptions) {\n    return new Service(backend, this._service, this._schema, encodingOptions);\n  }\n  createServer(handlers, encodingOptions) {\n    return new ServiceHandler(this._service, this._schema, handlers, encodingOptions);\n  }\n};\nvar Service = class {\n  constructor(backend, service, schema, encodingOptions) {\n    for (const method of service.methodsArray) {\n      method.resolve();\n      invariant4(method.resolvedRequestType, void 0, {\n        F: __dxlog_file4,\n        L: 59,\n        S: this,\n        A: [\n          \"method.resolvedRequestType\",\n          \"\"\n        ]\n      });\n      invariant4(method.resolvedResponseType, void 0, {\n        F: __dxlog_file4,\n        L: 60,\n        S: this,\n        A: [\n          \"method.resolvedResponseType\",\n          \"\"\n        ]\n      });\n      invariant4(!method.requestStream, \"Streaming RPC requests are not supported.\", {\n        F: __dxlog_file4,\n        L: 61,\n        S: this,\n        A: [\n          \"!method.requestStream\",\n          \"'Streaming RPC requests are not supported.'\"\n        ]\n      });\n      const requestCodec = schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n      const responseCodec = schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n      const methodName = mapRpcMethodName(method.name);\n      if (method.responseStream) {\n        this[methodName] = (request, requestOptions) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const stream = backend.callStream(method.name, {\n            value: encoded,\n            type_url: method.resolvedRequestType.fullName\n          }, requestOptions);\n          return Stream.map(stream, (data) => responseCodec.decode(data.value, encodingOptions));\n        };\n      } else {\n        this[methodName] = async (request, requestOptions) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const response = await backend.call(method.name, {\n            value: encoded,\n            type_url: method.resolvedRequestType.fullName\n          }, requestOptions);\n          return responseCodec.decode(response.value, encodingOptions);\n        };\n      }\n      Object.defineProperty(this[methodName], \"name\", {\n        value: methodName\n      });\n    }\n  }\n};\nvar ServiceHandler = class {\n  constructor(_serviceDefinition, _schema, _serviceProvider, _encodingOptions) {\n    this._serviceDefinition = _serviceDefinition;\n    this._schema = _schema;\n    this._serviceProvider = _serviceProvider;\n    this._encodingOptions = _encodingOptions;\n  }\n  /**\n  * Request/response method call.\n  */\n  async call(methodName, request, options) {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    invariant4(!method.requestStream, \"Invalid RPC method call: request streaming mismatch.\", {\n      F: __dxlog_file4,\n      L: 120,\n      S: this,\n      A: [\n        \"!method.requestStream\",\n        \"'Invalid RPC method call: request streaming mismatch.'\"\n      ]\n    });\n    invariant4(!method.responseStream, `Invalid RPC method call: response streaming mismatch. ${methodName}`, {\n      F: __dxlog_file4,\n      L: 121,\n      S: this,\n      A: [\n        \"!method.responseStream\",\n        \"`Invalid RPC method call: response streaming mismatch. ${methodName}`\"\n      ]\n    });\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handler = await this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);\n    const response = await handler(requestDecoded, options);\n    const responseEncoded = responseCodec.encode(response, this._encodingOptions);\n    return {\n      value: responseEncoded,\n      type_url: method.resolvedResponseType.fullName\n    };\n  }\n  /**\n  * Streaming method call.\n  */\n  callStream(methodName, request, options) {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    invariant4(!method.requestStream, \"Invalid RPC method call: request streaming mismatch.\", {\n      F: __dxlog_file4,\n      L: 141,\n      S: this,\n      A: [\n        \"!method.requestStream\",\n        \"'Invalid RPC method call: request streaming mismatch.'\"\n      ]\n    });\n    invariant4(method.responseStream, `Invalid RPC method call: response streaming mismatch., ${methodName}`, {\n      F: __dxlog_file4,\n      L: 142,\n      S: this,\n      A: [\n        \"method.responseStream\",\n        \"`Invalid RPC method call: response streaming mismatch., ${methodName}`\"\n      ]\n    });\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handlerPromise = this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);\n    const responseStream = Stream.unwrapPromise(handlerPromise.then((handler) => handler(requestDecoded, options)));\n    return Stream.map(responseStream, (data) => ({\n      value: responseCodec.encode(data, this._encodingOptions),\n      type_url: method.resolvedResponseType.fullName\n    }));\n  }\n  async _getHandler(method) {\n    const service = await getAsyncValue(this._serviceProvider);\n    const handler = service[method];\n    invariant4(handler, `Handler is missing: ${method}`, {\n      F: __dxlog_file4,\n      L: 163,\n      S: this,\n      A: [\n        \"handler\",\n        \"`Handler is missing: ${method}`\"\n      ]\n    });\n    return handler.bind(service);\n  }\n  _getMethodInfo(methodName) {\n    const method = this._serviceDefinition.methods[methodName];\n    invariant4(!!method, `Method not found: ${methodName}`, {\n      F: __dxlog_file4,\n      L: 169,\n      S: this,\n      A: [\n        \"!!method\",\n        \"`Method not found: ${methodName}`\"\n      ]\n    });\n    method.resolve();\n    invariant4(method.resolvedRequestType, void 0, {\n      F: __dxlog_file4,\n      L: 172,\n      S: this,\n      A: [\n        \"method.resolvedRequestType\",\n        \"\"\n      ]\n    });\n    invariant4(method.resolvedResponseType, void 0, {\n      F: __dxlog_file4,\n      L: 173,\n      S: this,\n      A: [\n        \"method.resolvedResponseType\",\n        \"\"\n      ]\n    });\n    const requestCodec = this._schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n    const responseCodec = this._schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n    return {\n      method,\n      requestCodec,\n      responseCodec\n    };\n  }\n};\nvar mapRpcMethodName = (name) => name[0].toLocaleLowerCase() + name.substring(1);\n\n// packages/common/codec-protobuf/src/schema.ts\nvar Schema = class _Schema {\n  static fromJson(schema, substitutions = {}) {\n    const root = protobufjs2.Root.fromJSON(schema);\n    return new _Schema(root, substitutions);\n  }\n  // prettier-ignore\n  constructor(_typesRoot, substitutions) {\n    this._typesRoot = _typesRoot;\n    this._codecCache = /* @__PURE__ */ new Map();\n    this._mapping = createMappingDescriptors(substitutions);\n  }\n  getCodecForType(typeName) {\n    if (typeof typeName !== \"string\") {\n      throw new TypeError(\"Expected `typeName` argument to be a string\");\n    }\n    let codec = this._codecCache.get(typeName);\n    if (codec) {\n      return codec;\n    }\n    if (codec === null) {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n    const type = this._typesRoot.lookupType(typeName);\n    codec = new ProtoCodec(type, this._mapping, this);\n    this._codecCache.set(typeName, codec);\n    return codec;\n  }\n  hasType(typeName) {\n    if (typeName === \"\") {\n      return false;\n    }\n    if (this._codecCache.has(typeName)) {\n      return true;\n    }\n    try {\n      this.tryGetCodecForType(typeName);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  tryGetCodecForType(typeName) {\n    if (typeName === \"\") {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n    if (typeof typeName !== \"string\") {\n      throw new TypeError(\"Expected `typeName` argument to be a string\");\n    }\n    let codec = this._codecCache.get(typeName);\n    if (codec) {\n      return codec;\n    }\n    if (codec === null) {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n    const type = this._typesRoot.lookupType(typeName);\n    codec = new ProtoCodec(type, this._mapping, this);\n    this._codecCache.set(typeName, codec);\n    return codec;\n  }\n  getService(name) {\n    if (typeof name !== \"string\") {\n      throw new TypeError(\"Expected `name` argument to be a string\");\n    }\n    const service = this._typesRoot.lookupService(name);\n    return new ServiceDescriptor(service, this);\n  }\n  /**\n  * Dynamically add new definitions to this schema.\n  */\n  addJson(schema) {\n    if (!schema.nested) {\n      throw new Error(\"Invalid schema: missing nested object\");\n    }\n    this._typesRoot = Root2.fromJSON(merge(this._typesRoot.toJSON(), schema));\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/struct.ts\nvar encodeStructValue = (structValue, visitedObjects) => {\n  const valueType = typeof structValue;\n  switch (valueType) {\n    case \"undefined\": {\n      return {\n        nullValue: 0\n      };\n    }\n    case \"number\": {\n      return {\n        numberValue: structValue\n      };\n    }\n    case \"string\": {\n      return {\n        stringValue: structValue\n      };\n    }\n    case \"boolean\": {\n      return {\n        boolValue: structValue\n      };\n    }\n    case \"object\": {\n      if (structValue === null || visitedObjects.has(structValue)) {\n        return {\n          nullValue: 0\n        };\n      }\n      try {\n        if (Array.isArray(structValue)) {\n          return {\n            listValue: {\n              values: structValue.map((value) => encodeStructValue(value, visitedObjects))\n            }\n          };\n        }\n        return {\n          structValue: encodeStruct(structValue, visitedObjects)\n        };\n      } finally {\n        visitedObjects.delete(structValue);\n      }\n    }\n    default: {\n      return {\n        nullValue: 0\n      };\n    }\n  }\n};\nvar encodeStruct = (struct, visitedObjects = /* @__PURE__ */ new WeakSet()) => ({\n  fields: Object.fromEntries(Object.entries(struct).map(([key, value]) => [\n    key,\n    encodeStructValue(value, visitedObjects)\n  ]))\n});\nvar decodeStructValue = (structValue) => {\n  const [key, v] = Object.entries(structValue)[0];\n  switch (key) {\n    case \"nullValue\": {\n      return null;\n    }\n    case \"numberValue\": {\n      return v;\n    }\n    case \"stringValue\": {\n      return v;\n    }\n    case \"boolValue\": {\n      return v;\n    }\n    case \"structValue\": {\n      return decodeStruct(v);\n    }\n    case \"listValue\": {\n      return v.values.map(decodeStructValue);\n    }\n    default:\n      throw new Error(`Unsupported type: ${key}`);\n  }\n};\nvar decodeStruct = (struct) => Object.fromEntries(Object.entries(struct.fields || {}).map(([key, value]) => [\n  key,\n  decodeStructValue(value)\n]));\nvar structSubstitutions = {\n  \"google.protobuf.Struct\": {\n    encode: (value) => encodeStruct(value),\n    decode: (value) => decodeStruct(value)\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/any.ts\nvar anySubstitutions = {\n  \"google.protobuf.Any\": {\n    encode: (value, context, schema, options) => {\n      const field = schema.getCodecForType(context.messageName).protoType.fields[context.fieldName];\n      if (options.preserveAny || field.getOption(\"preserve_any\")) {\n        if (value[\"@type\"] && value[\"@type\"] !== \"google.protobuf.Any\") {\n          throw new Error(\"Can only encode google.protobuf.Any with @type set to google.protobuf.Any in preserveAny mode.\");\n        }\n        return value;\n      }\n      if (typeof value[\"@type\"] !== \"string\") {\n        throw new Error(\"Cannot encode google.protobuf.Any without @type string field\");\n      }\n      if (value[\"@type\"] === \"google.protobuf.Any\") {\n        return value;\n      }\n      if (value[\"@type\"] === \"google.protobuf.Struct\") {\n        const codec2 = schema.tryGetCodecForType(value[\"@type\"]);\n        return codec2.encodeAsAny(structSubstitutions[\"google.protobuf.Struct\"].encode(value));\n      }\n      const codec = schema.tryGetCodecForType(value[\"@type\"]);\n      return codec.encodeAsAny(value);\n    },\n    decode: (value, context, schema, options) => {\n      const field = schema.getCodecForType(context.messageName).protoType.fields[context.fieldName];\n      if (options.preserveAny || field.getOption(\"preserve_any\")) {\n        return {\n          \"@type\": \"google.protobuf.Any\",\n          type_url: value.type_url ?? \"\",\n          value: value.value ?? new Uint8Array()\n        };\n      }\n      if (!schema.hasType(value.type_url)) {\n        return {\n          \"@type\": \"google.protobuf.Any\",\n          ...value\n        };\n      }\n      const codec = schema.tryGetCodecForType(value.type_url);\n      let data = codec.decode(value.value);\n      if (value.type_url === \"google.protobuf.Struct\") {\n        data = structSubstitutions[\"google.protobuf.Struct\"].decode(data);\n      }\n      return {\n        ...data,\n        \"@type\": value.type_url\n      };\n    }\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/timestamp.ts\nvar timestampSubstitutions = {\n  \"google.protobuf.Timestamp\": {\n    encode: (value) => {\n      const unixMilliseconds = value.getTime();\n      return {\n        seconds: Math.floor(unixMilliseconds / 1e3).toString(),\n        nanos: unixMilliseconds % 1e3 * 1e6\n      };\n    },\n    decode: (value) => new Date(parseInt(value.seconds ?? \"0\") * 1e3 + (value.nanos ?? 0) / 1e6)\n  }\n};\n\n// packages/common/codec-protobuf/src/compression.ts\nimport { compress, decompress } from \"compress-json\";\nvar compressSchema = (data) => compress(data);\nvar decompressSchema = (data) => decompress(data);\n\n// packages/common/codec-protobuf/src/util.ts\nimport { Trigger } from \"@dxos/async\";\nvar getFirstStreamValue = async (stream, { timeout } = {}) => {\n  try {\n    const trigger = new Trigger();\n    stream.subscribe((value) => trigger.wake(value));\n    return await trigger.wait({\n      timeout\n    });\n  } finally {\n    await stream.close();\n  }\n};\nexport {\n  OBJECT_CONVERSION_OPTIONS,\n  ProtoCodec,\n  Schema,\n  Service,\n  ServiceDescriptor,\n  ServiceHandler,\n  Stream,\n  anySubstitutions,\n  compressSchema,\n  createMappingDescriptors,\n  decodeProtobuf,\n  decompressSchema,\n  encodeProtobuf,\n  getFirstStreamValue,\n  mapMessage,\n  patchBufferCodec,\n  sanitize,\n  structSubstitutions,\n  timestampSubstitutions\n};\n//# sourceMappingURL=index.mjs.map\n","import \"@dxos/node-std/globals\";\n\n// inject-globals:@inject-globals\nimport {\n  global,\n  Buffer,\n  process\n} from \"@dxos/node-std/inject-globals\";\n\n// packages/common/timeframe/src/timeframe.ts\nimport { inspect } from \"@dxos/node-std/util\";\nimport { equalsSymbol } from \"@dxos/debug\";\nvar Timeframe = class _Timeframe {\n  constructor(frames = []) {\n    this._frames = /* @__PURE__ */ new Map();\n    for (const [key, seq] of frames) {\n      this.set(key, seq);\n    }\n  }\n  toJSON() {\n    return this.frames().reduce((frames, [key, seq]) => {\n      frames[key.truncate()] = seq;\n      return frames;\n    }, {});\n  }\n  toString() {\n    return `(${this.frames().map(([key, seq]) => `${key.truncate()}[${seq}]`).join(\", \")})`;\n  }\n  equals(object) {\n    return this.size() === object.size() && this.frames().every(([key, seq]) => object.get(key) === seq);\n  }\n  // TODO(burdon): Rename getFrame.\n  get(key) {\n    return this._frames.get(key.toHex())?.seq;\n  }\n  // TODO(burdon): Rename setFrame.\n  set(key, seq) {\n    const hex = key.toHex();\n    this._frames.set(hex, {\n      key,\n      seq\n    });\n  }\n  // TODO(burdon): Change to getter.\n  frames() {\n    return Array.from(this._frames.values()).map(({ key, seq }) => [\n      key,\n      seq\n    ]);\n  }\n  // TODO(burdon): Change to getter.\n  size() {\n    return this._frames.size;\n  }\n  // TODO(burdon): Change to getter (empty).\n  isEmpty() {\n    return this.size() === 0;\n  }\n  /**\n  * Returns a new timeframe with specified keys removed.\n  * @param keys\n  */\n  withoutKeys(keys) {\n    return new _Timeframe(this.frames().filter(([frameKey]) => keys.every((key) => !key.equals(frameKey))));\n  }\n  map(fn) {\n    return new _Timeframe(this.frames().map(fn));\n  }\n  /**\n  * Returns a total amount of messages represented by this timeframe.\n  */\n  totalMessages() {\n    return Array.from(this._frames.values()).reduce((result, { seq }) => result + seq + 1, 0);\n  }\n  /**\n  * Returns a total amount of messages that are present in this timeframe but are missing in `base`.\n  */\n  newMessages(base) {\n    return Array.from(this._frames.entries()).reduce((result, [hex, { seq }]) => result + Math.max(seq - (base._frames.get(hex)?.seq ?? -1), 0), 0);\n  }\n  /**\n  * Used by NodeJS to get textual representation of this object in `console.log`.\n  */\n  [inspect.custom]() {\n    return `Timeframe${this.toString()}`;\n  }\n  [equalsSymbol](other) {\n    if (!(other instanceof _Timeframe)) {\n      return false;\n    }\n    return this.equals(other);\n  }\n  /**\n  * Merges the values, updating the highest sequence numbers.\n  * @param timeframes\n  */\n  static merge(...timeframes) {\n    const result = new _Timeframe();\n    for (const timeframe of timeframes) {\n      for (const [hex, entry] of timeframe._frames) {\n        const currentEntry = result._frames.get(hex);\n        if (currentEntry === void 0 || entry.seq > currentEntry.seq) {\n          result._frames.set(hex, entry);\n        }\n      }\n    }\n    return result;\n  }\n  /**\n  * Compares two timeframes and returns an array of frames from the first timeframe where the sequence number\n  * is greater than the associated sequence number from the second timeframe.\n  */\n  static dependencies(tf1, tf2) {\n    const result = new _Timeframe();\n    for (const [hex, entry] of tf1._frames) {\n      const otherEntry = tf2._frames.get(hex);\n      if (otherEntry === void 0 || otherEntry.seq < entry.seq) {\n        result._frames.set(hex, entry);\n      }\n    }\n    return result;\n  }\n};\nexport {\n  Timeframe\n};\n//# sourceMappingURL=index.mjs.map\n","//\n// Copyright 2020 DXOS.org\n//\nimport { anySubstitutions, structSubstitutions, timestampSubstitutions } from '@dxos/codec-protobuf';\nimport { PublicKey } from '@dxos/keys';\nimport { Timeframe } from '@dxos/timeframe';\nexport const substitutions = {\n    'dxos.keys.PublicKey': {\n        encode: (value) => ({ data: value.asUint8Array() }),\n        decode: (value) => PublicKey.from(value.data),\n    },\n    // TODO(dmaretskyi): Shouldn't be substituted to PublicKey.\n    'dxos.keys.PrivateKey': {\n        encode: (value) => ({ data: new Uint8Array(value) }),\n        decode: (value) => PublicKey.from(new Uint8Array(value.data)).asBuffer(),\n    },\n    'dxos.echo.timeframe.TimeframeVector': {\n        encode: (timeframe) => ({\n            frames: timeframe.frames().map(([feedKey, seq]) => ({ feedKey: feedKey.asUint8Array(), seq })),\n        }),\n        decode: (vector) => new Timeframe((vector.frames ?? [])\n            .filter((frame) => frame.feedKey != null && frame.seq != null)\n            .map((frame) => [PublicKey.from(frame.feedKey), frame.seq])),\n    },\n};\nexport default {\n    ...anySubstitutions,\n    ...structSubstitutions,\n    ...substitutions,\n    ...timestampSubstitutions,\n};\n//# sourceMappingURL=substitutions.js.map","import { Schema, decompressSchema } from \"@dxos/codec-protobuf\";\nimport substitutions from \"../substitutions\";\nexport const schemaJson = decompressSchema(JSON.parse(\"[[\\\"nested\\\",\\\"a|0\\\",\\\"dxos\\\",\\\"example\\\",\\\"google\\\",\\\"a|2|3|4\\\",\\\"agent\\\",\\\"bot\\\",\\\"client\\\",\\\"config\\\",\\\"devtools\\\",\\\"echo\\\",\\\"error\\\",\\\"gravity\\\",\\\"halo\\\",\\\"iframe\\\",\\\"keys\\\",\\\"mesh\\\",\\\"registry\\\",\\\"rpc\\\",\\\"service\\\",\\\"tracing\\\",\\\"type\\\",\\\"value\\\",\\\"a|6|7|8|9|A|B|C|D|E|F|G|H|I|J|K|L|M|N\\\",\\\"dashboard\\\",\\\"echoproxy\\\",\\\"epoch\\\",\\\"functions\\\",\\\"a|P|Q|R|S\\\",\\\"AgentStatus\\\",\\\"DashboardService\\\",\\\"PluginState\\\",\\\"a|U|V|W\\\",\\\"oneofs\\\",\\\"fields\\\",\\\"comment\\\",\\\"a|Y|Z|0|a\\\",\\\"_memory\\\",\\\"a|c\\\",\\\"oneof\\\",\\\"a|e\\\",\\\"memory\\\",\\\"a|g\\\",\\\"o|f|h\\\",\\\"o|d|i\\\",\\\"status\\\",\\\"plugins\\\",\\\"a|k|g|l\\\",\\\"id\\\",\\\"a|M|n|a\\\",\\\"Status\\\",\\\"n|1\\\",\\\"o|o|p|q|\\\",\\\"options\\\",\\\"a|M|n|s|a\\\",\\\"Memory\\\",\\\"n|2\\\",\\\"proto3_optional\\\",\\\"a|w\\\",\\\"b|T\\\",\\\"o|x|y\\\",\\\"o|t|u|v|z|\\\",\\\"rule\\\",\\\"a|11|M|n|a\\\",\\\"repeated\\\",\\\"n|3\\\",\\\"o|12|13|W|14|\\\",\\\"o|m|r|10|15\\\",\\\"a|u|p\\\",\\\"a|Z|a\\\",\\\"total\\\",\\\"free\\\",\\\"ramUsage\\\",\\\"a|19|1A|1B\\\",\\\"string\\\",\\\"The total amount of system memory in bytes as a string.\\\",\\\"o|o|1D|q|1E\\\",\\\"The amount of free system memory in bytes as a string.\\\",\\\"o|o|1D|v|1G\\\",\\\"o|o|1D|14|\\\",\\\"o|1C|1F|1H|1I\\\",\\\"o|18|1J|\\\",\\\"values\\\",\\\"comments\\\",\\\"a|1L|a|1M\\\",\\\"ON\\\",\\\"OFF\\\",\\\"a|1O|1P\\\",\\\"n|0\\\",\\\"o|1Q|1R|q\\\",\\\"o|1Q||\\\",\\\"o|1N|1S||1T\\\",\\\"o|17|1K|1U\\\",\\\"o|b|j|16|1V|\\\",\\\"methods\\\",\\\"a|1X|a\\\",\\\"a|k\\\",\\\"requestType\\\",\\\"responseType\\\",\\\"responseStream\\\",\\\"a|1a|1b|1c|a\\\",\\\"google.protobuf.Empty\\\",\\\"o|1d|1e|U|y|\\\",\\\"o|1Z|1f\\\",\\\"o|1Y|1g|\\\",\\\"a|n|9\\\",\\\"o|o|1D|q|\\\",\\\"dxos.config.Runtime.Agent.Plugin\\\",\\\"o|o|1k|v|\\\",\\\"o|1i|1j|1l\\\",\\\"o|18|1m|\\\",\\\"o|X|1W|1h|1n\\\",\\\"o|1|1o\\\",\\\"Config\\\",\\\"a|1q\\\",\\\"a|Y|Z|a\\\",\\\"_port\\\",\\\"a|1t\\\",\\\"port\\\",\\\"a|1v\\\",\\\"o|f|1w\\\",\\\"o|1u|1x\\\",\\\"int32\\\",\\\"o|t|1z|q|z|\\\",\\\"o|1w|20\\\",\\\"o|1s|1y|21|\\\",\\\"o|1r|22\\\",\\\"o|1|23\\\",\\\"EpochMonitorConfig\\\",\\\"a|25\\\",\\\"_minMessagesBetweenEpochs\\\",\\\"_minTimeBetweenEpochs\\\",\\\"_minInactivityBeforeEpoch\\\",\\\"_maxInactivityDelay\\\",\\\"a|27|28|29|2A\\\",\\\"minMessagesBetweenEpochs\\\",\\\"a|2C\\\",\\\"o|f|2D\\\",\\\"minTimeBetweenEpochs\\\",\\\"a|2F\\\",\\\"o|f|2G\\\",\\\"minInactivityBeforeEpoch\\\",\\\"a|2I\\\",\\\"o|f|2J\\\",\\\"maxInactivityDelay\\\",\\\"a|2L\\\",\\\"o|f|2M\\\",\\\"o|2B|2E|2H|2K|2N\\\",\\\"a|2C|2F|2I|2L\\\",\\\"o|t|1z|v|z|\\\",\\\"o|t|1z|14|z|\\\",\\\"n|4\\\",\\\"o|t|1z|2S|z|\\\",\\\"o|2P|20|2Q|2R|2T\\\",\\\"o|1s|2O|2U|\\\",\\\"o|26|2V\\\",\\\"o|1|2W\\\",\\\"Function\\\",\\\"FunctionRegistryService\\\",\\\"FunctionsConfig\\\",\\\"RegisterRequest\\\",\\\"RegisterResponse\\\",\\\"UnregisterRequest\\\",\\\"UpdateRegistrationRequest\\\",\\\"a|2Y|2Z|2a|2b|2c|2d|2e\\\",\\\"route\\\",\\\"a|n|2g\\\",\\\"o|o|1D|v|\\\",\\\"o|2h|1j|2i\\\",\\\"o|18|2j|\\\",\\\"Register\\\",\\\"UpdateRegistration\\\",\\\"Unregister\\\",\\\"a|2l|2m|2n\\\",\\\"a|1a|1b|a\\\",\\\"o|2p|2b|2c|\\\",\\\"o|2p|2e|1e|\\\",\\\"o|2p|2d|1e|\\\",\\\"o|2o|2q|2r|2s\\\",\\\"o|1Y|2t|\\\",\\\"_manifest\\\",\\\"a|1t|2v\\\",\\\"manifest\\\",\\\"a|2x\\\",\\\"o|f|2y\\\",\\\"o|2w|1x|2z\\\",\\\"a|1v|2x\\\",\\\"o|t|1D|v|z|\\\",\\\"o|31|20|32\\\",\\\"o|1s|30|33|\\\",\\\"endpoint\\\",\\\"a|35\\\",\\\"o|36|1j\\\",\\\"o|18|37|\\\",\\\"registrationId\\\",\\\"a|39|35\\\",\\\"o|3A|1j|2i\\\",\\\"o|18|3B|\\\",\\\"a|39\\\",\\\"o|3D|1j\\\",\\\"o|18|3E|\\\",\\\"a|39|S\\\",\\\"o|12|13|2Y|v|\\\",\\\"o|3G|1j|3H\\\",\\\"o|18|3I|\\\",\\\"o|2f|2k|2u|34|38|3C|3F|3J\\\",\\\"o|1|3K\\\",\\\"o|T|1p|24|2X|3L\\\",\\\"o|1|3M\\\",\\\"Bot\\\",\\\"BotFactoryService\\\",\\\"BotPackageSpecifier\\\",\\\"BotReport\\\",\\\"BotService\\\",\\\"GetBotsResponse\\\",\\\"GetLogsRequest\\\",\\\"GetLogsResponse\\\",\\\"InitializeRequest\\\",\\\"SendCommandRequest\\\",\\\"SendCommandResponse\\\",\\\"SpawnBotRequest\\\",\\\"StartRequest\\\",\\\"a|3O|3P|3Q|3R|3S|3T|3U|3V|3W|3X|3Y|3Z|3a\\\",\\\"_status\\\",\\\"_desiredState\\\",\\\"_attemptsToAchieveDesiredState\\\",\\\"_packageSpecifier\\\",\\\"_lastStart\\\",\\\"_spaceKey\\\",\\\"_runtime\\\",\\\"_report\\\",\\\"a|3c|3d|3e|3f|3g|3h|3i|3j\\\",\\\"o|f|1Z\\\",\\\"desiredState\\\",\\\"a|3m\\\",\\\"o|f|3n\\\",\\\"attemptsToAchieveDesiredState\\\",\\\"a|3p\\\",\\\"o|f|3q\\\",\\\"packageSpecifier\\\",\\\"a|3s\\\",\\\"o|f|3t\\\",\\\"lastStart\\\",\\\"a|3v\\\",\\\"o|f|3w\\\",\\\"spaceKey\\\",\\\"a|3y\\\",\\\"o|f|3z\\\",\\\"runtime\\\",\\\"a|41\\\",\\\"o|f|42\\\",\\\"report\\\",\\\"a|44\\\",\\\"o|f|45\\\",\\\"o|3k|3l|3o|3r|3u|3x|40|43|46\\\",\\\"a|n|k|3m|3p|3s|3v|3y|41|44\\\",\\\"o|t|p|v|z|\\\",\\\"n|t\\\",\\\"The state that the bot aims to be in. Can be only either RUNNING or STOPPED.\\\",\\\"o|t|p|4A|z|4B\\\",\\\"n|u\\\",\\\"o|t|1z|4D|z|\\\",\\\"o|t|3Q|14|z|\\\",\\\"google.protobuf.Timestamp\\\",\\\"o|t|4G|2S|z|\\\",\\\"dxos.keys.PublicKey\\\",\\\"n|5\\\",\\\"o|t|4I|4J|z|\\\",\\\"Runtime\\\",\\\"n|6\\\",\\\"o|t|4L|4M|z|\\\",\\\"n|7\\\",\\\"o|t|3R|4O|z|\\\",\\\"o|48|1j|49|4C|4E|4F|4H|4K|4N|4P\\\",\\\"a|4L|p\\\",\\\"_exitCode\\\",\\\"_exitSignal\\\",\\\"_error\\\",\\\"a|4S|4T|4U\\\",\\\"exitCode\\\",\\\"a|4W\\\",\\\"o|f|4X\\\",\\\"exitSignal\\\",\\\"a|4Z\\\",\\\"o|f|4a\\\",\\\"a|C\\\",\\\"o|f|4c\\\",\\\"o|4V|4Y|4b|4d\\\",\\\"a|4W|4Z|C\\\",\\\"o|t|1D|14|z|\\\",\\\"o|4f|20|32|4g\\\",\\\"o|1s|4e|4h|\\\",\\\"STOPPED\\\",\\\"STARTING\\\",\\\"RUNNING\\\",\\\"STOPPING\\\",\\\"SPAWNING\\\",\\\"a|4j|4k|4l|4m|4n\\\",\\\"o|4o|1R|q|v|14|2S\\\",\\\"Starting bot process.\\\",\\\"Bot is running.\\\",\\\"Bot is stopping.\\\",\\\"Bot is being spawned. Bot factory is downloading the bot bundle and initializing resources.\\\",\\\"o|4o||4q|4r|4s|4t\\\",\\\"o|1N|4p||4u\\\",\\\"o|4R|4i|4v\\\",\\\"o|b|47|4Q|4w|\\\",\\\"GetBots\\\",\\\"SpawnBot\\\",\\\"Start\\\",\\\"Stop\\\",\\\"Remove\\\",\\\"GetLogs\\\",\\\"SendCommand\\\",\\\"RemoveAll\\\",\\\"a|4y|4z|50|51|52|53|54|55\\\",\\\"o|2p|1e|3T|\\\",\\\"o|2p|3Z|3O|\\\",\\\"o|2p|3O|3O|\\\",\\\"o|2p|3O|1e|\\\",\\\"o|1d|3U|3V|y|\\\",\\\"o|2p|3X|3Y|\\\",\\\"o|2p|1e|1e|\\\",\\\"o|56|57|58|59|59|5A|5B|5C|5D\\\",\\\"Service that is used by clients to communicate with bot factory.\\\",\\\"o|1Y|5E|5F\\\",\\\"kind\\\",\\\"a|5H\\\",\\\"a|e|a\\\",\\\"name\\\",\\\"ipfsCid\\\",\\\"localPath\\\",\\\"a|5K|5L|5M\\\",\\\"o|5J|5N|\\\",\\\"o|5I|5O\\\",\\\"DXN of the bot in the DXNS registry.\\\",\\\"o|o|1D|q|5Q\\\",\\\"o|5N|5R|2i|1I\\\",\\\"o|1s|5P|5S|\\\",\\\"_processedTimeframe\\\",\\\"a|5U\\\",\\\"processedTimeframe\\\",\\\"a|5W\\\",\\\"o|f|5X\\\",\\\"o|5V|5Y\\\",\\\"dxos.echo.timeframe.TimeframeVector\\\",\\\"Details of the space the bot was spawned for.\\\",\\\"o|t|5a|q|z|5b\\\",\\\"o|5X|5c\\\",\\\"o|1s|5Z|5d|\\\",\\\"Initialize\\\",\\\"Command\\\",\\\"StartReporting\\\",\\\"a|5f|50|5g|51|5h\\\",\\\"Initialize Client, create profile, and join a space.\\\",\\\"o|2p|3W|1e|5j\\\",\\\"Start an initialized bot.\\\",\\\"o|2p|3a|1e|5l\\\",\\\"Custom commands sent to the bot factory.\\\",\\\"o|2p|3X|3Y|5n\\\",\\\"Stop the bot.\\\",\\\"o|2p|1e|1e|5p\\\",\\\"Send periodic reports of the bot's state.\\\",\\\"o|1d|1e|3R|y|5r\\\",\\\"o|5i|5k|5m|5o|5q|5s\\\",\\\"Service that is used by bots communicating with bot factory.\\\",\\\"o|1Y|5t|5u\\\",\\\"bots\\\",\\\"a|5w\\\",\\\"o|12|13|3O|q|\\\",\\\"o|5x|5y\\\",\\\"o|18|5z|\\\",\\\"botId\\\",\\\"a|61\\\",\\\"o|62|1j\\\",\\\"o|18|63|\\\",\\\"chunk\\\",\\\"a|65\\\",\\\"bytes\\\",\\\"o|o|67|q|\\\",\\\"o|66|68\\\",\\\"o|18|69|\\\",\\\"_config\\\",\\\"_invitation\\\",\\\"_id\\\",\\\"a|6B|6C|6D\\\",\\\"a|9\\\",\\\"o|f|6F\\\",\\\"invitation\\\",\\\"a|6H\\\",\\\"o|f|6I\\\",\\\"a|n\\\",\\\"o|f|6K\\\",\\\"o|6E|6G|6J|6L\\\",\\\"a|9|6H|n\\\",\\\"dxos.config.Config\\\",\\\"Bot runtime configuration.\\\",\\\"o|t|6O|q|z|6P\\\",\\\"dxos.client.services.Invitation\\\",\\\"Invitation for the bot to join the target space.\\\",\\\"o|t|6R|v|z|6S\\\",\\\"ID of the bot.\\\",\\\"o|t|1D|14|z|6U\\\",\\\"o|6N|6Q|6T|6V\\\",\\\"o|1s|6M|6W|\\\",\\\"_botId\\\",\\\"_command\\\",\\\"a|6Y|6Z\\\",\\\"o|f|62\\\",\\\"command\\\",\\\"a|6c\\\",\\\"o|f|6d\\\",\\\"o|6a|6b|6e\\\",\\\"a|61|6c\\\",\\\"o|t|1D|q|z|\\\",\\\"o|t|67|v|z|\\\",\\\"o|6g|6h|6i\\\",\\\"o|1s|6f|6j|\\\",\\\"_response\\\",\\\"a|6l\\\",\\\"response\\\",\\\"a|6n\\\",\\\"o|f|6o\\\",\\\"o|6m|6p\\\",\\\"o|t|67|q|z|\\\",\\\"o|6o|6r\\\",\\\"o|1s|6q|6s|\\\",\\\"_package\\\",\\\"a|6u|6C|3h\\\",\\\"package\\\",\\\"a|6w\\\",\\\"o|f|6x\\\",\\\"o|6v|6y|6J|40\\\",\\\"a|6w|6H|3y\\\",\\\"o|t|3Q|q|z|\\\",\\\"Key of the space bot is invited to.\\\",\\\"o|t|4I|14|z|72\\\",\\\"o|70|71|6T|73\\\",\\\"o|1s|6z|74|\\\",\\\"o|o|6O|q|6P\\\",\\\"o|6F|76\\\",\\\"o|18|77|\\\",\\\"o|3b|4x|5G|5T|5e|5v|60|64|6A|6X|6k|6t|75|78\\\",\\\"o|1|79\\\",\\\"services\\\",\\\"a|7B\\\",\\\"AcceptInvitationRequest\\\",\\\"AdmissionKeypair\\\",\\\"AuthenticationRequest\\\",\\\"CancelInvitationRequest\\\",\\\"ConnectionState\\\",\\\"Contact\\\",\\\"ContactsService\\\",\\\"ControlMetricsRequest\\\",\\\"ControlMetricsResponse\\\",\\\"CreateEpochRequest\\\",\\\"CreateIdentityRequest\\\",\\\"Device\\\",\\\"DeviceKind\\\",\\\"DevicesService\\\",\\\"GetDiagnosticsRequest\\\",\\\"GetDiagnosticsResponse\\\",\\\"Identity\\\",\\\"IdentityService\\\",\\\"Invitation\\\",\\\"InvitationMethod\\\",\\\"InvitationsService\\\",\\\"LoadPersistentInvitationsResponse\\\",\\\"LogEntry\\\",\\\"LoggingService\\\",\\\"LogLevel\\\",\\\"Metrics\\\",\\\"NetworkService\\\",\\\"NetworkStatus\\\",\\\"Platform\\\",\\\"PostMessageRequest\\\",\\\"QueryCredentialsRequest\\\",\\\"QueryDevicesResponse\\\",\\\"QueryIdentityResponse\\\",\\\"QueryInvitationsResponse\\\",\\\"QueryLogsRequest\\\",\\\"QueryMetricsRequest\\\",\\\"QueryMetricsResponse\\\",\\\"QuerySpacesResponse\\\",\\\"QueryStatusRequest\\\",\\\"QueryStatusResponse\\\",\\\"RecoverIdentityRequest\\\",\\\"SignPresentationRequest\\\",\\\"Space\\\",\\\"SpaceMember\\\",\\\"SpacesService\\\",\\\"SpaceState\\\",\\\"SubscribeMessagesRequest\\\",\\\"SystemService\\\",\\\"SystemStatus\\\",\\\"UpdateConfigRequest\\\",\\\"UpdateMemberRoleRequest\\\",\\\"UpdateSpaceRequest\\\",\\\"UpdateStatusRequest\\\",\\\"WriteCredentialsRequest\\\",\\\"a|7D|7E|7F|7G|7H|7I|7J|7K|7L|7M|7N|7O|7P|7Q|7R|7S|7T|7U|7V|7W|7X|7Y|7Z|7a|7b|7c|7d|7e|7f|7g|7h|7i|7j|7k|7l|7m|7n|7o|7p|7q|7r|7s|7t|7u|7v|7w|7x|7y|7z|80|81|82|83|84\\\",\\\"_deviceProfile\\\",\\\"a|86\\\",\\\"deviceProfile\\\",\\\"a|88\\\",\\\"o|f|89\\\",\\\"o|87|8A\\\",\\\"a|6H|88\\\",\\\"o|o|7V|q|\\\",\\\"dxos.halo.credentials.DeviceProfileDocument\\\",\\\"o|t|8E|v|z|\\\",\\\"o|8C|8D|8F\\\",\\\"o|1s|8B|8G|\\\",\\\"_privateKey\\\",\\\"a|8I\\\",\\\"privateKey\\\",\\\"a|8K\\\",\\\"o|f|8L\\\",\\\"o|8J|8M\\\",\\\"publicKey\\\",\\\"a|8O|8K\\\",\\\"o|o|4I|q|\\\",\\\"dxos.keys.PrivateKey\\\",\\\"o|t|8R|v|z|\\\",\\\"o|8P|8Q|8S\\\",\\\"o|1s|8N|8T|\\\",\\\"invitationId\\\",\\\"authCode\\\",\\\"a|8V|8W\\\",\\\"o|8X|1j|2i\\\",\\\"o|18|8Y|\\\",\\\"a|8V\\\",\\\"o|8a|1j\\\",\\\"o|18|8b|\\\",\\\"OFFLINE\\\",\\\"ONLINE\\\",\\\"a|8d|8e\\\",\\\"o|8f|1R|q\\\",\\\"o|8f||\\\",\\\"o|1N|8g||8h\\\",\\\"profile\\\",\\\"a|8j\\\",\\\"halo.credentials.ProfileDocument\\\",\\\"o|o|8l|q|\\\",\\\"o|8k|8m\\\",\\\"o|18|8n|\\\",\\\"UpdateContact\\\",\\\"QueryContacts\\\",\\\"a|8p|8q\\\",\\\"o|2p|1e|7I|\\\",\\\"o|1d|1e|7I|y|\\\",\\\"o|8r|8s|8t\\\",\\\"o|1Y|8u|\\\",\\\"_reset\\\",\\\"_record\\\",\\\"a|8w|8x\\\",\\\"reset\\\",\\\"a|8z\\\",\\\"o|f|90\\\",\\\"record\\\",\\\"a|92\\\",\\\"o|f|93\\\",\\\"o|8y|91|94\\\",\\\"a|8z|92\\\",\\\"bool\\\",\\\"o|t|97|q|z|\\\",\\\"o|t|97|v|z|\\\",\\\"o|96|98|99\\\",\\\"o|1s|95|9A|\\\",\\\"_recording\\\",\\\"a|9C\\\",\\\"recording\\\",\\\"a|9E\\\",\\\"o|f|9F\\\",\\\"o|9D|9G\\\",\\\"o|9F|98\\\",\\\"o|1s|9H|9I|\\\",\\\"_migration\\\",\\\"a|9K\\\",\\\"migration\\\",\\\"a|9M\\\",\\\"o|f|9N\\\",\\\"o|9L|9O\\\",\\\"a|3y|9M\\\",\\\"Migration\\\",\\\"o|t|9R|v|z|\\\",\\\"o|9Q|8Q|9S\\\",\\\"a|9R\\\",\\\"NONE\\\",\\\"INIT_AUTOMERGE\\\",\\\"PRUNE_AUTOMERGE_ROOT_HISTORY\\\",\\\"FRAGMENT_AUTOMERGE_ROOT\\\",\\\"a|9V|9W|9X|9Y\\\",\\\"o|9Z|1R|q|v|14\\\",\\\"Init empty automerge document as the space root. Disables legacy ECHO snapshot creation.\\\",\\\"Init new automerge root by clonning the current space root. History is pruned.\\\",\\\"Create a new space root and move objects from the current space root to separate automerge documents and.\\\",\\\"o|9Z||9b|9c|9d\\\",\\\"o|1N|9a||9e\\\",\\\"o|9U|9f\\\",\\\"o|b|9P|9T|9g|\\\",\\\"reserved\\\",\\\"a|Y|Z|9i|a\\\",\\\"_profile\\\",\\\"a|9k|86\\\",\\\"o|f|8k\\\",\\\"o|9l|9m|8A\\\",\\\"a|8j|88\\\",\\\"o|t|8l|q|z|\\\",\\\"halo.credentials.DeviceProfileDocument\\\",\\\"o|t|9q|14|z|\\\",\\\"o|9o|9p|9r\\\",\\\"a|v|v\\\",\\\"a|9t\\\",\\\"o|9j|9n|9s|9u|\\\",\\\"a|9k\\\",\\\"o|9w|9m\\\",\\\"deviceKey\\\",\\\"presence\\\",\\\"a|9y|5H|8j|9z\\\",\\\"o|o|7P|v|\\\",\\\"PresenceState\\\",\\\"o|o|A2|2S|\\\",\\\"o|A0|8Q|A1|9r|A3\\\",\\\"a|A2\\\",\\\"REMOVED\\\",\\\"a|8d|8e|A6\\\",\\\"o|A7|1R|q|v\\\",\\\"o|A7|||\\\",\\\"o|1N|A8||A9\\\",\\\"o|A5|AA\\\",\\\"o|b|9x|A4|AB|\\\",\\\"CURRENT\\\",\\\"TRUSTED\\\",\\\"a|AD|AE\\\",\\\"o|AF|1R|q\\\",\\\"o|AF||\\\",\\\"o|1N|AG||AH\\\",\\\"UpdateDevice\\\",\\\"QueryDevices\\\",\\\"a|AJ|AK\\\",\\\"o|2p|9q|7O|\\\",\\\"o|1d|1e|7i|y|\\\",\\\"o|AL|AM|AN\\\",\\\"o|1Y|AO|\\\",\\\"_keys\\\",\\\"a|AQ\\\",\\\"a|G\\\",\\\"o|f|AS\\\",\\\"o|AR|AT\\\",\\\"KEY_OPTION\\\",\\\"o|t|AV|q|z|\\\",\\\"o|AS|AW\\\",\\\"a|AV\\\",\\\"TRUNCATE\\\",\\\"HUMANIZE\\\",\\\"a|9V|AZ|Aa\\\",\\\"o|Ab|1R|q|v\\\",\\\"o|Ab|||\\\",\\\"o|1N|Ac||Ad\\\",\\\"o|AY|Ae\\\",\\\"o|b|AU|AX|Af|\\\",\\\"timestamp\\\",\\\"diagnostics\\\",\\\"a|Ah|Ai\\\",\\\"o|o|4G|q|\\\",\\\"google.protobuf.Struct\\\",\\\"o|o|Al|v|\\\",\\\"o|Aj|Ak|Am\\\",\\\"o|18|An|\\\",\\\"a|3h|9k\\\",\\\"o|Ap|40|9m\\\",\\\"identityKey\\\",\\\"a|Ar|3y|8j\\\",\\\"o|t|4I|v|z|\\\",\\\"o|t|8l|14|z|\\\",\\\"o|As|8Q|At|Au\\\",\\\"o|1s|Aq|Av|\\\",\\\"CreateIdentity\\\",\\\"RecoverIdentity\\\",\\\"QueryIdentity\\\",\\\"UpdateProfile\\\",\\\"SignPresentation\\\",\\\"a|Ax|Ay|Az|B0|B1\\\",\\\"o|2p|7N|7T|\\\",\\\"o|2p|7r|7T|\\\",\\\"o|1d|1e|7j|y|\\\",\\\"o|2p|8l|7T|\\\",\\\"dxos.halo.credentials.Presentation\\\",\\\"o|2p|7s|B7|\\\",\\\"o|B2|B3|B4|B5|B6|B8\\\",\\\"o|1Y|B9|\\\",\\\"_timeout\\\",\\\"_identityKey\\\",\\\"_authCode\\\",\\\"_target\\\",\\\"_persistent\\\",\\\"_created\\\",\\\"_lifetime\\\",\\\"_multiUse\\\",\\\"_guestKeypair\\\",\\\"_delegationCredentialId\\\",\\\"_role\\\",\\\"a|BB|BC|3h|BD|BE|BF|BG|BH|BI|BJ|BK|BL\\\",\\\"timeout\\\",\\\"a|BN\\\",\\\"o|f|BO\\\",\\\"a|Ar\\\",\\\"o|f|BQ\\\",\\\"a|8W\\\",\\\"o|f|BS\\\",\\\"target\\\",\\\"a|BU\\\",\\\"o|f|BV\\\",\\\"persistent\\\",\\\"a|BX\\\",\\\"o|f|BY\\\",\\\"created\\\",\\\"a|Ba\\\",\\\"o|f|Bb\\\",\\\"lifetime\\\",\\\"a|Bd\\\",\\\"o|f|Be\\\",\\\"multiUse\\\",\\\"a|Bg\\\",\\\"o|f|Bh\\\",\\\"guestKeypair\\\",\\\"a|Bj\\\",\\\"o|f|Bk\\\",\\\"delegationCredentialId\\\",\\\"a|Bm\\\",\\\"o|f|Bn\\\",\\\"role\\\",\\\"a|Bp\\\",\\\"o|f|Bq\\\",\\\"o|BM|BP|BR|40|BT|BW|BZ|Bc|Bf|Bi|Bl|Bo|Br\\\",\\\"authMethod\\\",\\\"swarmKey\\\",\\\"state\\\",\\\"a|8V|M|5H|Bt|Bu|Bv|BN|Ar|3y|8W|BU|BX|Ba|Bd|Bg|Bj|Bm|Bp\\\",\\\"Local identifier (random).\\\",\\\"o|o|1D|q|Bx\\\",\\\"Type\\\",\\\"Determines the behavior of the invitation.\\\",\\\"o|o|Bz|v|C0\\\",\\\"Kind\\\",\\\"Kind of access the invitation will grant.\\\",\\\"o|o|C2|14|C3\\\",\\\"AuthMethod\\\",\\\"How the invitation is authenticated.\\\",\\\"o|o|C5|2S|C6\\\",\\\"Swarm rendezvous (random).\\\",\\\"o|o|4I|4J|C8\\\",\\\"State\\\",\\\"Local state.\\\",\\\"o|o|CA|4M|CB\\\",\\\"Timeout for guest to complete invitation once connected (ms).\\\",\\\"o|t|1z|4O|z|CD\\\",\\\"n|8\\\",\\\"Guest's identity.\\\",\\\"o|t|4I|CF|z|CG\\\",\\\"n|9\\\",\\\"Space to join (only present if kind is SPACE).\\\",\\\"o|t|4I|CI|z|CJ\\\",\\\"n|A\\\",\\\"Authentication code created by host (only present if auth_method is SHARED_SECRET).\\\",\\\"o|t|1D|CL|z|CM\\\",\\\"n|B\\\",\\\"Path or identifier to navigate to after successful authentication.\\\",\\\"o|t|1D|CO|z|CP\\\",\\\"n|C\\\",\\\"Host should resume invitation on startup until timeout.\\\",\\\"o|t|97|CR|z|CS\\\",\\\"n|D\\\",\\\"o|t|4G|CU|z|\\\",\\\"n|E\\\",\\\"o|t|1z|CW|z|\\\",\\\"n|F\\\",\\\"Whether an invitation can be used multiple times.\\\",\\\"o|t|97|CY|z|CZ\\\",\\\"n|G\\\",\\\"Guest's keypair required for AuthMethod.KNOWN_PUBLIC_KEY.\\\",\\\"o|t|7E|Cb|z|Cc\\\",\\\"n|H\\\",\\\"Present on Type.DELEGATED invitations.\\\",\\\"o|t|4I|Ce|z|Cf\\\",\\\"dxos.halo.credentials.SpaceMember.Role\\\",\\\"n|I\\\",\\\"Role of the admitted member, defaults to ADMIN.\\\",\\\"o|t|Ch|Ci|z|Cj\\\",\\\"o|Bw|By|C1|C4|C7|C9|CC|CE|CH|CK|CN|CQ|CT|CV|CX|Ca|Cd|Cg|Ck\\\",\\\"a|C5|C2|CA|Bz\\\",\\\"SHARED_SECRET\\\",\\\"KNOWN_PUBLIC_KEY\\\",\\\"a|9V|Cn|Co\\\",\\\"o|Cp|1R|q|v\\\",\\\"No authentication is required. Guest should not call `Authenticate`.\\\",\\\"Guest should call `Authenticate` with the shared secret.\\\",\\\"Guest should prove they possess a private key corresponding to the known public key recorded in an invitation.\\\",\\\"o|Cp|Cr|Cs|Ct\\\",\\\"o|1N|Cq||Cu\\\",\\\"DEVICE\\\",\\\"SPACE\\\",\\\"a|Cw|Cx\\\",\\\"o|Cy|1R|q\\\",\\\"o|Cy||\\\",\\\"o|1N|Cz||D0\\\",\\\"INIT\\\",\\\"CONNECTING\\\",\\\"CONNECTED\\\",\\\"READY_FOR_AUTHENTICATION\\\",\\\"AUTHENTICATING\\\",\\\"SUCCESS\\\",\\\"CANCELLED\\\",\\\"TIMEOUT\\\",\\\"ERROR\\\",\\\"EXPIRED\\\",\\\"a|D2|D3|D4|D5|D6|D7|D8|D9|DA|DB\\\",\\\"o|DC|1R|q|v|14|2S|4J|4M|4O|CF|CI\\\",\\\"o|DC||||||||||\\\",\\\"o|1N|DD||DE\\\",\\\"INTERACTIVE\\\",\\\"DELEGATED\\\",\\\"MULTIUSE\\\",\\\"a|DG|DH|DI\\\",\\\"o|DJ|1R|q|v\\\",\\\"Requires both to be online to complete key exchange.\\\",\\\"Invitation can be accepted by any valid peer.\\\",\\\"Multi-use interactive invitations.\\\\n@deprecated use multiUse flag with type=interactive instead.\\\",\\\"o|DJ|DL|DM|DN\\\",\\\"o|1N|DK||DO\\\",\\\"o|Cm|Cv|D1|DF|DP\\\",\\\"Represents the invitation state passed between client and service.\\\",\\\"o|b|Bs|Cl|DQ|DR\\\",\\\"accepted\\\",\\\"a|Ba|DT\\\",\\\"o|5J|DU|\\\",\\\"o|5I|DV\\\",\\\"o|o|7V|v|\\\",\\\"o|DU|8D|DX\\\",\\\"o|1s|DW|DY|\\\",\\\"CreateInvitation\\\",\\\"AcceptInvitation\\\",\\\"Authenticate\\\",\\\"CancelInvitation\\\",\\\"QueryInvitations\\\",\\\"a|Da|Db|Dc|Dd|De\\\",\\\"o|1d|7V|7V|y|\\\",\\\"o|1d|7D|7V|y|\\\",\\\"o|2p|7F|1e|\\\",\\\"o|2p|7G|1e|\\\",\\\"o|1d|1e|7k|y|\\\",\\\"o|Df|Dg|Dh|Di|Dj|Dk\\\",\\\"o|1Y|Dl|\\\",\\\"invitations\\\",\\\"a|Dn\\\",\\\"o|12|13|7V|q|\\\",\\\"o|Do|Dp\\\",\\\"o|18|Dq|\\\",\\\"_context\\\",\\\"_meta\\\",\\\"a|Ds|Dt|4U\\\",\\\"context\\\",\\\"a|Dv\\\",\\\"o|f|Dw\\\",\\\"meta\\\",\\\"a|Dy\\\",\\\"o|f|Dz\\\",\\\"o|Du|Dx|E0|4d\\\",\\\"level\\\",\\\"message\\\",\\\"a|E2|E3|Dv|Dy|C|Ah\\\",\\\"o|o|7b|q|\\\",\\\"o|t|Al|14|z|\\\",\\\"Meta\\\",\\\"o|t|E7|2S|z|\\\",\\\"dxos.error.Error\\\",\\\"o|t|E9|4J|z|\\\",\\\"o|o|4G|4M|\\\",\\\"o|E4|E5|2i|E6|E8|EA|EB\\\",\\\"a|E7\\\",\\\"_scope\\\",\\\"_resourceId\\\",\\\"a|EE|EF\\\",\\\"scope\\\",\\\"a|EH\\\",\\\"o|f|EI\\\",\\\"resourceId\\\",\\\"a|EK\\\",\\\"o|f|EL\\\",\\\"o|EG|EJ|EM\\\",\\\"file\\\",\\\"line\\\",\\\"a|EO|EP|EH|EK\\\",\\\"o|o|1z|v|\\\",\\\"o|EQ|1j|ER|E6|2T\\\",\\\"o|1s|EN|ES|\\\",\\\"o|ED|ET\\\",\\\"o|b|E1|EC|EU|\\\",\\\"ControlMetrics\\\",\\\"QueryMetrics\\\",\\\"QueryLogs\\\",\\\"a|EW|EX|EY\\\",\\\"o|2p|7K|7L|\\\",\\\"o|1d|7m|7n|y|\\\",\\\"o|1d|7l|7Z|y|\\\",\\\"o|EZ|Ea|Eb|Ec\\\",\\\"o|1Y|Ed|\\\",\\\"TRACE\\\",\\\"DEBUG\\\",\\\"INFO\\\",\\\"WARN\\\",\\\"a|Ef|Eg|Eh|Ei|DA\\\",\\\"o|Ej|4J|CL|CO|CR|CU\\\",\\\"o|Ej|||||\\\",\\\"o|1N|Ek||El\\\",\\\"a|Z|0|a\\\",\\\"a|Ah|1L\\\",\\\"KeyPair\\\",\\\"o|12|13|Ep|CL|\\\",\\\"o|Eo|Ak|Eq\\\",\\\"a|Ep\\\",\\\"_key\\\",\\\"_value\\\",\\\"_stats\\\",\\\"a|Et|Eu|Ev\\\",\\\"key\\\",\\\"a|Ex\\\",\\\"o|f|Ey\\\",\\\"a|N\\\",\\\"o|f|F0\\\",\\\"stats\\\",\\\"a|F2\\\",\\\"o|f|F3\\\",\\\"o|Ew|Ez|F1|F4\\\",\\\"a|Ex|N|F2\\\",\\\"dxos.value.Value\\\",\\\"o|t|F7|v|z|\\\",\\\"dxos.value.Stats\\\",\\\"o|t|F9|14|z|\\\",\\\"o|F6|6h|F8|FA\\\",\\\"o|1s|F5|FB|\\\",\\\"o|Es|FC\\\",\\\"o|En|Er|FD|\\\",\\\"UpdateConfig\\\",\\\"QueryStatus\\\",\\\"a|FF|FG\\\",\\\"o|2p|80|1e|\\\",\\\"o|1d|1e|7e|y|\\\",\\\"o|FH|FI|FJ\\\",\\\"o|1Y|FK|\\\",\\\"swarm\\\",\\\"signaling\\\",\\\"connectionInfo\\\",\\\"a|FM|FN|FO\\\",\\\"o|o|7H|q|\\\",\\\"Signal\\\",\\\"o|12|13|FR|v|\\\",\\\"dxos.devtools.swarm.SwarmInfo\\\",\\\"o|12|13|FT|14|\\\",\\\"o|FP|FQ|FS|FU\\\",\\\"a|FR\\\",\\\"server\\\",\\\"a|FX|Bv\\\",\\\"dxos.mesh.signal.SignalState\\\",\\\"o|o|FZ|v|\\\",\\\"o|FY|1j|Fa\\\",\\\"o|18|Fb|\\\",\\\"o|FW|Fc\\\",\\\"o|En|FV|Fd|\\\",\\\"_userAgent\\\",\\\"_platform\\\",\\\"_arch\\\",\\\"_uptime\\\",\\\"a|Ff|Fg|Fh|3i|Fi|c\\\",\\\"userAgent\\\",\\\"a|Fk\\\",\\\"o|f|Fl\\\",\\\"platform\\\",\\\"a|Fn\\\",\\\"o|f|Fo\\\",\\\"arch\\\",\\\"a|Fq\\\",\\\"o|f|Fr\\\",\\\"uptime\\\",\\\"a|Ft\\\",\\\"o|f|Fu\\\",\\\"o|Fj|Fm|Fp|Fs|43|Fv|i\\\",\\\"a|M|Fk|Fn|Fq|41|Ft|g\\\",\\\"PLATFORM_TYPE\\\",\\\"o|o|Fy|q|\\\",\\\"The User-Agent string from a browser\\\",\\\"o|t|1D|v|z|G0\\\",\\\"e.g process.platform from node, e.g. 'darwin', 'linux', 'win32'\\\",\\\"o|t|1D|14|z|G2\\\",\\\"the Node.JS arch string, e.g. 'arm64', 'x64'\\\",\\\"o|t|1D|2S|z|G4\\\",\\\"the node.js version string\\\",\\\"o|t|1D|4J|z|G6\\\",\\\"uint32\\\",\\\"the number of seconds the client has been up\\\",\\\"o|t|G8|4M|z|G9\\\",\\\"e.g. NodeJS.MemoryUsage, subject to change\\\",\\\"o|t|Al|4O|z|GB\\\",\\\"o|Fx|Fz|G1|G3|G5|G7|GA|GC\\\",\\\"a|Fy\\\",\\\"BROWSER\\\",\\\"SHARED_WORKER\\\",\\\"NODE\\\",\\\"a|GF|GG|GH\\\",\\\"o|GI|1R|q|v\\\",\\\"o|GI|||\\\",\\\"o|1N|GJ||GK\\\",\\\"o|GE|GL\\\",\\\"o|b|Fw|GD|GM|\\\",\\\"channel\\\",\\\"a|3y|GO|E3\\\",\\\"google.protobuf.Any\\\",\\\"o|o|GQ|14|\\\",\\\"o|GP|8Q|2i|GR\\\",\\\"o|18|GS|\\\",\\\"_noTail\\\",\\\"a|GU\\\",\\\"noTail\\\",\\\"a|GW\\\",\\\"o|f|GX\\\",\\\"o|GV|GY\\\",\\\"a|3y|GW\\\",\\\"o|Ga|8Q|99\\\",\\\"o|1s|GZ|Gb|\\\",\\\"devices\\\",\\\"a|Gd\\\",\\\"o|12|13|7O|q|\\\",\\\"o|Ge|Gf\\\",\\\"o|18|Gg|\\\",\\\"_identity\\\",\\\"a|Gi\\\",\\\"identity\\\",\\\"a|Gk\\\",\\\"o|f|Gl\\\",\\\"o|Gj|Gm\\\",\\\"o|t|7T|q|z|\\\",\\\"o|Gl|Go\\\",\\\"o|1s|Gn|Gp|\\\",\\\"_existing\\\",\\\"a|Gr\\\",\\\"existing\\\",\\\"a|Gt\\\",\\\"o|f|Gu\\\",\\\"o|Gs|Gv\\\",\\\"action\\\",\\\"a|Gx|M|Dn|Gt\\\",\\\"Action\\\",\\\"o|o|Gz|q|\\\",\\\"o|o|Bz|v|\\\",\\\"o|12|13|7V|14|\\\",\\\"o|t|97|2S|z|\\\",\\\"o|Gy|H0|H1|H2|H3\\\",\\\"a|Gz|Bz\\\",\\\"ADDED\\\",\\\"SAVED\\\",\\\"LOAD_COMPLETE\\\",\\\"a|H6|A6|H7|H8\\\",\\\"o|H9|1R|q|v|14\\\",\\\"o|H9||||\\\",\\\"o|1N|HA||HB\\\",\\\"CREATED\\\",\\\"ACCEPTED\\\",\\\"a|HD|HE\\\",\\\"o|HF|1R|q\\\",\\\"o|HF||\\\",\\\"o|1N|HG||HH\\\",\\\"o|H5|HC|HI\\\",\\\"o|b|Gw|H4|HJ|\\\",\\\"_options\\\",\\\"a|HL\\\",\\\"a|s\\\",\\\"o|f|HN\\\",\\\"o|HM|HO\\\",\\\"filters\\\",\\\"a|HQ|s\\\",\\\"Filter\\\",\\\"o|12|13|HS|q|\\\",\\\"MatchingOptions\\\",\\\"o|t|HU|CL|z|\\\",\\\"o|HR|HT|HV\\\",\\\"a|HS|HU\\\",\\\"_pattern\\\",\\\"a|HY\\\",\\\"pattern\\\",\\\"a|Ha\\\",\\\"o|f|Hb\\\",\\\"o|HZ|Hc\\\",\\\"a|E2|Ha\\\",\\\"o|He|E5|32\\\",\\\"o|1s|Hd|Hf|\\\",\\\"INCLUSIVE\\\",\\\"EXPLICIT\\\",\\\"a|Hh|Hi\\\",\\\"o|Hj|q|v\\\",\\\"Filters match all log levels above. Default behaviour for the logger.\\\",\\\"Explicitly specify all desired log levels.\\\",\\\"o|Hj|Hl|Hm\\\",\\\"o|1N|Hk||Hn\\\",\\\"o|HX|Hg|Ho\\\",\\\"o|b|HP|HW|Hp|\\\",\\\"_interval\\\",\\\"a|Hr\\\",\\\"interval\\\",\\\"a|Ht\\\",\\\"o|f|Hu\\\",\\\"o|Hs|Hv\\\",\\\"o|Hu|20\\\",\\\"o|1s|Hw|Hx|\\\",\\\"metrics\\\",\\\"a|Ah|Hz\\\",\\\"o|o|7c|v|\\\",\\\"o|I0|Ak|I1\\\",\\\"o|18|I2|\\\",\\\"spaces\\\",\\\"a|I4\\\",\\\"o|12|13|7t|q|\\\",\\\"o|I5|I6\\\",\\\"o|18|I7|\\\",\\\"o|o|7z|q|\\\",\\\"o|1Z|I9\\\",\\\"o|18|IA|\\\",\\\"recoveryKey\\\",\\\"a|IC\\\",\\\"o|ID|68\\\",\\\"o|18|IE|\\\",\\\"_nonce\\\",\\\"a|IG\\\",\\\"nonce\\\",\\\"a|II\\\",\\\"o|f|IJ\\\",\\\"o|IH|IK\\\",\\\"presentation\\\",\\\"a|IM|II\\\",\\\"o|o|B7|q|\\\",\\\"o|IN|IO|6i\\\",\\\"o|1s|IL|IP|\\\",\\\"_pipeline\\\",\\\"_creator\\\",\\\"_cache\\\",\\\"a|IR|4U|IS|IT\\\",\\\"pipeline\\\",\\\"a|IV\\\",\\\"o|f|IW\\\",\\\"creator\\\",\\\"a|IY\\\",\\\"o|f|IZ\\\",\\\"cache\\\",\\\"a|Ib\\\",\\\"o|f|Ic\\\",\\\"o|IU|IX|4d|Ia|Id\\\",\\\"members\\\",\\\"a|3y|Bv|IV|C|If|IY|Ib|Hz\\\",\\\"o|o|7w|v|\\\",\\\"PipelineState\\\",\\\"o|t|Ii|14|z|\\\",\\\"o|t|E9|2S|z|\\\",\\\"o|12|13|7u|CL|\\\",\\\"o|t|4I|CO|z|\\\",\\\"dxos.echo.metadata.SpaceCache\\\",\\\"n|K\\\",\\\"o|t|In|Io|z|\\\",\\\"n|L\\\",\\\"o|o|7c|Iq|\\\",\\\"o|Ig|8Q|Ih|Ij|Ik|Il|Im|Ip|Ir\\\",\\\"a|7c|Ii\\\",\\\"_open\\\",\\\"_pipelineInitBegin\\\",\\\"_controlPipelineReady\\\",\\\"_dataPipelineOpen\\\",\\\"_dataPipelineReady\\\",\\\"_ready\\\",\\\"a|Iu|Iv|Iw|Ix|Iy|Iz\\\",\\\"open\\\",\\\"a|J1\\\",\\\"o|f|J2\\\",\\\"pipelineInitBegin\\\",\\\"a|J4\\\",\\\"o|f|J5\\\",\\\"controlPipelineReady\\\",\\\"a|J7\\\",\\\"o|f|J8\\\",\\\"dataPipelineOpen\\\",\\\"a|JA\\\",\\\"o|f|JB\\\",\\\"dataPipelineReady\\\",\\\"a|JD\\\",\\\"o|f|JE\\\",\\\"ready\\\",\\\"a|JG\\\",\\\"o|f|JH\\\",\\\"o|J0|J3|J6|J9|JC|JF|JI\\\",\\\"a|J1|J4|J7|JA|JD|JG\\\",\\\"o|t|4G|q|z|\\\",\\\"o|t|4G|v|z|\\\",\\\"o|t|4G|14|z|\\\",\\\"o|t|4G|4J|z|\\\",\\\"o|t|4G|4M|z|\\\",\\\"o|JK|JL|JM|JN|4H|JO|JP\\\",\\\"o|1s|JJ|JQ|\\\",\\\"_controlFeedKey\\\",\\\"_dataFeedKey\\\",\\\"_currentEpoch\\\",\\\"_appliedEpoch\\\",\\\"_currentControlTimeframe\\\",\\\"_targetControlTimeframe\\\",\\\"_totalControlTimeframe\\\",\\\"_knownControlTimeframe\\\",\\\"_startDataTimeframe\\\",\\\"_currentDataTimeframe\\\",\\\"_targetDataTimeframe\\\",\\\"_totalDataTimeframe\\\",\\\"_knownDataTimeframe\\\",\\\"a|JS|JT|JU|JV|JW|JX|JY|JZ|Ja|Jb|Jc|Jd|Je\\\",\\\"controlFeedKey\\\",\\\"a|Jg\\\",\\\"o|f|Jh\\\",\\\"dataFeedKey\\\",\\\"a|Jj\\\",\\\"o|f|Jk\\\",\\\"currentEpoch\\\",\\\"a|Jm\\\",\\\"o|f|Jn\\\",\\\"appliedEpoch\\\",\\\"a|Jp\\\",\\\"o|f|Jq\\\",\\\"currentControlTimeframe\\\",\\\"a|Js\\\",\\\"o|f|Jt\\\",\\\"targetControlTimeframe\\\",\\\"a|Jv\\\",\\\"o|f|Jw\\\",\\\"totalControlTimeframe\\\",\\\"a|Jy\\\",\\\"o|f|Jz\\\",\\\"knownControlTimeframe\\\",\\\"a|K1\\\",\\\"o|f|K2\\\",\\\"startDataTimeframe\\\",\\\"a|K4\\\",\\\"o|f|K5\\\",\\\"currentDataTimeframe\\\",\\\"a|K7\\\",\\\"o|f|K8\\\",\\\"targetDataTimeframe\\\",\\\"a|KA\\\",\\\"o|f|KB\\\",\\\"totalDataTimeframe\\\",\\\"a|KD\\\",\\\"o|f|KE\\\",\\\"knownDataTimeframe\\\",\\\"a|KG\\\",\\\"o|f|KH\\\",\\\"o|Jf|Ji|Jl|Jo|Jr|Ju|Jx|K0|K3|K6|K9|KC|KF|KI\\\",\\\"controlFeeds\\\",\\\"dataFeeds\\\",\\\"a|Jg|Jj|KK|KL|Jm|Jp|Js|Jv|Jy|K1|K4|K7|KA|KD|KG\\\",\\\"o|t|4I|q|z|\\\",\\\"TODO(burdon): Normalize _key suffix.\\\",\\\"o|12|13|4I|Ci|KO\\\",\\\"n|J\\\",\\\"o|12|13|4I|KQ|\\\",\\\"dxos.halo.credentials.Credential\\\",\\\"Last processed epoch. Might now have been applied yet.\\\",\\\"o|t|KS|Io|z|KT\\\",\\\"Epoch that is currently applied.\\\",\\\"o|t|KS|Iq|z|KV\\\",\\\"Mutations already processed.\\\",\\\"o|t|5a|CL|z|KX\\\",\\\"Minimum timeframe to consider the state to be up-to-date.\\\",\\\"o|t|5a|CO|z|KZ\\\",\\\"All mutations stored in feeds.\\\",\\\"o|t|5a|CW|z|Kb\\\",\\\"All mutations known to exist on the network.\\\",\\\"o|t|5a|CY|z|Kd\\\",\\\"n|1c\\\",\\\"Start timeframe of the pipeline.\\\",\\\"o|t|5a|Kf|z|Kg\\\",\\\"o|t|5a|CR|z|KX\\\",\\\"o|t|5a|CU|z|KZ\\\",\\\"o|t|5a|Cb|z|Kb\\\",\\\"o|t|5a|Ce|z|Kd\\\",\\\"o|KM|KN|At|KP|KR|KU|KW|KY|Ka|Kc|Ke|Kh|Ki|Kj|Kk|Kl\\\",\\\"o|1s|KJ|Km|\\\",\\\"o|It|JR|Kn\\\",\\\"o|b|Ie|Is|Ko|\\\",\\\"peerStates\\\",\\\"a|Gk|9z|Kq|Bp\\\",\\\"o|o|7T|q|\\\",\\\"o|o|A2|v|\\\",\\\"dxos.mesh.presence.PeerState\\\",\\\"o|12|13|Ku|14|\\\",\\\"o|o|Ch|2S|\\\",\\\"o|Kr|Ks|Kt|Kv|Kw\\\",\\\"o|A5|8i\\\",\\\"o|En|Kx|Ky|\\\",\\\"CreateSpace\\\",\\\"UpdateSpace\\\",\\\"QuerySpaces\\\",\\\"UpdateMemberRole\\\",\\\"PostMessage\\\",\\\"SubscribeMessages\\\",\\\"WriteCredentials\\\",\\\"QueryCredentials\\\",\\\"CreateEpoch\\\",\\\"a|L0|L1|L2|L3|L4|L5|L6|L7|L8\\\",\\\"o|2p|1e|7t|\\\",\\\"o|2p|82|1e|\\\",\\\"o|1d|1e|7o|y|\\\",\\\"o|2p|81|1e|\\\",\\\"Broadcast an ephemeral message to the space swarm.\\\",\\\"o|2p|7g|1e|LE\\\",\\\"dxos.mesh.teleport.gossip.GossipMessage\\\",\\\"Subscribe to messages from the space swarm.\\\",\\\"o|1d|7x|LG|y|LH\\\",\\\"Write credentials to the space control feed.\\\",\\\"o|2p|84|1e|LJ\\\",\\\"Query credentials from the space control feed.\\\",\\\"o|1d|7h|KS|y|LL\\\",\\\"o|2p|7M|1e|\\\",\\\"o|L9|LA|LB|LC|LD|LF|LI|LK|LM|LN\\\",\\\"o|1Y|LO|\\\",\\\"INACTIVE\\\",\\\"ACTIVE\\\",\\\"CLOSED\\\",\\\"CONTROL_ONLY\\\",\\\"INITIALIZING\\\",\\\"READY\\\",\\\"a|LQ|LR|LS|LT|LU|LV|DA\\\",\\\"o|LW|v|4M|q|4O|2S|14|4J\\\",\\\"Runtime state of the space object.\\\",\\\"Space is inactive. No swarming or replication will be done.\\\",\\\"Space is active. Swarming and replication will be done.\\\",\\\"Space is closed.\\\",\\\"Data pipeline is inactive.\\\",\\\"Data pipeline is initializing.\\\",\\\"Data pipeline is ready.\\\",\\\"Space errored.\\\",\\\"o|LW|LZ|La|Lb|Lc|Ld|Le|Lf\\\",\\\"o|1N|LX|LY|Lg\\\",\\\"a|3y|GO\\\",\\\"o|Li|8Q|2i\\\",\\\"o|18|Lj|\\\",\\\"GetConfig\\\",\\\"GetDiagnostics\\\",\\\"UpdateStatus\\\",\\\"Reset\\\",\\\"GetPlatform\\\",\\\"a|Ll|Lm|Ln|FG|Lo|Lp\\\",\\\"Get the static config of the client.\\\",\\\"o|2p|1e|6O|Lr\\\",\\\"Get the diagnostics snapshot.\\\",\\\"o|2p|7R|7S|Lt\\\",\\\"Update the status of the client. Used to re-activate an inactive client.\\\",\\\"o|2p|83|1e|Lv\\\",\\\"Stream the status of the client.\\\",\\\"o|1d|7p|7q|y|Lx\\\",\\\"Reset the client.\\\",\\\"o|2p|1e|1e|Lz\\\",\\\"Get platform Information\\\",\\\"o|2p|1e|7f|M1\\\",\\\"o|Lq|Ls|Lu|Lw|Ly|M0|M2\\\",\\\"o|1Y|M3|\\\",\\\"a|LR|LQ\\\",\\\"o|M5|1R|q\\\",\\\"o|M5||\\\",\\\"o|1N|M6||M7\\\",\\\"a|FM\\\",\\\"o|M9|FQ\\\",\\\"o|18|MA|\\\",\\\"memberKey\\\",\\\"newRole\\\",\\\"a|3y|MC|MD\\\",\\\"o|o|4I|v|\\\",\\\"o|o|Ch|14|\\\",\\\"o|ME|8Q|MF|MG\\\",\\\"o|18|MH|\\\",\\\"_state\\\",\\\"a|MJ\\\",\\\"a|Bv\\\",\\\"o|f|ML\\\",\\\"o|MK|MM\\\",\\\"a|3y|Bv\\\",\\\"Allowed values: ACTIVE, INACTIVE.\\\",\\\"o|t|7w|v|z|MP\\\",\\\"o|MO|8Q|MQ\\\",\\\"o|1s|MN|MR|\\\",\\\"credentials\\\",\\\"a|3y|MT\\\",\\\"o|12|13|KS|v|\\\",\\\"o|MU|8Q|MV\\\",\\\"o|18|MW|\\\",\\\"o|85|8H|8U|8Z|8c|8i|8o|8v|9B|9J|9h|9v|AC|AI|AP|Ag|Ao|Aw|BA|DS|DZ|Dm|Dr|EV|Ee|Em|FE|FL|Fe|GN|GT|Gc|Gh|Gq|HK|Hq|Hy|I3|I8|Hy|IB|IF|IQ|Kp|Kz|LP|Lh|Lk|M4|M8|MB|MI|MS|IB|MX\\\",\\\"o|1|MY\\\",\\\"o|7C|MZ\\\",\\\"o|1|Ma\\\",\\\"a|s|0\\\",\\\"go_package\\\",\\\"a|Md\\\",\\\"github.com/dxos/kube/proto/def/dxos/config\\\",\\\"o|Me|Mf\\\",\\\"_envVar\\\",\\\"envVar\\\",\\\"Module\\\",\\\"Package\\\",\\\"Repo\\\",\\\"a|Mh|1q|Mi|Mj|Mk|Ml|4L\\\",\\\"a|Mi\\\",\\\"o|f|Mn\\\",\\\"_version\\\",\\\"a|Mp|6u|3i\\\",\\\"version\\\",\\\"a|Mr\\\",\\\"o|f|Ms\\\",\\\"o|Mq|Mt|6y|43\\\",\\\"a|Mr|6w|41\\\",\\\"o|t|Mk|v|z|\\\",\\\"o|t|4L|14|z|\\\",\\\"o|Mv|20|Mw|Mx\\\",\\\"o|1s|Mu|My|\\\",\\\"extend\\\",\\\"a|M|n|N0|s|a\\\",\\\"n|G8\\\",\\\"google.protobuf.FieldOptions\\\",\\\"o|N1|1D|N2|N3|z|\\\",\\\"_name\\\",\\\"_type\\\",\\\"_displayName\\\",\\\"_description\\\",\\\"_bundle\\\",\\\"_tunnel\\\",\\\"_build\\\",\\\"a|6D|N5|N6|N7|N8|N9|NA|NB|8x\\\",\\\"a|5K\\\",\\\"o|f|ND\\\",\\\"a|M\\\",\\\"o|f|NF\\\",\\\"displayName\\\",\\\"a|NH\\\",\\\"o|f|NI\\\",\\\"description\\\",\\\"a|NK\\\",\\\"o|f|NL\\\",\\\"bundle\\\",\\\"a|NN\\\",\\\"o|f|NO\\\",\\\"tunnel\\\",\\\"a|NQ\\\",\\\"o|f|NR\\\",\\\"build\\\",\\\"a|NT\\\",\\\"o|f|NU\\\",\\\"o|NC|6L|NE|NG|NJ|NM|NP|NS|NV|94\\\",\\\"tags\\\",\\\"deps\\\",\\\"repos\\\",\\\"a|n|5K|M|NH|NK|NX|NN|NQ|NY|NT|NZ|92\\\",\\\"o|t|1D|CF|z|\\\",\\\"o|t|1D|2S|z|\\\",\\\"o|12|13|1D|4J|\\\",\\\"o|t|67|4M|z|\\\",\\\"o|t|97|4O|z|\\\",\\\"o|12|13|Mj|CL|\\\",\\\"Build\\\",\\\"o|t|Nh|Kf|z|\\\",\\\"n|1d\\\",\\\"o|12|13|Ml|Nj|\\\",\\\"n|3E\\\",\\\"The data will be validated based on the type when being published.\\\",\\\"o|t|GQ|Nl|z|Nm\\\",\\\"o|Na|Nb|6h|32|4g|Nc|Nd|Ne|Nf|Ng|Ni|Nk|Nn\\\",\\\"a|Nh\\\",\\\"_outdir\\\",\\\"_tag\\\",\\\"_env\\\",\\\"a|6Z|Nq|Mp|Nr|Ns\\\",\\\"outdir\\\",\\\"a|Nu\\\",\\\"o|f|Nv\\\",\\\"tag\\\",\\\"a|Nx\\\",\\\"o|f|Ny\\\",\\\"env\\\",\\\"a|O0\\\",\\\"o|f|O1\\\",\\\"o|Nt|6e|Nw|Mt|Nz|O2\\\",\\\"a|6c|Nu|Mr|Nx|O0\\\",\\\"o|t|Al|CL|z|\\\",\\\"o|O4|6h|32|4g|Nc|O5\\\",\\\"o|1s|O3|O6|\\\",\\\"o|Np|O7\\\",\\\"o|b|NW|No|O8|\\\",\\\"_license\\\",\\\"a|OA\\\",\\\"license\\\",\\\"a|OC\\\",\\\"o|f|OD\\\",\\\"o|OB|OE\\\",\\\"modules\\\",\\\"a|OC|NZ|OG\\\",\\\"o|12|13|Ml|v|\\\",\\\"o|12|13|Mj|14|\\\",\\\"o|OH|6h|OI|OJ\\\",\\\"o|1s|OF|OK|\\\",\\\"_url\\\",\\\"a|N5|OM|Mp\\\",\\\"url\\\",\\\"a|OO\\\",\\\"o|f|OP\\\",\\\"o|ON|NE|OQ|Mt\\\",\\\"a|5K|OO|Mr\\\",\\\"o|OS|6h|32|4g\\\",\\\"o|1s|OR|OT|\\\",\\\"_client\\\",\\\"_app\\\",\\\"_cli\\\",\\\"_props\\\",\\\"_services\\\",\\\"_system\\\",\\\"_kube\\\",\\\"_agent\\\",\\\"a|OV|OW|OX|OY|OZ|Oa|Ob|Oc\\\",\\\"a|8\\\",\\\"o|f|Oe\\\",\\\"app\\\",\\\"a|Og\\\",\\\"o|f|Oh\\\",\\\"cli\\\",\\\"a|Oj\\\",\\\"o|f|Ok\\\",\\\"props\\\",\\\"a|Om\\\",\\\"o|f|On\\\",\\\"o|f|7C\\\",\\\"system\\\",\\\"a|Oq\\\",\\\"o|f|Or\\\",\\\"kube\\\",\\\"a|Ot\\\",\\\"o|f|Ou\\\",\\\"a|6\\\",\\\"o|f|Ow\\\",\\\"o|Od|Of|Oi|Ol|Oo|Op|Os|Ov|Ox\\\",\\\"a|8|Og|Oj|Om|7B|Oq|Ot|G|6\\\",\\\"Client\\\",\\\"o|t|P0|q|z|\\\",\\\"App\\\",\\\"o|t|P2|v|z|\\\",\\\"CLI\\\",\\\"o|t|P4|14|z|\\\",\\\"Props\\\",\\\"o|t|P6|2S|z|\\\",\\\"Services\\\",\\\"o|t|P8|4J|z|\\\",\\\"System\\\",\\\"o|t|PA|4M|z|\\\",\\\"Kube\\\",\\\"o|t|PC|4O|z|\\\",\\\"Keys\\\",\\\"o|12|13|PE|CF|\\\",\\\"Agent\\\",\\\"o|t|PG|CI|z|\\\",\\\"o|Oz|P1|P3|P5|P7|P9|PB|PD|PF|PH\\\",\\\"a|PG|P2|P4|P0|PE|PC|P6|P8|PA\\\",\\\"a|l\\\",\\\"Plugin\\\",\\\"o|12|13|PL|q|\\\",\\\"o|PK|PM\\\",\\\"a|PL\\\",\\\"_enabled\\\",\\\"a|N5|PP|6B\\\",\\\"enabled\\\",\\\"a|PR\\\",\\\"o|f|PS\\\",\\\"o|PQ|NE|PT|6G\\\",\\\"a|n|5K|PR|9\\\",\\\"o|t|97|14|z|\\\",\\\"o|t|GQ|CL|z|\\\",\\\"o|PV|1j|32|PW|PX\\\",\\\"o|1s|PU|PY|\\\",\\\"o|PO|PZ\\\",\\\"o|En|PN|Pa|\\\",\\\"_org\\\",\\\"_theme\\\",\\\"_website\\\",\\\"_publicUrl\\\",\\\"a|Pc|Pd|Pe|Pf|NB|Ns\\\",\\\"org\\\",\\\"a|Ph\\\",\\\"o|f|Pi\\\",\\\"theme\\\",\\\"a|Pk\\\",\\\"o|f|Pl\\\",\\\"website\\\",\\\"a|Pn\\\",\\\"o|f|Po\\\",\\\"publicUrl\\\",\\\"a|Pq\\\",\\\"o|f|Pr\\\",\\\"o|Pg|Pj|Pm|Pp|Ps|NV|O2\\\",\\\"a|Ph|Pk|Pn|Pq|NT|O0\\\",\\\"(env_var)\\\",\\\"a|Pv|w\\\",\\\"PUBLIC_URL\\\",\\\"o|Pw|Px|y\\\",\\\"o|t|1D|2S|Py|\\\",\\\"BuildInfo\\\",\\\"o|t|Q0|Kf|z|\\\",\\\"o|t|Al|Nj|z|\\\",\\\"o|Pu|6h|32|4g|Pz|Q1|Q2\\\",\\\"a|Q0\\\",\\\"_timestamp\\\",\\\"_commitHash\\\",\\\"_branch\\\",\\\"a|Q5|Q6|Mp|Q7\\\",\\\"a|Ah\\\",\\\"o|f|Q9\\\",\\\"commitHash\\\",\\\"a|QB\\\",\\\"o|f|QC\\\",\\\"branch\\\",\\\"a|QE\\\",\\\"o|f|QF\\\",\\\"o|Q8|QA|QD|Mt|QG\\\",\\\"a|Ah|QB|Mr|QE\\\",\\\"RFC-3339 datetime string.\\\",\\\"o|t|1D|q|z|QJ\\\",\\\"Version from package.json.\\\",\\\"o|t|1D|14|z|QL\\\",\\\"o|QI|QK|32|QM|Nc\\\",\\\"o|1s|QH|QN|\\\",\\\"o|Q4|QO\\\",\\\"o|b|Pt|Q3|QP|\\\",\\\"_nodePath\\\",\\\"_console\\\",\\\"_mdns\\\",\\\"_signal\\\",\\\"_npmClient\\\",\\\"_channel\\\",\\\"a|QR|OW|QS|QT|QU|QV|QW\\\",\\\"nodePath\\\",\\\"a|QY\\\",\\\"o|f|QZ\\\",\\\"console\\\",\\\"a|Qb\\\",\\\"o|f|Qc\\\",\\\"mdns\\\",\\\"a|Qe\\\",\\\"o|f|Qf\\\",\\\"signal\\\",\\\"a|Qh\\\",\\\"o|f|Qi\\\",\\\"npmClient\\\",\\\"a|Qk\\\",\\\"o|f|Ql\\\",\\\"a|GO\\\",\\\"o|f|Qn\\\",\\\"o|QX|Qa|Oi|Qd|Qg|Qj|Qm|Qo\\\",\\\"a|QY|Og|Qb|Qe|Qh|Qk|GO\\\",\\\"AppServe\\\",\\\"o|t|Qr|v|z|\\\",\\\"o|t|Mk|14|z|\\\",\\\"o|t|Mk|2S|z|\\\",\\\"o|t|Mk|4J|z|\\\",\\\"o|t|1D|4M|z|\\\",\\\"o|t|1D|4O|z|\\\",\\\"o|Qq|6h|Qs|Qt|Qu|Qv|Qw|Qx\\\",\\\"a|Qr|Mk\\\",\\\"_serve\\\",\\\"a|R0\\\",\\\"serve\\\",\\\"a|R2\\\",\\\"o|f|R3\\\",\\\"o|R1|R4\\\",\\\"Serve\\\",\\\"o|t|R6|q|z|\\\",\\\"o|R3|R7\\\",\\\"a|R6\\\",\\\"_loginApp\\\",\\\"_keyPhrase\\\",\\\"a|6B|RA|RB\\\",\\\"loginApp\\\",\\\"a|RD\\\",\\\"o|f|RE\\\",\\\"keyPhrase\\\",\\\"a|RG\\\",\\\"o|f|RH\\\",\\\"o|RC|6G|RF|RI\\\",\\\"a|9|RD|RG\\\",\\\"o|RK|6h|32|4g\\\",\\\"o|1s|RJ|RL|\\\",\\\"o|R9|RM\\\",\\\"o|b|R5|R8|RN|\\\",\\\"_bin\\\",\\\"a|6u|QW|RP|6B\\\",\\\"bin\\\",\\\"a|RR\\\",\\\"o|f|RS\\\",\\\"o|RQ|6y|Qo|RT|6G\\\",\\\"a|6w|GO|RR|9\\\",\\\"o|RV|6h|32|4g|Nc\\\",\\\"o|1s|RU|RW|\\\",\\\"o|Qz|RO|RX\\\",\\\"o|b|Qp|Qy|RY|\\\",\\\"_log\\\",\\\"_storage\\\",\\\"_enableSnapshots\\\",\\\"_snapshotInterval\\\",\\\"_invitationExpiration\\\",\\\"_remoteSource\\\",\\\"_remoteSourceAuthenticationToken\\\",\\\"_devtoolsProxy\\\",\\\"a|Ra|Rb|Rc|Rd|Re|Rf|Rg|Rh\\\",\\\"log\\\",\\\"a|Rj\\\",\\\"o|f|Rk\\\",\\\"storage\\\",\\\"a|Rm\\\",\\\"o|f|Rn\\\",\\\"enableSnapshots\\\",\\\"a|Rp\\\",\\\"o|f|Rq\\\",\\\"snapshotInterval\\\",\\\"a|Rs\\\",\\\"o|f|Rt\\\",\\\"invitationExpiration\\\",\\\"a|Rv\\\",\\\"o|f|Rw\\\",\\\"remoteSource\\\",\\\"a|Ry\\\",\\\"o|f|Rz\\\",\\\"remoteSourceAuthenticationToken\\\",\\\"a|S1\\\",\\\"o|f|S2\\\",\\\"devtoolsProxy\\\",\\\"a|S4\\\",\\\"o|f|S5\\\",\\\"o|Ri|Rl|Ro|Rr|Ru|Rx|S0|S3|S6\\\",\\\"a|Rj|Rm|Rp|Rs|Rv|Ry|S1|S4\\\",\\\"Log\\\",\\\"o|t|S9|q|z|\\\",\\\"Storage\\\",\\\"o|t|SB|v|z|\\\",\\\"Milliseconds\\\",\\\"o|t|1z|2S|z|SD\\\",\\\"o|t|1z|4J|z|SD\\\",\\\"Connect to and serve client services to a remote proxy.\\\",\\\"o|t|1D|4O|z|SG\\\",\\\"o|S8|SA|SC|PW|SE|SF|Qw|Nb|SH\\\",\\\"a|S9|SB\\\",\\\"_filter\\\",\\\"_prefix\\\",\\\"a|SK|SL\\\",\\\"filter\\\",\\\"a|SN\\\",\\\"o|f|SO\\\",\\\"prefix\\\",\\\"a|SQ\\\",\\\"o|f|SR\\\",\\\"o|SM|SP|SS\\\",\\\"a|SN|SQ\\\",\\\"LOG_FILTER\\\",\\\"o|Pw|SV|y\\\",\\\"o|t|1D|q|SW|\\\",\\\"LOG_PREFIX\\\",\\\"o|Pw|SY|y\\\",\\\"o|t|1D|v|SZ|\\\",\\\"o|SU|SX|Sa\\\",\\\"o|1s|ST|Sb|\\\",\\\"_keyStore\\\",\\\"_dataStore\\\",\\\"_dataRoot\\\",\\\"_spaceFragmentation\\\",\\\"a|BF|Sd|Se|Sf|Sg\\\",\\\"keyStore\\\",\\\"a|Si\\\",\\\"o|f|Sj\\\",\\\"dataStore\\\",\\\"a|Sl\\\",\\\"o|f|Sm\\\",\\\"dataRoot\\\",\\\"a|So\\\",\\\"o|f|Sp\\\",\\\"spaceFragmentation\\\",\\\"a|Sr\\\",\\\"o|f|Ss\\\",\\\"o|Sh|BZ|Sk|Sn|Sq|St\\\",\\\"a|BX|Si|Sl|So|Sr\\\",\\\"StorageDriver\\\",\\\"o|t|Sw|v|z|\\\",\\\"o|t|Sw|14|z|\\\",\\\"@deprecated\\\",\\\"o|t|97|4J|z|Sz\\\",\\\"o|Sv|98|Sx|Sy|Nc|T0\\\",\\\"a|Sw\\\",\\\"RAM\\\",\\\"IDB\\\",\\\"CHROME\\\",\\\"FIREFOX\\\",\\\"WEBFS\\\",\\\"LEVELJS\\\",\\\"JSONDOWN\\\",\\\"a|T3|T4|T5|T6|GH|T7|T8|T9\\\",\\\"o|TA|1R|q|v|14|2S|4J|CO|CR\\\",\\\"o|TA||||||||\\\",\\\"o|1N|TB||TC\\\",\\\"o|T2|TD\\\",\\\"o|b|Su|T1|TE|\\\",\\\"o|SJ|Sc|TF\\\",\\\"o|b|S7|SI|TG|\\\",\\\"a|N5|Eu\\\",\\\"o|TI|NE|F1\\\",\\\"a|5K|N\\\",\\\"o|TK|6h|32\\\",\\\"o|1s|TJ|TL|\\\",\\\"host\\\",\\\"autoupdate\\\",\\\"https\\\",\\\"p2p\\\",\\\"confhost\\\",\\\"alias\\\",\\\"monitoring\\\",\\\"trace\\\",\\\"telemetry\\\",\\\"appTunneling\\\",\\\"ipfsApiAuthorizations\\\",\\\"a|TN|1v|TO|TP|TQ|TR|O0|TS|TT|TU|TV|D|TW|5w|TX\\\",\\\"Autoupdate\\\",\\\"o|o|TZ|14|\\\",\\\"Https\\\",\\\"o|o|Tb|2S|\\\",\\\"P2P\\\",\\\"o|o|Td|4J|\\\",\\\"o|o|1D|4M|\\\",\\\"o|12|13|1D|4O|\\\",\\\"o|12|13|1D|CF|\\\",\\\"Monitoring\\\",\\\"o|o|Ti|CI|\\\",\\\"Trace\\\",\\\"o|o|Tk|CL|\\\",\\\"Telemetry\\\",\\\"o|o|Tm|CO|\\\",\\\"Gravity\\\",\\\"o|o|To|CR|\\\",\\\"AppTunneling\\\",\\\"o|o|Tq|CU|\\\",\\\"Bots\\\",\\\"o|o|Ts|CW|\\\",\\\"KuboApiAuthorization\\\",\\\"o|12|13|Tu|CY|\\\",\\\"o|TY|1j|2i|Ta|Tc|Te|Tf|Tg|Th|Tj|Tl|Tn|Tp|Tr|Tt|Tv\\\",\\\"a|Tq|TZ|Ts|To|Tb|Tu|Ti|Td|Tm|Tk\\\",\\\"commandTemplate\\\",\\\"outputRe\\\",\\\"a|PR|Ty|Tz|1v\\\",\\\"o|o|97|q|\\\",\\\"o|o|1D|2S|\\\",\\\"o|U0|U1|2i|1I|U2\\\",\\\"o|18|U3|\\\",\\\"a|PR|Ht\\\",\\\"Seconds\\\",\\\"o|o|1z|v|U6\\\",\\\"o|U5|U1|U7\\\",\\\"o|18|U8|\\\",\\\"Refresh interval - Seconds\\\",\\\"o|o|1z|v|UA\\\",\\\"o|U5|U1|UB\\\",\\\"o|18|UC|\\\",\\\"_logDir\\\",\\\"a|UE\\\",\\\"logDir\\\",\\\"a|UG\\\",\\\"o|f|UH\\\",\\\"o|UF|UI\\\",\\\"disabled\\\",\\\"a|UK|5K|UG\\\",\\\"o|UL|U1|2i|4g\\\",\\\"o|1s|UJ|UM|\\\",\\\"email\\\",\\\"certfile\\\",\\\"keyfile\\\",\\\"dnsprovider\\\",\\\"a|PR|1v|UO|UP|UQ|UR\\\",\\\"o|o|1D|4J|\\\",\\\"o|US|U1|2i|1I|U2|UT|Tf\\\",\\\"o|18|UU|\\\",\\\"authSecret\\\",\\\"allowedPaths\\\",\\\"a|5K|UW|UX\\\",\\\"Just for organizational purposes.\\\",\\\"o|o|1D|q|UZ\\\",\\\"o|12|13|1D|14|\\\",\\\"o|UY|Ua|2i|Ub\\\",\\\"https://github.com/ipfs/kubo/blob/master/docs/config.md#apiauthorizations\\\",\\\"o|18|Uc|Ud\\\",\\\"a|PR|35|Ht\\\",\\\"o|o|1z|14|U6\\\",\\\"o|Uf|U1|2i|Ug\\\",\\\"o|18|Uh|\\\",\\\"privatekey\\\",\\\"bootstrap\\\",\\\"a|Uj|1v|Uk\\\",\\\"o|Ul|1j|2i|Ub\\\",\\\"o|18|Um|\\\",\\\"a|UK|NX\\\",\\\"o|12|13|1D|v|\\\",\\\"o|Uo|U1|Up\\\",\\\"o|18|Uq|\\\",\\\"a|UK\\\",\\\"o|Us|U1\\\",\\\"o|18|Ut|\\\",\\\"o|Tx|U4|U9|UD|UN|UV|Ue|Ui|Un|Ur|Uu\\\",\\\"o|En|Tw|Uv|\\\",\\\"_title\\\",\\\"a|Ux\\\",\\\"title\\\",\\\"a|Uz\\\",\\\"o|f|V0\\\",\\\"o|Uy|V1\\\",\\\"o|V0|6h\\\",\\\"o|1s|V2|V3|\\\",\\\"_dxns\\\",\\\"_ipfs\\\",\\\"_machine\\\",\\\"_bot\\\",\\\"_publisher\\\",\\\"_supervisor\\\",\\\"_tunneling\\\",\\\"_faasd\\\",\\\"_agentHosting\\\",\\\"a|Ob|OW|V5|V6|V7|V8|V9|VA|VB|VC|VD\\\",\\\"dxns\\\",\\\"a|VF\\\",\\\"o|f|VG\\\",\\\"ipfs\\\",\\\"a|VI\\\",\\\"o|f|VJ\\\",\\\"machine\\\",\\\"a|VL\\\",\\\"o|f|VM\\\",\\\"a|7\\\",\\\"o|f|VO\\\",\\\"publisher\\\",\\\"a|VQ\\\",\\\"o|f|VR\\\",\\\"supervisor\\\",\\\"a|VT\\\",\\\"o|f|VU\\\",\\\"tunneling\\\",\\\"a|VW\\\",\\\"o|f|VX\\\",\\\"faasd\\\",\\\"a|VZ\\\",\\\"o|f|Va\\\",\\\"agentHosting\\\",\\\"a|Vc\\\",\\\"o|f|Vd\\\",\\\"o|VE|Ov|Oi|VH|VK|VN|VP|VS|VV|VY|Vb|Ve\\\",\\\"ice\\\",\\\"a|Ot|Og|VF|VI|FN|Vg|VL|7|VQ|VT|VW|VZ|Vc\\\",\\\"o|t|PC|q|z|\\\",\\\"AppServer\\\",\\\"o|t|Vj|v|z|\\\",\\\"Dxns\\\",\\\"o|t|Vl|14|z|\\\",\\\"Ipfs\\\",\\\"o|t|Vn|2S|z|\\\",\\\"o|12|13|FR|4J|\\\",\\\"Ice\\\",\\\"o|12|13|Vq|4M|\\\",\\\"Machine\\\",\\\"o|t|Vs|4O|z|\\\",\\\"BotHost\\\",\\\"o|t|Vu|CF|z|\\\",\\\"Publisher\\\",\\\"o|t|Vw|CI|z|\\\",\\\"Supervisor\\\",\\\"o|t|Vy|CL|z|\\\",\\\"Tunneling\\\",\\\"o|t|W0|CO|z|\\\",\\\"Faasd\\\",\\\"o|t|W2|CR|z|\\\",\\\"AgentHosting\\\",\\\"o|t|W4|CU|z|\\\",\\\"o|Vh|Vi|Vk|Vm|Vo|Vp|Vr|Vt|Vv|Vx|Vz|W1|W3|W5\\\",\\\"a|W4|Vj|Vu|Vl|W2|Vq|Vn|PC|Vs|Vw|FR|Vy|W0\\\",\\\"_server\\\",\\\"a|W8|N6\\\",\\\"a|FX\\\",\\\"o|f|WA\\\",\\\"o|W9|WB|NG\\\",\\\"a|FX|M\\\",\\\"o|WD|6h|32\\\",\\\"o|1s|WC|WE|\\\",\\\"a|SL|W8\\\",\\\"o|WG|SS|WB\\\",\\\"a|SQ|FX\\\",\\\"o|WI|6h|32\\\",\\\"o|1s|WH|WJ|\\\",\\\"_proxy\\\",\\\"a|WL\\\",\\\"proxy\\\",\\\"a|WN\\\",\\\"o|f|WO\\\",\\\"o|WM|WP\\\",\\\"o|WO|6h\\\",\\\"o|1s|WQ|WR|\\\",\\\"_accountUri\\\",\\\"_address\\\",\\\"_account\\\",\\\"_faucet\\\",\\\"a|W8|WT|WU|WV|WW\\\",\\\"accountUri\\\",\\\"a|WY\\\",\\\"o|f|WZ\\\",\\\"address\\\",\\\"a|Wb\\\",\\\"o|f|Wc\\\",\\\"account\\\",\\\"a|We\\\",\\\"o|f|Wf\\\",\\\"faucet\\\",\\\"a|Wh\\\",\\\"o|f|Wi\\\",\\\"o|WX|WB|Wa|Wd|Wg|Wj\\\",\\\"a|FX|WY|Wb|We|Wh\\\",\\\"DXNS endpoint.\\\",\\\"o|t|1D|q|z|Wm\\\",\\\"Substrate account URI. This is a secret.\\\\nKUBEs do not serve this with the config but we store it in profile.yml.\\\\n\\\\nTODO(dmaretskyi): Deprecate this and move it to keyring.\\\",\\\"o|t|1D|v|z|Wo\\\",\\\"Public Polkadot Address.\\\",\\\"o|t|1D|14|z|Wq\\\",\\\"Public address of a DXNS Account.\\\",\\\"o|t|1D|2S|z|Ws\\\",\\\"o|t|1D|4J|z|\\\",\\\"o|Wl|Wn|Wp|Wr|Wt|Wu\\\",\\\"o|1s|Wk|Wv|\\\",\\\"_gateway\\\",\\\"_username\\\",\\\"_password\\\",\\\"a|Wx|Wy|Wz\\\",\\\"gateway\\\",\\\"a|X1\\\",\\\"o|f|X2\\\",\\\"username\\\",\\\"a|X4\\\",\\\"o|f|X5\\\",\\\"password\\\",\\\"a|X7\\\",\\\"o|f|X8\\\",\\\"o|X0|X3|X6|X9\\\",\\\"a|X1|X4|X7\\\",\\\"o|XB|6h|32|4g\\\",\\\"o|1s|XA|XC|\\\",\\\"_urls\\\",\\\"_credential\\\",\\\"a|XE|Wy|XF\\\",\\\"urls\\\",\\\"a|XH\\\",\\\"o|f|XI\\\",\\\"credential\\\",\\\"a|XK\\\",\\\"o|f|XL\\\",\\\"o|XG|XJ|X6|XM\\\",\\\"a|XH|X4|XK\\\",\\\"o|XO|6h|32|4g\\\",\\\"o|1s|XN|XP|\\\",\\\"_serverAuthSecret\\\",\\\"a|W8|Wx|XR\\\",\\\"serverAuthSecret\\\",\\\"a|XT\\\",\\\"o|f|XU\\\",\\\"o|XS|WB|X3|XV\\\",\\\"a|FX|X1|XT\\\",\\\"Same secret format as https://github.com/ipfs/kubo/blob/master/docs/config.md#apiauthorizations\\\",\\\"o|t|1D|14|z|XY\\\",\\\"o|XX|6h|32|XZ\\\",\\\"o|1s|XW|Xa|\\\",\\\"_endpoints\\\",\\\"a|Xc|Pf\\\",\\\"endpoints\\\",\\\"a|Xe\\\",\\\"o|f|Xf\\\",\\\"o|Xd|Xg|Ps\\\",\\\"a|Xe|Pq\\\",\\\"Endpoints\\\",\\\"o|t|Xj|q|z|\\\",\\\"o|Xi|Xk|32\\\",\\\"a|Xj\\\",\\\"_logs\\\",\\\"_cert\\\",\\\"a|Xn|OZ|Xo\\\",\\\"logs\\\",\\\"a|Xq\\\",\\\"o|f|Xr\\\",\\\"cert\\\",\\\"a|Xt\\\",\\\"o|f|Xu\\\",\\\"o|Xp|Xs|Op|Xv\\\",\\\"a|Xq|7B|Xt\\\",\\\"o|Xx|6h|32|4g\\\",\\\"o|1s|Xw|Xy|\\\",\\\"o|Xm|Xz\\\",\\\"o|b|Xh|Xl|Y0|\\\",\\\"_doAccessToken\\\",\\\"_githubAccessToken\\\",\\\"_githubUsername\\\",\\\"_dnsDomain\\\",\\\"_npmAccessToken\\\",\\\"a|Y2|Y3|Y4|Y5|Y6\\\",\\\"doAccessToken\\\",\\\"a|Y8\\\",\\\"o|f|Y9\\\",\\\"githubAccessToken\\\",\\\"a|YB\\\",\\\"o|f|YC\\\",\\\"githubUsername\\\",\\\"a|YE\\\",\\\"o|f|YF\\\",\\\"dnsDomain\\\",\\\"a|YH\\\",\\\"o|f|YI\\\",\\\"npmAccessToken\\\",\\\"a|YK\\\",\\\"o|f|YL\\\",\\\"o|Y7|YA|YD|YG|YJ|YM\\\",\\\"a|Y8|YB|YE|YH|YK\\\",\\\"o|YO|6h|32|4g|Nc|Wu\\\",\\\"o|1s|YN|YP|\\\",\\\"a|W8\\\",\\\"o|YR|WB\\\",\\\"o|WA|6h\\\",\\\"o|1s|YS|YT|\\\",\\\"_api\\\",\\\"a|YV|3c\\\",\\\"api\\\",\\\"a|YX\\\",\\\"o|f|YY\\\",\\\"o|YW|YZ|3l\\\",\\\"a|FX|YX|k\\\",\\\"o|Yb|1j|32|4g\\\",\\\"o|1s|Ya|Yc|\\\",\\\"o|W7|WF|WK|WS|Ww|XD|XQ|Xb|Y1|YQ|YU|Yd|YU|YU\\\",\\\"o|b|Vf|W6|Ye|\\\",\\\"_debug\\\",\\\"a|Yg\\\",\\\"debug\\\",\\\"a|Yi\\\",\\\"o|f|Yj\\\",\\\"o|Yh|Yk\\\",\\\"o|Yj|6h\\\",\\\"o|1s|Yl|Ym|\\\",\\\"o|PJ|Pb|QQ|RZ|TH|TM|Uw|V4|Yf|Yn\\\",\\\"o|b|Oy|PI|Yo|\\\",\\\"o|Mm|Mo|Mz|N4|O9|OL|OU|Yp\\\",\\\"o|Mc|Mg|Yq\\\",\\\"a|TN|FM\\\",\\\"ClearSnapshotsRequest\\\",\\\"DevtoolsHost\\\",\\\"DisableDebugLoggingRequest\\\",\\\"DisableDebugLoggingResponse\\\",\\\"EnableDebugLoggingRequest\\\",\\\"EnableDebugLoggingResponse\\\",\\\"Event\\\",\\\"FeedStats\\\",\\\"GetBlobsResponse\\\",\\\"GetConfigResponse\\\",\\\"GetNetworkPeersRequest\\\",\\\"GetNetworkPeersResponse\\\",\\\"GetSnapshotsResponse\\\",\\\"GetSpaceSnapshotRequest\\\",\\\"GetSpaceSnapshotResponse\\\",\\\"PeerStats\\\",\\\"ReadyEvent\\\",\\\"ResetStorageRequest\\\",\\\"SaveSpaceSnapshotRequest\\\",\\\"SaveSpaceSnapshotResponse\\\",\\\"SignalResponse\\\",\\\"SpaceStats\\\",\\\"StorageInfo\\\",\\\"StoredSnapshotInfo\\\",\\\"SubscribeToCredentialMessagesRequest\\\",\\\"SubscribeToCredentialMessagesResponse\\\",\\\"SubscribeToFeedBlocksRequest\\\",\\\"SubscribeToFeedBlocksResponse\\\",\\\"SubscribeToFeedsRequest\\\",\\\"SubscribeToFeedsResponse\\\",\\\"SubscribeToItemsRequest\\\",\\\"SubscribeToItemsResponse\\\",\\\"SubscribeToKeyringKeysRequest\\\",\\\"SubscribeToKeyringKeysResponse\\\",\\\"SubscribeToMetadataResponse\\\",\\\"SubscribeToNetworkTopicsResponse\\\",\\\"SubscribeToSignalStatusResponse\\\",\\\"SubscribeToSpacesRequest\\\",\\\"SubscribeToSpacesResponse\\\",\\\"SubscribeToSwarmInfoRequest\\\",\\\"SubscribeToSwarmInfoResponse\\\",\\\"a|Yt|Yu|Yv|Yw|Yx|Yy|Yz|Z0|Z1|Z2|Z3|Z4|Z5|Z6|Z7|Z8|Z9|ZA|ZB|ZC|P8|ZD|ZE|ZF|ZG|ZH|ZI|ZJ|ZK|ZL|ZM|ZN|ZO|ZP|ZQ|ZR|ZS|ZT|ZU|ZV|ZW|ZX\\\",\\\"o|\\\",\\\"o|18|ZZ|\\\",\\\"Events\\\",\\\"GetStorageInfo\\\",\\\"ResetStorage\\\",\\\"GetBlobs\\\",\\\"GetSnapshots\\\",\\\"EnableDebugLogging\\\",\\\"DisableDebugLogging\\\",\\\"SubscribeToKeyringKeys\\\",\\\"SubscribeToCredentialMessages\\\",\\\"SubscribeToSpaces\\\",\\\"SubscribeToItems\\\",\\\"SubscribeToFeeds\\\",\\\"SubscribeToFeedBlocks\\\",\\\"SubscribeToMetadata\\\",\\\"GetSpaceSnapshot\\\",\\\"SaveSpaceSnapshot\\\",\\\"ClearSnapshots\\\",\\\"GetNetworkPeers\\\",\\\"SubscribeToNetworkTopics\\\",\\\"SubscribeToSignalStatus\\\",\\\"SubscribeToSignal\\\",\\\"SubscribeToSwarmInfo\\\",\\\"a|Zb|Ll|Zc|Zd|Ze|Zf|Zg|Zh|Zi|Zj|Zk|Zl|Zm|Zn|Zo|Zp|Zq|Zr|Zs|Zt|Zu|Zv|Zw\\\",\\\"o|1d|1e|Yz|y|\\\",\\\"o|2p|1e|Z2|\\\",\\\"o|2p|1e|ZF|\\\",\\\"o|2p|ZA|1e|\\\",\\\"o|2p|1e|Z1|\\\",\\\"o|2p|1e|Z5|\\\",\\\"o|2p|Yx|Yy|\\\",\\\"o|1d|ZP|ZQ|y|\\\",\\\"o|1d|ZH|ZI|y|\\\",\\\"o|1d|ZU|ZV|y|\\\",\\\"o|1d|ZN|ZO|y|\\\",\\\"o|1d|ZL|ZM|y|\\\",\\\"o|1d|ZJ|ZK|y|\\\",\\\"o|1d|1e|ZR|y|\\\",\\\"o|2p|Z6|Z7|\\\",\\\"o|2p|ZB|ZC|\\\",\\\"o|2p|Yt|1e|\\\",\\\"o|2p|Z3|Z4|\\\",\\\"o|1d|1e|ZS|y|\\\",\\\"o|1d|1e|ZT|y|\\\",\\\"o|1d|1e|ZD|y|\\\",\\\"o|1d|ZW|ZX|y|\\\",\\\"o|Zx|Zy|Zz|a0|a1|a2|a3|a4|a4|a5|a6|a7|a8|a9|aA|aB|aC|aD|aE|aF|aG|aH|aI|aJ\\\",\\\"o|1Y|aK|\\\",\\\"_namespaces\\\",\\\"a|aM\\\",\\\"namespaces\\\",\\\"a|aO\\\",\\\"o|f|aP\\\",\\\"o|aN|aQ\\\",\\\"o|aP|6h\\\",\\\"o|1s|aR|aS|\\\",\\\"_enabledNamespaces\\\",\\\"a|aU\\\",\\\"enabledNamespaces\\\",\\\"a|aW\\\",\\\"o|f|aX\\\",\\\"o|aV|aY\\\",\\\"o|aX|6h\\\",\\\"o|1s|aZ|aa|\\\",\\\"payload\\\",\\\"a|ac\\\",\\\"o|5J|JH|\\\",\\\"o|ad|ae\\\",\\\"o|o|Z9|q|\\\",\\\"o|JH|ag\\\",\\\"o|1s|af|ah|\\\",\\\"length\\\",\\\"a|Ex|aj\\\",\\\"o|ak|8Q|ER\\\",\\\"o|18|al|\\\",\\\"blobs\\\",\\\"a|an\\\",\\\"dxos.echo.blob.BlobMeta\\\",\\\"o|12|13|ap|q|\\\",\\\"o|ao|aq\\\",\\\"o|18|ar|\\\",\\\"o|6F|1j\\\",\\\"o|18|at|\\\",\\\"topic\\\",\\\"a|av\\\",\\\"o|aw|68\\\",\\\"o|18|ax|\\\",\\\"peers\\\",\\\"a|az\\\",\\\"PeerInfo\\\",\\\"o|12|13|b1|q|\\\",\\\"o|b0|b2\\\",\\\"a|b1\\\",\\\"connections\\\",\\\"a|n|Bv|b5\\\",\\\"o|12|13|67|14|\\\",\\\"o|b6|8Q|2i|b7\\\",\\\"o|18|b8|\\\",\\\"o|b4|b9\\\",\\\"o|En|b3|bA|\\\",\\\"snapshots\\\",\\\"a|bC\\\",\\\"o|12|13|ZG|q|\\\",\\\"o|bD|bE\\\",\\\"o|18|bF|\\\",\\\"o|3z|8Q\\\",\\\"o|18|bH|\\\",\\\"_snapshot\\\",\\\"a|bJ\\\",\\\"snapshot\\\",\\\"a|bL\\\",\\\"o|f|bM\\\",\\\"o|bK|bN\\\",\\\"dxos.echo.snapshot.SpaceSnapshot\\\",\\\"o|t|bP|q|z|\\\",\\\"o|bM|bQ\\\",\\\"o|1s|bO|bR|\\\",\\\"controlFeed\\\",\\\"dataFeed\\\",\\\"a|bT|bU\\\",\\\"o|o|Z0|q|\\\",\\\"o|o|Z0|v|\\\",\\\"o|bV|bW|bX\\\",\\\"o|18|bY|\\\",\\\"o|12|13|ZE|q|\\\",\\\"o|I5|ba\\\",\\\"o|18|bb|\\\",\\\"data\\\",\\\"_topic\\\",\\\"a|bd|be\\\",\\\"swarmEvent\\\",\\\"a|bg|E3\\\",\\\"o|5J|bh|\\\",\\\"o|f|aw\\\",\\\"o|bf|bi|bj\\\",\\\"receivedAt\\\",\\\"a|bg|E3|bl|av\\\",\\\"dxos.mesh.signal.SwarmEvent\\\",\\\"o|o|bn|q|\\\",\\\"dxos.mesh.signal.Message\\\",\\\"o|o|bp|v|\\\",\\\"o|o|4G|14|\\\",\\\"o|t|67|2S|z|\\\",\\\"o|bm|bo|bq|br|bs\\\",\\\"o|1s|bk|bt|\\\",\\\"a|Ex|az\\\",\\\"o|12|13|Z8|v|\\\",\\\"o|bv|8Q|bw\\\",\\\"o|18|bx|\\\",\\\"storageUsage\\\",\\\"originUsage\\\",\\\"usageQuota\\\",\\\"a|M|bz|c0|c1\\\",\\\"o|o|G8|v|\\\",\\\"o|o|G8|14|\\\",\\\"o|o|G8|2S|\\\",\\\"o|c2|1j|c3|c4|c5\\\",\\\"o|18|c6|\\\",\\\"size\\\",\\\"a|Ex|c8\\\",\\\"o|c9|1j|c3\\\",\\\"o|18|cA|\\\",\\\"a|3h\\\",\\\"o|cC|40\\\",\\\"o|3z|KN\\\",\\\"o|1s|cD|cE|\\\",\\\"messages\\\",\\\"a|cG\\\",\\\"dxos.halo.signed.SignedMessage\\\",\\\"o|12|13|cI|q|\\\",\\\"o|cH|cJ\\\",\\\"o|18|cK|\\\",\\\"_feedKey\\\",\\\"_maxBlocks\\\",\\\"a|3h|cM|cN\\\",\\\"feedKey\\\",\\\"a|cP\\\",\\\"o|f|cQ\\\",\\\"maxBlocks\\\",\\\"a|cS\\\",\\\"o|f|cT\\\",\\\"o|cO|40|cR|cU\\\",\\\"a|3y|cP|cS\\\",\\\"o|cW|KN|At|2R\\\",\\\"o|1s|cV|cX|\\\",\\\"blocks\\\",\\\"a|cZ\\\",\\\"Block\\\",\\\"o|12|13|cb|q|\\\",\\\"o|ca|cc\\\",\\\"a|cb\\\",\\\"seq\\\",\\\"a|cP|cf|bd\\\",\\\"dxos.echo.feed.FeedMessage\\\",\\\"o|o|ch|14|\\\",\\\"o|cg|8Q|ER|ci\\\",\\\"o|18|cj|\\\",\\\"o|ce|ck\\\",\\\"o|En|cd|cl|\\\",\\\"feedKeys\\\",\\\"a|cn\\\",\\\"o|12|13|4I|q|\\\",\\\"o|co|cp\\\",\\\"o|18|cq|\\\",\\\"feeds\\\",\\\"a|cs\\\",\\\"Feed\\\",\\\"o|12|13|cu|q|\\\",\\\"o|ct|cv\\\",\\\"a|cu\\\",\\\"downloaded\\\",\\\"a|cP|aj|67|cy\\\",\\\"o|o|1z|14|\\\",\\\"Bitfield of downloaded blocks.\\\",\\\"o|o|67|2S|d1\\\",\\\"o|cz|8Q|ER|d0|d2\\\",\\\"o|18|d3|\\\",\\\"o|cx|d4\\\",\\\"o|En|cw|d5|\\\",\\\"a|bd\\\",\\\"o|d7|1j\\\",\\\"o|18|d8|\\\",\\\"dxos.halo.keyring.KeyRecord\\\",\\\"o|12|13|dA|q|\\\",\\\"o|AS|dB\\\",\\\"o|18|dC|\\\",\\\"metadata\\\",\\\"a|dE\\\",\\\"dxos.echo.metadata.EchoMetadata\\\",\\\"o|o|dG|q|\\\",\\\"o|dF|dH\\\",\\\"o|18|dI|\\\",\\\"topics\\\",\\\"a|dK\\\",\\\"Topic\\\",\\\"o|12|13|dM|q|\\\",\\\"o|dL|dN\\\",\\\"a|dM\\\",\\\"_label\\\",\\\"a|dQ\\\",\\\"label\\\",\\\"a|dS\\\",\\\"o|f|dT\\\",\\\"o|dR|dU\\\",\\\"a|av|dS\\\",\\\"o|dW|8Q|32\\\",\\\"o|1s|dV|dX|\\\",\\\"o|dP|dY\\\",\\\"o|En|dO|dZ|\\\",\\\"servers\\\",\\\"a|db\\\",\\\"SignalServer\\\",\\\"o|12|13|dd|q|\\\",\\\"o|dc|de\\\",\\\"a|dd\\\",\\\"a|4U\\\",\\\"o|dh|4d\\\",\\\"reconnectIn\\\",\\\"connectionStarted\\\",\\\"lastStateChange\\\",\\\"a|TN|Bv|C|dj|dk|dl\\\",\\\"o|o|1z|2S|\\\",\\\"o|o|4G|4J|\\\",\\\"o|dm|1j|Fa|4g|dn|do|EB\\\",\\\"o|1s|di|dp|\\\",\\\"o|dg|dq\\\",\\\"o|En|df|dr|\\\",\\\"spaceKeys\\\",\\\"a|dt\\\",\\\"o|du|cp\\\",\\\"o|18|dv|\\\",\\\"SpaceInfo\\\",\\\"o|12|13|dx|q|\\\",\\\"o|I5|dy\\\",\\\"a|dx\\\",\\\"_timeframe\\\",\\\"a|e1\\\",\\\"timeframe\\\",\\\"a|e3\\\",\\\"o|f|e4\\\",\\\"o|e2|e5\\\",\\\"isOpen\\\",\\\"genesisFeed\\\",\\\"a|Ex|e7|e3|e8|bT|bU\\\",\\\"o|o|97|v|\\\",\\\"o|t|5a|14|z|\\\",\\\"o|o|4I|2S|\\\",\\\"o|o|4I|4J|\\\",\\\"o|o|4I|4M|\\\",\\\"o|e9|8Q|eA|eB|eC|eD|eE\\\",\\\"o|1s|e6|eF|\\\",\\\"o|e0|eG\\\",\\\"o|En|dz|eH|\\\",\\\"o|12|13|FT|q|\\\",\\\"o|d7|eJ\\\",\\\"o|18|eK|\\\",\\\"o|ZY|Za|aL|aT|ab|aT|ab|ai|am|as|au|ay|bB|bG|bI|bS|bZ|Za|Za|bI|bS|bc|bu|by|c7|cB|cF|cL|cY|cm|cr|d6|Za|d9|Za|dD|dJ|da|ds|dw|eI|Za|eL\\\",\\\"o|1|eM\\\",\\\"ConnectionEvent\\\",\\\"ConnectionInfo\\\",\\\"SwarmInfo\\\",\\\"a|eO|eP|eQ\\\",\\\"_newState\\\",\\\"a|eS|4U\\\",\\\"newState\\\",\\\"a|eU\\\",\\\"o|f|eV\\\",\\\"o|eT|eW|4d\\\",\\\"a|M|eU|C\\\",\\\"o|eY|1j|32|4g\\\",\\\"o|1s|eX|eZ|\\\",\\\"_transport\\\",\\\"_closeReason\\\",\\\"_readBufferSize\\\",\\\"_writeBufferSize\\\",\\\"_lastUpdate\\\",\\\"_transportDetails\\\",\\\"_transportBytesSent\\\",\\\"_transportBytesReceived\\\",\\\"_transportPacketsSent\\\",\\\"_transportPacketsReceived\\\",\\\"a|eb|ec|Gi|ed|ee|ef|eg|eh|ei|ej|ek\\\",\\\"transport\\\",\\\"a|em\\\",\\\"o|f|en\\\",\\\"closeReason\\\",\\\"a|ep\\\",\\\"o|f|eq\\\",\\\"readBufferSize\\\",\\\"a|es\\\",\\\"o|f|et\\\",\\\"writeBufferSize\\\",\\\"a|ev\\\",\\\"o|f|ew\\\",\\\"lastUpdate\\\",\\\"a|ey\\\",\\\"o|f|ez\\\",\\\"transportDetails\\\",\\\"a|f1\\\",\\\"o|f|f2\\\",\\\"transportBytesSent\\\",\\\"a|f4\\\",\\\"o|f|f5\\\",\\\"transportBytesReceived\\\",\\\"a|f7\\\",\\\"o|f|f8\\\",\\\"transportPacketsSent\\\",\\\"a|fA\\\",\\\"o|f|fB\\\",\\\"transportPacketsReceived\\\",\\\"a|fD\\\",\\\"o|f|fE\\\",\\\"o|el|eo|er|Gm|eu|ex|f0|f3|f6|f9|fC|fF\\\",\\\"sessionId\\\",\\\"remotePeerId\\\",\\\"protocolExtensions\\\",\\\"events\\\",\\\"streams\\\",\\\"a|Bv|fH|fI|em|fJ|fK|fL|ep|Gk|es|ev|ey|f1|f4|f7|fA|fD\\\",\\\"o|o|4I|14|\\\",\\\"o|12|13|eO|4M|\\\",\\\"StreamStats\\\",\\\"o|12|13|fP|4O|\\\",\\\"o|t|1D|CI|z|\\\",\\\"o|t|G8|CL|z|\\\",\\\"o|t|G8|CO|z|\\\",\\\"o|t|4G|CR|z|\\\",\\\"o|t|1D|CU|z|\\\",\\\"o|t|G8|CW|z|\\\",\\\"o|t|G8|CY|z|\\\",\\\"o|t|G8|Cb|z|\\\",\\\"o|t|G8|Ce|z|\\\",\\\"o|fM|1j|MF|fN|Nc|Nd|fO|fQ|Nb|fR|fS|fT|fU|fV|fW|fX|fY|fZ\\\",\\\"a|fP\\\",\\\"_contentType\\\",\\\"_bytesSentRate\\\",\\\"_bytesReceivedRate\\\",\\\"a|fc|fd|fe|ee\\\",\\\"contentType\\\",\\\"a|fg\\\",\\\"o|f|fh\\\",\\\"bytesSentRate\\\",\\\"a|fj\\\",\\\"o|f|fk\\\",\\\"bytesReceivedRate\\\",\\\"a|fm\\\",\\\"o|f|fn\\\",\\\"o|ff|fi|fl|fo|ex\\\",\\\"bytesSent\\\",\\\"bytesReceived\\\",\\\"a|n|Nx|fg|fq|fr|fj|fm|ev\\\",\\\"o|o|G8|q|\\\",\\\"o|t|G8|4M|z|\\\",\\\"o|t|G8|4O|z|\\\",\\\"o|t|G8|CF|z|\\\",\\\"o|fs|ft|2i|Wu|c4|c5|fu|fv|fw\\\",\\\"o|1s|fp|fx|\\\",\\\"o|fb|fy\\\",\\\"o|b|fG|fa|fz|\\\",\\\"isActive\\\",\\\"a|n|av|dS|g1|b5\\\",\\\"o|o|97|2S|\\\",\\\"o|12|13|eP|4J|\\\",\\\"o|g2|8Q|MF|4g|g3|g4\\\",\\\"o|1s|dV|g5|\\\",\\\"o|eR|ea|g0|g6\\\",\\\"o|1|g7\\\",\\\"o|Ys|eN|g8\\\",\\\"o|1|g9\\\",\\\"blob\\\",\\\"feed\\\",\\\"indexing\\\",\\\"model\\\",\\\"object\\\",\\\"query\\\",\\\"a|gB|gC|SN|gD|dE|gE|gF|gG|K|bL|e3\\\",\\\"BlobMeta\\\",\\\"a|gI\\\",\\\"_bitfield\\\",\\\"_updated\\\",\\\"a|gK|BG|gL\\\",\\\"bitfield\\\",\\\"a|gN\\\",\\\"o|f|gO\\\",\\\"updated\\\",\\\"a|gQ\\\",\\\"o|f|gR\\\",\\\"o|gM|gP|Bc|gS\\\",\\\"chunkSize\\\",\\\"a|n|Bv|aj|gU|gN|Ba|gQ\\\",\\\"Hash of blob content.\\\",\\\"o|o|67|q|gW\\\",\\\"o|o|CA|v|\\\",\\\"Length of blob in bytes.\\\",\\\"o|o|1z|14|gZ\\\",\\\"Size of chunk in bytes. Must be a power of 2. Default is 4096.\\\",\\\"o|o|1z|2S|gb\\\",\\\"o|t|67|4J|z|\\\",\\\"o|t|4G|4O|z|\\\",\\\"o|gV|gX|gY|ga|gc|gd|JP|ge\\\",\\\"a|CA\\\",\\\"PARTIALLY_PRESENT\\\",\\\"FULLY_PRESENT\\\",\\\"a|gh|gi\\\",\\\"o|gj|1R|q\\\",\\\"o|gj||\\\",\\\"o|1N|gk||gl\\\",\\\"o|gg|gm\\\",\\\"o|b|gT|gf|gn|\\\",\\\"o|gJ|go\\\",\\\"o|1|gp\\\",\\\"CredentialsMessage\\\",\\\"DataMessage\\\",\\\"FeedMessage\\\",\\\"a|gr|gs|gt\\\",\\\"o|o|KS|q|\\\",\\\"o|XL|gv\\\",\\\"A container for dxos.credentials.Message\\\",\\\"o|18|gw|gx\\\",\\\"batch\\\",\\\"a|gz\\\",\\\"dxos.echo.object.EchoObjectBatch\\\",\\\"o|o|h1|v|\\\",\\\"o|h0|h2\\\",\\\"A container ECHO database messages in data feeds.\\\",\\\"o|18|h3|h4\\\",\\\"a|e3|ac\\\",\\\"o|o|5a|q|\\\",\\\"Payload\\\",\\\"o|o|h8|v|\\\",\\\"o|h6|h7|h9\\\",\\\"a|h8\\\",\\\"a|XK|bd\\\",\\\"o|5J|hC|\\\",\\\"o|ad|hD\\\",\\\"o|o|gr|CL|\\\",\\\"o|o|gs|CO|\\\",\\\"o|hC|hF|hG\\\",\\\"o|1s|hE|hH|\\\",\\\"o|hB|hI\\\",\\\"Outer message type decoded by Codec.\\\\nThis is what is written to the feeds.\\\",\\\"o|En|hA|hJ|hK\\\",\\\"o|gu|gy|h5|hL\\\",\\\"o|1|hM\\\",\\\"QueryOptions\\\",\\\"a|HS|hO\\\",\\\"_properties\\\",\\\"_text\\\",\\\"_not\\\",\\\"a|hQ|N6|hR|hS|HL\\\",\\\"properties\\\",\\\"a|hU\\\",\\\"o|f|hV\\\",\\\"text\\\",\\\"a|hX\\\",\\\"o|f|hY\\\",\\\"not\\\",\\\"a|ha\\\",\\\"o|f|hb\\\",\\\"o|hT|hW|NG|hZ|hc|HO\\\",\\\"and\\\",\\\"or\\\",\\\"a|hU|M|hX|ha|he|hf|s\\\",\\\"o|t|Al|q|z|\\\",\\\"dxos.echo.model.document.Reference\\\",\\\"o|t|hi|v|z|\\\",\\\"o|12|13|HS|4J|\\\",\\\"o|12|13|HS|4M|\\\",\\\"o|t|hO|4O|z|\\\",\\\"o|hg|hh|hj|4g|H3|hk|hl|hm\\\",\\\"Protocol for ephemeral Filter serialization.\\\",\\\"o|1s|hd|hn|ho\\\",\\\"_deleted\\\",\\\"_dataLocation\\\",\\\"a|hq|hr\\\",\\\"deleted\\\",\\\"a|ht\\\",\\\"o|f|hu\\\",\\\"dataLocation\\\",\\\"a|hw\\\",\\\"o|f|hx\\\",\\\"o|hs|hv|hy\\\",\\\"models\\\",\\\"a|ht|i0|I4|hw\\\",\\\"ShowDeletedOption\\\",\\\"Controls how deleted items are filtered.\\\",\\\"o|t|i2|q|z|i3\\\",\\\"Filter by model.\\\\n@default * Only DocumentModel.\\\\nTo querty all models, use `models: [\\\\\\\"*\\\\\\\"]`.\\\",\\\"o|12|13|1D|v|i5\\\",\\\"Query only in specific spaces.\\\",\\\"o|12|13|4I|14|i7\\\",\\\"DataLocation\\\",\\\"Query only local spaces, or remote on agent.\\\\n@default `QueryOptions.DataLocation.LOCAL`\\\",\\\"o|t|i9|2S|z|iA\\\",\\\"o|i1|i4|i6|i8|iB\\\",\\\"a|i9|i2\\\",\\\"ALL\\\",\\\"LOCAL\\\",\\\"REMOTE\\\",\\\"a|iE|iF|iG\\\",\\\"o|iH|1R|q|v\\\",\\\"o|iH|||\\\",\\\"o|1N|iI||iJ\\\",\\\"HIDE_DELETED\\\",\\\"SHOW_DELETED\\\",\\\"SHOW_DELETED_ONLY\\\",\\\"a|iL|iM|iN\\\",\\\"o|iO|1R|q|v\\\",\\\"Do not return deleted items. Default behaviour.\\\",\\\"Return deleted and regular items.\\\",\\\"Return only deleted items.\\\",\\\"o|iO|iQ|iR|iS\\\",\\\"o|1N|iP||iT\\\",\\\"o|iD|iK|iU\\\",\\\"o|b|hz|iC|iV|\\\",\\\"o|hP|hp|iW\\\",\\\"o|1|iX\\\",\\\"IndexConfig\\\",\\\"IndexKind\\\",\\\"a|iZ|ia\\\",\\\"a|PP\\\",\\\"o|ic|PT\\\",\\\"indexes\\\",\\\"a|ie|PR\\\",\\\"o|12|13|ia|q|\\\",\\\"Is indexing enabled (FEATURE FLAG).\\\\nIf not set, the default is false.\\\\nTODO(mykola): Delete once we promote it as a production feature.\\\",\\\"o|t|97|v|z|ih\\\",\\\"o|if|ig|ii\\\",\\\"o|1s|id|ij|\\\",\\\"_field\\\",\\\"a|il\\\",\\\"field\\\",\\\"a|in\\\",\\\"o|f|io\\\",\\\"o|im|ip\\\",\\\"a|5H|in\\\",\\\"o|o|C2|q|\\\",\\\"o|ir|is|32\\\",\\\"a|C2\\\",\\\"SCHEMA_MATCH\\\",\\\"FIELD_MATCH\\\",\\\"FULL_TEXT\\\",\\\"a|iv|iw|ix\\\",\\\"o|iy|1R|q|v\\\",\\\"o|iy|||\\\",\\\"o|1N|iz||j0\\\",\\\"o|iu|j1\\\",\\\"o|b|iq|it|j2|\\\",\\\"o|ib|ik|j3\\\",\\\"o|1|j4\\\",\\\"ControlPipelineSnapshot\\\",\\\"EchoMetadata\\\",\\\"IdentityRecord\\\",\\\"LargeSpaceMetadata\\\",\\\"SmallSpaceMetadata\\\",\\\"SpaceCache\\\",\\\"SpaceMetadata\\\",\\\"a|j6|j7|j8|j9|jA|jB|jC\\\",\\\"a|e3|cG\\\",\\\"timeframe.TimeframeVector\\\",\\\"Timeframe of the last message included in the snapshot.\\\",\\\"o|o|jF|q|jG\\\",\\\"ControlMessage\\\",\\\"o|12|13|jI|v|\\\",\\\"o|jE|jH|jJ\\\",\\\"a|jI\\\",\\\"a|cP|XK\\\",\\\"o|o|KS|v|\\\",\\\"o|jM|8Q|jN\\\",\\\"o|18|jO|\\\",\\\"o|jL|jP\\\",\\\"o|En|jK|jQ|\\\",\\\"a|Mr|Ba|gQ|Gk|I4|Dn\\\",\\\"Version number that is inceremnted every time there's a breaking change to the storage schema.\\\\nThis is used to detect if the storage schema has changed since the last time the client was run.\\\\nLoading data from a different version will might result in an error.\\\",\\\"o|o|1z|q|jT\\\",\\\"o|o|4G|v|\\\",\\\"o|t|j8|CL|z|\\\",\\\"List of the data spaces.\\\",\\\"o|12|13|jC|CO|jX\\\",\\\"o|12|13|6R|CR|\\\",\\\"o|jS|jU|jV|br|jW|jY|jZ\\\",\\\"Main metadata record.\\\",\\\"o|1s|Gn|ja|jb\\\",\\\"_profileSpace\\\",\\\"a|jd|9k\\\",\\\"profileSpace\\\",\\\"a|jf\\\",\\\"o|f|jg\\\",\\\"o|je|jh|9m\\\",\\\"haloSpace\\\",\\\"a|Ar|9y|jj|jf|8j\\\",\\\"o|o|jC|14|\\\",\\\"TODO(burdon): Not yet implemented. Must be null.\\\",\\\"o|t|jC|2S|z|jm\\\",\\\"ProfileDocument\\\",\\\"Cached profile.\\\",\\\"o|t|jo|4J|z|jp\\\",\\\"o|jk|8Q|MF|jl|jn|jq\\\",\\\"Information needed to bootstrap an Identity.\\\",\\\"o|1s|ji|jr|js\\\",\\\"_controlPipelineSnapshot\\\",\\\"a|ju\\\",\\\"controlPipelineSnapshot\\\",\\\"a|jw\\\",\\\"o|f|jx\\\",\\\"o|jv|jy\\\",\\\"o|t|j6|q|z|\\\",\\\"o|jx|k0\\\",\\\"Per-space metadata. Infrequent updates.\\\",\\\"o|1s|jz|k1|k2\\\",\\\"Per-space metadata. Frequent updates. Keep small.\\\",\\\"o|18|ZZ|k4\\\",\\\"a|hQ\\\",\\\"o|k6|hW\\\",\\\"dxos.echo.model.document.ObjectSnapshot\\\",\\\"Properties snapshot.\\\",\\\"o|t|k8|q|z|k9\\\",\\\"o|hV|kA\\\",\\\"o|1s|k7|kB|\\\",\\\"_genesisFeedKey\\\",\\\"_controlTimeframe\\\",\\\"_dataTimeframe\\\",\\\"a|MJ|kD|JS|JT|kE|kF|IT\\\",\\\"genesisFeedKey\\\",\\\"a|kH\\\",\\\"o|f|kI\\\",\\\"controlTimeframe\\\",\\\"a|kK\\\",\\\"o|f|kL\\\",\\\"dataTimeframe\\\",\\\"a|kN\\\",\\\"o|f|kO\\\",\\\"o|kG|MM|kJ|Ji|Jl|kM|kP|Id\\\",\\\"a|Ex|Bv|kH|Jg|cn|Jj|kK|kN|Ib\\\",\\\"Space key.\\\",\\\"o|o|4I|q|kS\\\",\\\"ACTIVE, INACTIVE, etc.\\\",\\\"o|t|7w|CL|z|kU\\\",\\\"o|t|4I|4M|z|\\\",\\\"Key of the wriatable control feed.\\\",\\\"o|t|4I|2S|z|kX\\\",\\\"List of all feed associated with the space.\\\",\\\"o|12|13|4I|v|kZ\\\",\\\"Key of the wriatable data feed.\\\",\\\"o|t|4I|14|z|kb\\\",\\\"o|t|jF|CF|z|\\\",\\\"o|t|jF|4J|z|\\\",\\\"o|t|jB|CI|z|\\\",\\\"o|kR|kT|kV|kW|kY|ka|kc|kd|ke|kf\\\",\\\"o|1s|kQ|kg|\\\",\\\"o|jD|jR|jc|jt|k3|k5|kC|kh\\\",\\\"o|1|ki\\\",\\\"document\\\",\\\"messenger\\\",\\\"a|kk|kl|hX\\\",\\\"Array\\\",\\\"KeyValue\\\",\\\"KeyValueObject\\\",\\\"ObjectMutation\\\",\\\"ObjectMutationSet\\\",\\\"ObjectSnapshot\\\",\\\"Predicate\\\",\\\"Query\\\",\\\"Reference\\\",\\\"Value\\\",\\\"YJS\\\",\\\"a|kn|ko|kp|kq|kr|ks|kt|ku|kv|kw|kx\\\",\\\"a|1L\\\",\\\"o|12|13|kw|q|\\\",\\\"o|kz|l0\\\",\\\"Ordered collection of values.\\\",\\\"o|18|l1|l2\\\",\\\"a|Ex|N\\\",\\\"o|o|kw|v|\\\",\\\"o|l4|1j|l5\\\",\\\"Key x Value tuple.\\\",\\\"o|18|l6|l7\\\",\\\"o|12|13|ko|q|\\\",\\\"o|hV|l9\\\",\\\"Object data definition.\\\",\\\"o|18|lA|lB\\\",\\\"_mutation\\\",\\\"a|Eu|lD\\\",\\\"mutation\\\",\\\"a|lF\\\",\\\"o|f|lG\\\",\\\"o|lE|F1|lH\\\",\\\"operation\\\",\\\"a|lJ|Ex|N|lF\\\",\\\"Operation\\\",\\\"o|o|lL|q|\\\",\\\"o|t|kw|14|z|\\\",\\\"o|t|kx|2S|z|\\\",\\\"o|lK|lM|2i|lN|lO\\\",\\\"a|lL\\\",\\\"SET\\\",\\\"DELETE\\\",\\\"ARRAY_PUSH\\\",\\\"SET_ADD\\\",\\\"SET_DELETE\\\",\\\"a|lR|lS|lT|lU|lV|kx\\\",\\\"o|lW|1R|q|v|2S|4J|4M\\\",\\\"o|lW||||||\\\",\\\"o|1N|lX||lY\\\",\\\"o|lQ|lZ\\\",\\\"Atomic mutation.\\\",\\\"o|b|lI|lP|la|lb\\\",\\\"_typeRef\\\",\\\"a|N6|ld\\\",\\\"typeRef\\\",\\\"a|lf\\\",\\\"o|f|lg\\\",\\\"o|le|NG|lh\\\",\\\"mutations\\\",\\\"metaMutations\\\",\\\"a|M|lf|lj|lk\\\",\\\"o|t|kv|2S|z|\\\",\\\"o|12|13|kq|v|\\\",\\\"o|12|13|kq|14|\\\",\\\"o|ll|6h|lm|ln|lo\\\",\\\"Set of mutations.\\\",\\\"o|1s|li|lp|lq\\\",\\\"a|N6|ld|Dt\\\",\\\"o|ls|NG|lh|E0\\\",\\\"root\\\",\\\"a|M|lf|lu|Dy\\\",\\\"o|lv|6h|lm|l5|lN\\\",\\\"State snapshot.\\\",\\\"o|1s|lt|lw|lx\\\",\\\"a|Et|Eu\\\",\\\"o|lz|Ez|F1\\\",\\\"op\\\",\\\"predicates\\\",\\\"a|m1|Ex|N|m2\\\",\\\"o|12|13|kt|2S|\\\",\\\"o|m3|lM|32|lN|m4\\\",\\\"OR\\\",\\\"AND\\\",\\\"NOT\\\",\\\"IN\\\",\\\"EQUALS\\\",\\\"GTE\\\",\\\"GT\\\",\\\"LTE\\\",\\\"LT\\\",\\\"PREFIX_MATCH\\\",\\\"TEXT_MATCH\\\",\\\"a|m6|m7|m8|m9|mA|mB|mC|mD|mE|mF|mG\\\",\\\"o|mH|1R|q|v|CL|CO|CR|CU|CW|CY|Io|Iq\\\",\\\"o|mH|||||||||||\\\",\\\"o|1N|mI||mJ\\\",\\\"o|lQ|mK\\\",\\\"Query predicate.\\\",\\\"o|b|m0|m5|mL|mM\\\",\\\"a|lu\\\",\\\"o|o|kt|q|\\\",\\\"o|mO|mP\\\",\\\"Query.\\\",\\\"o|18|mQ|mR\\\",\\\"_protocol\\\",\\\"_host\\\",\\\"a|mT|mU\\\",\\\"protocol\\\",\\\"a|mW\\\",\\\"o|f|mX\\\",\\\"a|TN\\\",\\\"o|f|mZ\\\",\\\"o|mV|mY|ma\\\",\\\"itemId\\\",\\\"a|mc|mW|TN\\\",\\\"\\\\\\\"space\\\\\\\", or \\\\\\\"protobuf\\\\\\\"\\\",\\\"o|t|1D|v|z|me\\\",\\\"space key, FQN of the schema\\\",\\\"o|t|1D|14|z|mg\\\",\\\"o|md|1j|mf|mh\\\",\\\"Reference to an Item.\\\",\\\"o|1s|mb|mi|mj\\\",\\\"a|Bz\\\",\\\"null\\\",\\\"int\\\",\\\"float\\\",\\\"datetime\\\",\\\"array\\\",\\\"reference\\\",\\\"a|mm|97|mn|mo|1D|Ah|mp|67|gF|mq|mr\\\",\\\"o|5J|ms|\\\",\\\"o|ml|mt\\\",\\\"int64\\\",\\\"o|o|mv|14|\\\",\\\"o|o|mo|2S|\\\",\\\"o|o|1D|CL|\\\",\\\"o|o|1D|CO|\\\",\\\"o|o|67|CR|\\\",\\\"o|o|kp|Io|\\\",\\\"o|o|kn|Iq|\\\",\\\"n|U\\\",\\\"o|o|kv|n3|\\\",\\\"o|ms|U1|eA|mw|mx|UT|my|mz|n0|n1|n2|n4\\\",\\\"Generic value.\\\",\\\"o|1s|mu|n5|n6\\\",\\\"a|n|ac\\\",\\\"o|o|67|v|\\\",\\\"o|n8|68|n9\\\",\\\"o|18|nA|\\\",\\\"o|ky|l3|l8|lC|lc|lr|ly|mN|mS|mk|n7|nB\\\",\\\"o|1|nC\\\",\\\"Message\\\",\\\"a|nE\\\",\\\"sender\\\",\\\"a|Ah|hX|nG\\\",\\\"o|nH|1j|2i|1I\\\",\\\"o|18|nI|\\\",\\\"o|nF|nJ\\\",\\\"o|1|nK\\\",\\\"TextKind\\\",\\\"TextMutation\\\",\\\"TextSnapshot\\\",\\\"a|nM|nN|nO\\\",\\\"PLAIN\\\",\\\"RICH\\\",\\\"a|nQ|nR\\\",\\\"o|nS|1R|q\\\",\\\"o|nS||\\\",\\\"o|1N|nT||nU\\\",\\\"_update\\\",\\\"_clientId\\\",\\\"_kind\\\",\\\"a|nW|nX|nY|il\\\",\\\"update\\\",\\\"a|na\\\",\\\"o|f|nb\\\",\\\"clientId\\\",\\\"a|nd\\\",\\\"o|f|ne\\\",\\\"o|f|5I\\\",\\\"o|nZ|nc|nf|ng|ip\\\",\\\"a|na|nd|5H|in\\\",\\\"o|t|nM|14|z|\\\",\\\"o|ni|6r|2Q|nj|Nc\\\",\\\"o|1s|nh|nk|\\\",\\\"a|bd|5H|in\\\",\\\"o|o|nM|v|\\\",\\\"o|nm|68|nn|1I\\\",\\\"o|18|no|\\\",\\\"o|nP|nV|nl|np\\\",\\\"o|1|nq\\\",\\\"o|km|nD|nL|nr\\\",\\\"o|1|ns\\\",\\\"EchoObject\\\",\\\"EchoObjectBatch\\\",\\\"MutationMeta\\\",\\\"a|nu|nv|nw\\\",\\\"_genesis\\\",\\\"a|Dt|ny|bJ\\\",\\\"genesis\\\",\\\"a|o0\\\",\\\"o|f|o1\\\",\\\"o|nz|E0|o2|bN\\\",\\\"objectId\\\",\\\"a|o4|Dy|o0|bL|lj\\\",\\\"Metadata for the genesis mutation.\\\",\\\"o|t|nw|v|z|o6\\\",\\\"Genesis\\\",\\\"Present in mutations creating new items and snapshots.\\\",\\\"o|t|o8|CL|z|o9\\\",\\\"Snapshot\\\",\\\"o|t|oB|CU|z|\\\",\\\"Mutation\\\",\\\"May be present in snapshots. In that case the mutations must be applied on top of the snapshot.\\\",\\\"o|12|13|oD|CW|oE\\\",\\\"o|o5|1j|o7|oA|oC|oF\\\",\\\"a|o8|oD|oB\\\",\\\"_modelVersion\\\",\\\"a|oI\\\",\\\"modelVersion\\\",\\\"a|oK\\\",\\\"o|f|oL\\\",\\\"o|oJ|oM\\\",\\\"modelType\\\",\\\"a|oO|oK\\\",\\\"o|oP|2i|4g\\\",\\\"o|1s|oN|oQ|\\\",\\\"_parentId\\\",\\\"_action\\\",\\\"_model\\\",\\\"a|Dt|oS|oT|oU\\\",\\\"parentId\\\",\\\"a|oW\\\",\\\"o|f|oX\\\",\\\"a|Gx\\\",\\\"o|f|oZ\\\",\\\"a|gE\\\",\\\"o|f|ob\\\",\\\"o|oV|E0|oY|oa|oc\\\",\\\"a|Dy|oW|Gx|gE\\\",\\\"o|t|nw|q|z|\\\",\\\"Set parent id\\\",\\\"o|t|1D|CL|z|og\\\",\\\"o|t|Gz|CO|z|\\\",\\\"preserve_any\\\",\\\"a|oj|w\\\",\\\"o|ok|y|y\\\",\\\"o|t|GQ|CR|ol|\\\",\\\"o|oe|of|oh|oi|om\\\",\\\"a|Gz\\\",\\\"NOOP\\\",\\\"RESTORE\\\",\\\"a|op|lS|oq\\\",\\\"o|or|1R|q|v\\\",\\\"o|or|||\\\",\\\"o|1N|os||ot\\\",\\\"o|oo|ou\\\",\\\"o|b|od|on|ov|\\\",\\\"a|hq|oS|oU\\\",\\\"o|ox|hv|oY|oc\\\",\\\"a|ht|oW|gE\\\",\\\"Set the model to the provided snapshot.\\\",\\\"o|t|GQ|CL|ol|p0\\\",\\\"o|oz|98|32|p1\\\",\\\"o|1s|oy|p2|\\\",\\\"o|oH|oR|ow|p3\\\",\\\"Wrapper for all ECHO messages.\\\",\\\"o|b|o3|oG|p4|p5\\\",\\\"objects\\\",\\\"a|p7\\\",\\\"o|12|13|nu|q|\\\",\\\"o|p8|p9\\\",\\\"o|18|pA|\\\",\\\"_seq\\\",\\\"_memberKey\\\",\\\"a|cM|pC|pD|e1\\\",\\\"a|cf\\\",\\\"o|f|pF\\\",\\\"a|MC\\\",\\\"o|f|pH\\\",\\\"o|pE|cR|pG|pI|e5\\\",\\\"clientTag\\\",\\\"a|cP|cf|MC|e3|pK\\\",\\\"o|t|4I|14|z|\\\",\\\"o|t|jF|2S|z|\\\",\\\"If this mutation was created by this client, this field will be set to the tag in the mutation.\\\",\\\"o|12|13|1D|4J|pO\\\",\\\"o|pL|KN|2Q|pM|pN|pP\\\",\\\"o|1s|pJ|pQ|\\\",\\\"o|nx|p6|pB|pR\\\",\\\"o|1|pS\\\",\\\"Heads\\\",\\\"QueryRequest\\\",\\\"QueryResponse\\\",\\\"QueryResult\\\",\\\"QueryService\\\",\\\"a|pU|pV|pW|pX|pY\\\",\\\"hashes\\\",\\\"a|pa\\\",\\\"o|12|13|1D|q|\\\",\\\"o|pb|pc\\\",\\\"Automerge heads.\\\\nUsed for encoding in Index metadata store.\\\\n@see https://automerge.org/automerge-repo/types/_automerge_automerge_repo.Heads.html\\\",\\\"o|18|pd|pe\\\",\\\"_queryId\\\",\\\"a|pg\\\",\\\"queryId\\\",\\\"a|pi\\\",\\\"o|f|pj\\\",\\\"o|ph|pk\\\",\\\"a|pi|SN\\\",\\\"dxos.echo.filter.Filter\\\",\\\"o|o|pn|v|\\\",\\\"o|pm|6h|po\\\",\\\"o|1s|pl|pp|\\\",\\\"results\\\",\\\"a|pi|pr|p7\\\",\\\"o|12|13|pX|v|\\\",\\\"dxos.echo.object.EchoObject\\\",\\\"o|12|13|pu|14|\\\",\\\"o|ps|6h|pt|pv\\\",\\\"o|1s|pl|pw|\\\",\\\"rank\\\",\\\"a|n|3y|py\\\",\\\"o|o|mo|14|\\\",\\\"o|pz|1j|MF|q0\\\",\\\"o|18|q1|\\\",\\\"SetConfig\\\",\\\"ExecQuery\\\",\\\"Reindex\\\",\\\"a|q3|q4|q5\\\",\\\"dxos.echo.indexing.IndexConfig\\\",\\\"o|2p|q7|1e|\\\",\\\"o|1d|pV|pW|y|\\\",\\\"o|q6|q8|q9|5D\\\",\\\"o|1Y|qA|\\\",\\\"o|pZ|pf|pq|px|q2|qB\\\",\\\"o|1|qC\\\",\\\"DataService\\\",\\\"EchoEvent\\\",\\\"FlushRequest\\\",\\\"HostInfo\\\",\\\"MutationReceipt\\\",\\\"SubscribeRequest\\\",\\\"SyncRepoRequest\\\",\\\"SyncRepoResponse\\\",\\\"WriteRequest\\\",\\\"a|qE|qF|qG|qH|qI|qJ|qK|qL|qM\\\",\\\"Subscribe\\\",\\\"Write\\\",\\\"Flush\\\",\\\"GetHostInfo\\\",\\\"SyncRepo\\\",\\\"SendSyncMessage\\\",\\\"a|qO|qP|qQ|qR|qS|qT\\\",\\\"o|1d|qJ|qF|y|\\\",\\\"o|2p|qM|qI|\\\",\\\"o|2p|qG|1e|\\\",\\\"o|2p|1e|qH|\\\",\\\"o|1d|qK|qL|y|\\\",\\\"o|2p|qK|1e|\\\",\\\"o|qU|qV|qW|qX|qY|qZ|qa\\\",\\\"o|1Y|qb|\\\",\\\"_clientTag\\\",\\\"a|qd|cM|pC|oT\\\",\\\"a|pK\\\",\\\"o|f|qf\\\",\\\"o|qe|qg|cR|pG|oa\\\",\\\"a|pK|cP|cf|Gx|gz\\\",\\\"If this event comes as a response to this client wirting the mutation, this field will be set to the tag in the mutation.\\\",\\\"o|t|1D|q|z|qj\\\",\\\"For mutations read from the feed store those fields will be set to the position of the mutation in the feed.\\\",\\\"o|t|4I|v|z|ql\\\",\\\"DatabaseAction\\\",\\\"o|t|qn|2S|z|\\\",\\\"o|o|h1|CL|\\\",\\\"o|qi|qk|qm|2R|qo|qp\\\",\\\"a|qn\\\",\\\"RESET\\\",\\\"a|qs\\\",\\\"o|qt|1R\\\",\\\"o|qt|\\\",\\\"o|1N|qu||qv\\\",\\\"o|qr|qw\\\",\\\"o|b|qh|qq|qx|\\\",\\\"states\\\",\\\"a|3y|qz\\\",\\\"DocState\\\",\\\"Automerge specific document ids to wait to flush.\\\",\\\"o|12|13|r1|v|r2\\\",\\\"o|r0|KN|r3\\\",\\\"a|r1\\\",\\\"documentId\\\",\\\"heads\\\",\\\"a|r6|r7\\\",\\\"o|r8|1j|Up\\\",\\\"o|18|r9|\\\",\\\"o|r5|rA\\\",\\\"o|b|cD|r4|rB|\\\",\\\"peerId\\\",\\\"a|rD\\\",\\\"o|rE|1j\\\",\\\"o|18|rF|\\\",\\\"a|cP|cf\\\",\\\"o|rH|8Q|ER\\\",\\\"o|18|rI|\\\",\\\"_syncMessage\\\",\\\"a|rK\\\",\\\"syncMessage\\\",\\\"a|rM\\\",\\\"o|f|rN\\\",\\\"o|rL|rO\\\",\\\"a|n|rM\\\",\\\"o|rQ|1j|6i\\\",\\\"o|1s|rP|rR|\\\",\\\"o|rN|6r\\\",\\\"o|1s|rP|rT|\\\",\\\"a|qd\\\",\\\"o|rV|qg\\\",\\\"a|3y|pK|gz\\\",\\\"Ephermal tag to correlate events in the subscription.\\\",\\\"o|t|1D|v|z|rY\\\",\\\"o|rX|8Q|rZ|qp\\\",\\\"o|1s|rW|ra|\\\",\\\"o|qN|qc|qy|rC|rG|rJ|bI|rS|rU|rb\\\",\\\"o|1|rc\\\",\\\"EchoSnapshot\\\",\\\"SpaceSnapshot\\\",\\\"a|re|rf\\\",\\\"items\\\",\\\"a|rh\\\",\\\"object.EchoObject\\\",\\\"o|12|13|rj|q|\\\",\\\"o|ri|rk\\\",\\\"Database Snapshot\\\",\\\"o|18|rl|rm\\\",\\\"a|e1|Q5\\\",\\\"o|ro|e5|QA\\\",\\\"database\\\",\\\"a|3y|e3|Ah|rq\\\",\\\"o|t|jF|v|z|\\\",\\\"o|o|re|CO|\\\",\\\"o|rr|68|rs|2R|rt\\\",\\\"Snapshots define full space state at a given point in time.\\\\nThey must have enough information to be able to recover the space state without reading the feed messages.\\\\n\\\\nEach snapshot is identified by a space key and a timeframe.\\\\nThe timeframe defines the set of feed messages that have already been processed.\\\\nWhen loading from the snapshot, application would skip all of the feed messages up to (and including) the provided timeframe.\\\",\\\"o|1s|rp|ru|rv\\\",\\\"o|rg|rn|rw\\\",\\\"o|1|rx\\\",\\\"github.com/dxos/kube/proto/def/dxos/echo/timeframe\\\",\\\"o|Me|rz\\\",\\\"TimeframeVector\\\",\\\"a|s1\\\",\\\"frames\\\",\\\"a|s3\\\",\\\"Frame\\\",\\\"o|12|13|s5|q|\\\",\\\"o|s4|s6\\\",\\\"a|s5\\\",\\\"o|rH|68|d0\\\",\\\"o|18|s9|\\\",\\\"o|s8|sA\\\",\\\"Vector timestamp used to order messages.\\\",\\\"o|En|s7|sB|sC\\\",\\\"o|s2|sD\\\",\\\"o|Mc|s0|sE\\\",\\\"o|gH|gq|hN|iY|j5|kj|nt|pT|qD|rd|ry|sF\\\",\\\"o|1|sG\\\",\\\"github.com/dxos/kube/proto/def/dxos/error\\\",\\\"o|Me|sI\\\",\\\"Error\\\",\\\"a|sK\\\",\\\"_message\\\",\\\"_stack\\\",\\\"a|N5|sM|Ds|sN\\\",\\\"a|E3\\\",\\\"o|f|sP\\\",\\\"stack\\\",\\\"a|sR\\\",\\\"o|f|sS\\\",\\\"o|sO|NE|sQ|Dx|sT\\\",\\\"a|5K|E3|Dv|sR\\\",\\\"Also error code. Will be used to reconstruct a known error type.\\\",\\\"o|t|1D|q|z|sW\\\",\\\"o|t|Al|2S|z|\\\",\\\"o|sV|sX|32|sY|4g\\\",\\\"Serialized error.\\\",\\\"o|1s|sU|sZ|sa\\\",\\\"o|sL|sb\\\",\\\"o|Mc|sJ|sc\\\",\\\"AcceptSpaceInvitationCommand\\\",\\\"AgentSpec\\\",\\\"CommandSequence\\\",\\\"CreateProfileCommand\\\",\\\"CreateSpaceCommand\\\",\\\"CreateSpaceInvitationCommand\\\",\\\"SyncClient\\\",\\\"SyncServer\\\",\\\"TearDown\\\",\\\"a|se|sf|5g|sg|sh|si|sj|sk|sl|sm\\\",\\\"a|Bu\\\",\\\"o|so|1j\\\",\\\"o|18|sp|\\\",\\\"_stateMachine\\\",\\\"_startSequence\\\",\\\"_stopSequence\\\",\\\"a|Mp|sr|ss|st\\\",\\\"stateMachine\\\",\\\"a|sv\\\",\\\"o|f|sw\\\",\\\"startSequence\\\",\\\"a|sy\\\",\\\"o|f|sz\\\",\\\"stopSequence\\\",\\\"a|t1\\\",\\\"o|f|t2\\\",\\\"o|su|Mt|sx|t0|t3\\\",\\\"testSequences\\\",\\\"a|Mr|sv|sy|t1|t5\\\",\\\"o|t|sg|14|z|\\\",\\\"o|t|sg|2S|z|\\\",\\\"o|12|13|sg|4J|\\\",\\\"o|t6|20|32|t7|t8|t9\\\",\\\"Root specification for Agent.\\\",\\\"o|1s|t4|tA|tB\\\",\\\"Cmd\\\",\\\"a|tD\\\",\\\"createProfile\\\",\\\"createSpace\\\",\\\"createSpaceInvitation\\\",\\\"acceptSpaceInvitation\\\",\\\"syncServer\\\",\\\"syncClient\\\",\\\"tearDown\\\",\\\"a|tF|tG|tH|tI|tJ|tK|tL\\\",\\\"o|5J|tM|\\\",\\\"o|tE|tN\\\",\\\"o|o|sh|q|\\\",\\\"o|o|si|v|\\\",\\\"o|o|sj|14|\\\",\\\"o|o|se|2S|\\\",\\\"o|o|sl|4J|\\\",\\\"o|o|sk|4M|\\\",\\\"o|o|sm|4O|\\\",\\\"o|tM|tP|tQ|tR|tS|tT|tU|tV\\\",\\\"Atomic async command.\\\",\\\"o|1s|tO|tW|tX\\\",\\\"commands\\\",\\\"a|tZ\\\",\\\"o|12|13|5g|q|\\\",\\\"o|ta|tb\\\",\\\"Commands that must be run sequentially.\\\",\\\"o|18|tc|td\\\",\\\"__noop_\\\",\\\"a|tf\\\",\\\"_noop_\\\",\\\"a|th\\\",\\\"o|f|ti\\\",\\\"o|tg|tj\\\",\\\"o|ti|98\\\",\\\"o|1s|tk|tl|\\\",\\\"a|6D\\\",\\\"o|tn|6L\\\",\\\"o|6K|6h\\\",\\\"o|1s|to|tp|\\\",\\\"a|n|Bu\\\",\\\"o|tr|1j|2i\\\",\\\"o|18|ts|\\\",\\\"srvId\\\",\\\"verbose\\\",\\\"a|n|tu|TN|1v|tv\\\",\\\"o|o|97|4J|\\\",\\\"o|tw|1j|2i|1I|c5|tx\\\",\\\"o|18|ty|\\\",\\\"a|n|TN|1v|tv\\\",\\\"o|u0|1j|2i|c4|g3\\\",\\\"o|18|u1|\\\",\\\"o|sn|sq|tC|tY|te|tm|tq|tt|tz|u2|tm\\\",\\\"o|1|u3\\\",\\\"keyring\\\",\\\"signed\\\",\\\"a|MT|Dn|u5|G|u6\\\",\\\"github.com/dxos/kube/proto/def/dxos/halo/credentials\\\",\\\"o|Me|u8\\\",\\\"AdmittedFeed\\\",\\\"auth\\\",\\\"Auth\\\",\\\"AuthorizedDevice\\\",\\\"Chain\\\",\\\"Claim\\\",\\\"Credential\\\",\\\"DeviceProfile\\\",\\\"DeviceProfileDocument\\\",\\\"DeviceType\\\",\\\"Epoch\\\",\\\"greet\\\",\\\"HaloSpace\\\",\\\"IdentityProfile\\\",\\\"IdentityRecovery\\\",\\\"KeyInfo\\\",\\\"KubeAccess\\\",\\\"MemberProfile\\\",\\\"Presentation\\\",\\\"Proof\\\",\\\"ServiceAccess\\\",\\\"SpaceGenesis\\\",\\\"a|uA|uB|uC|uD|uE|uF|uG|uH|uI|uJ|uK|uL|uM|Gk|uN|uO|uP|uQ|uR|uS|jo|uT|uU|uV|7u\\\",\\\"designation\\\",\\\"a|3y|Ar|9y|uX\\\",\\\"Owning identity.\\\",\\\"o|o|4I|v|uZ\\\",\\\"Owning device.\\\",\\\"o|o|4I|14|ub\\\",\\\"Designation\\\",\\\"Feeds with different designations are consumed by separate pipelines.\\\",\\\"o|o|ud|2S|ue\\\",\\\"o|uY|8Q|ua|uc|uf\\\",\\\"a|ud\\\",\\\"GENERAL\\\",\\\"CONTROL\\\",\\\"DATA\\\",\\\"a|ui|uj|uk\\\",\\\"o|ul|1R|q|v\\\",\\\"Classic general purpose feeds for both HALO and ECHO messages together. To be deprecated.\\\",\\\"Contain system-level messages messages, such as credentials and epochs.\\\",\\\"Database mutations.\\\",\\\"o|ul|un|uo|up\\\",\\\"o|1N|um||uq\\\",\\\"o|uh|ur\\\",\\\"o|En|ug|us|\\\",\\\"a|uC\\\",\\\"_feedAdmit\\\",\\\"a|cM|uv\\\",\\\"feedAdmit\\\",\\\"a|ux\\\",\\\"o|f|uy\\\",\\\"o|uw|cR|uz\\\",\\\"a|3y|9y|Ar|cP|ux\\\",\\\"The publicKey of the target Space for these credentials.\\\",\\\"o|o|4I|q|v2\\\",\\\"The publicKey of the authenticating Device.\\\",\\\"o|o|4I|v|v4\\\",\\\"The publicKey of the authenticating Identity.\\\",\\\"o|o|4I|14|v6\\\",\\\"o|t|4I|2S|z|v6\\\",\\\"FeedAdmit message to the should be written to a control feed in case the `feed_key` is not admitted to the space.\\\",\\\"o|t|GQ|4J|z|v9\\\",\\\"o|v1|v3|v5|v7|v8|vA\\\",\\\"The payload for a SignedMessage sent during handshake for replication authentication.\\\",\\\"o|1s|v0|vB|vC\\\",\\\"o|uu|vD\\\",\\\"o|1|vE\\\",\\\"Assertion for agents authenticating in the space swarm.\\\",\\\"o|18|ZZ|vG\\\",\\\"a|Ar|9y\\\",\\\"o|vI|8Q|MF\\\",\\\"o|18|vJ|\\\",\\\"Credential that authorizes the subject to issue new credentials (can be recursive).\\\",\\\"o|o|uG|q|vL\\\",\\\"o|XL|vM\\\",\\\"A chain of credentials that establishes the delegated authority to issue new credentials.\\\\nEach key in the chain has an assotiated credential that establishes the authrity of that specific key.\\\\n\\\\nExample:\\\\nAlice/Device-2 => Alice/Device-1 => Alice\\\\n\\\\nThis chain would include 2 credentials:\\\\n1. Giving Alice/Device-2 the authority to issue credentials on behalf of Alice, signed by Alice/Device-1.\\\\n2. Giving Alice/Device-1 the authority to issue credentials on behalf of Alice, signed by Alice.\\\",\\\"o|18|vN|vO\\\",\\\"assertion\\\",\\\"a|n|vQ\\\",\\\"o|o|GQ|v|\\\",\\\"o|vR|8Q|vS\\\",\\\"o|18|vT|\\\",\\\"_expirationDate\\\",\\\"_expirationRef\\\",\\\"_proof\\\",\\\"a|6D|vV|vW|vX\\\",\\\"expirationDate\\\",\\\"a|vZ\\\",\\\"o|f|va\\\",\\\"expirationRef\\\",\\\"a|vc\\\",\\\"o|f|vd\\\",\\\"proof\\\",\\\"a|vf\\\",\\\"o|f|vg\\\",\\\"o|vY|6L|vb|ve|vh\\\",\\\"issuer\\\",\\\"issuanceDate\\\",\\\"subject\\\",\\\"parentCredentialIds\\\",\\\"a|n|vj|vk|vZ|vc|vl|vf|vm\\\",\\\"o|o|uF|CL|\\\",\\\"o|t|uT|CO|z|\\\",\\\"o|12|13|4I|CR|\\\",\\\"o|vn|KN|MF|br|4H|gd|vo|vp|vq\\\",\\\"o|1s|vi|vr|\\\",\\\"o|o|uI|q|\\\",\\\"o|8k|vt\\\",\\\"[ASSERTION]: Sets device profile information.\\\",\\\"o|18|vu|vv\\\",\\\"_platformVersion\\\",\\\"_architecture\\\",\\\"_os\\\",\\\"_osVersion\\\",\\\"a|dQ|Fg|vx|vy|vz|w0|N6\\\",\\\"platformVersion\\\",\\\"a|w2\\\",\\\"o|f|w3\\\",\\\"architecture\\\",\\\"a|w5\\\",\\\"o|f|w6\\\",\\\"os\\\",\\\"a|w8\\\",\\\"o|f|w9\\\",\\\"osVersion\\\",\\\"a|wB\\\",\\\"o|f|wC\\\",\\\"o|w1|dU|Fp|w4|w7|wA|wD|NG\\\",\\\"a|dS|Fn|w2|w5|w8|wB|M\\\",\\\"o|t|uJ|4O|z|\\\",\\\"o|wF|6h|32|4g|Nc|Wu|Qw|wG\\\",\\\"o|1s|wE|wH|\\\",\\\"UNKNOWN\\\",\\\"NATIVE\\\",\\\"AGENT\\\",\\\"AGENT_MANAGED\\\",\\\"MOBILE\\\",\\\"a|wJ|GF|wK|wL|wM|wN\\\",\\\"o|wO|1R|q|v|14|2S|4J\\\",\\\"o|wO||||||\\\",\\\"o|1N|wP||wQ\\\",\\\"_previousId\\\",\\\"_snapshotCid\\\",\\\"_automergeRoot\\\",\\\"a|wS|wT|wU\\\",\\\"previousId\\\",\\\"a|wW\\\",\\\"o|f|wX\\\",\\\"snapshotCid\\\",\\\"a|wZ\\\",\\\"o|f|wa\\\",\\\"automergeRoot\\\",\\\"a|wc\\\",\\\"o|f|wd\\\",\\\"o|wV|wY|wb|we\\\",\\\"number\\\",\\\"a|wg|wW|e3|wZ|wc\\\",\\\"Epoch number.\\\",\\\"o|o|G8|q|wi\\\",\\\"Id of the previous epoch. Identified by the credential id.\\\",\\\"o|t|4I|v|z|wk\\\",\\\"Epoch start timeframe. Indexes correspond to last mutations included into the snapshot.\\\",\\\"o|o|5a|CL|wm\\\",\\\"Epoch start snapshot.\\\",\\\"o|t|1D|CO|z|wo\\\",\\\"URL of the automerge document representing the space root.\\\",\\\"o|t|1D|CR|z|wq\\\",\\\"o|wh|wj|wl|wn|wp|wr\\\",\\\"o|1s|wf|ws|\\\",\\\"BeginResponse\\\",\\\"ClaimResponse\\\",\\\"HandshakeResponse\\\",\\\"KeyHint\\\",\\\"NotarizeResponse\\\",\\\"a|wu|wv|5g|ww|wx|wy\\\",\\\"info\\\",\\\"a|x0\\\",\\\"keyType\\\",\\\"a|x2|M|n|a\\\",\\\"o|x3|1D|GQ|q|\\\",\\\"o|x1|x4\\\",\\\"o|18|x5|\\\",\\\"rendezvousKey\\\",\\\"a|n|x7\\\",\\\"o|x8|68|n9\\\",\\\"o|18|x9|\\\",\\\"_secret\\\",\\\"a|xB\\\",\\\"secret\\\",\\\"a|xD\\\",\\\"o|f|xE\\\",\\\"o|xC|xF\\\",\\\"params\\\",\\\"a|6c|xD|xH\\\",\\\"o|o|Bz|q|\\\",\\\"o|12|13|GQ|CL|\\\",\\\"o|xI|xJ|6i|xK\\\",\\\"BEGIN\\\",\\\"HANDSHAKE\\\",\\\"NOTARIZE\\\",\\\"FINISH\\\",\\\"CLAIM\\\",\\\"a|xM|xN|xO|xP|xQ\\\",\\\"o|xR|1R|q|v|14|CL\\\",\\\"o|xR|||||\\\",\\\"o|1N|xS||xT\\\",\\\"o|ml|xU\\\",\\\"A Greeter command.\\\",\\\"o|b|xG|xL|xV|xW\\\",\\\"a|II|3y\\\",\\\"o|xY|68|MF\\\",\\\"o|18|xZ|\\\",\\\"a|8O|M\\\",\\\"keys.KeyType\\\",\\\"o|o|xc|v|\\\",\\\"o|xb|8Q|xd\\\",\\\"o|18|xe|\\\",\\\"copies\\\",\\\"a|xg|e8\\\",\\\"o|12|13|GQ|q|\\\",\\\"o|xh|xi|fN\\\",\\\"o|18|xj|\\\",\\\"o|wz|x6|xA|xX|xa|xf|xk\\\",\\\"o|1|xl\\\",\\\"haloKey\\\",\\\"a|Ar|xn\\\",\\\"o|o|4I|v|kS\\\",\\\"o|xo|8Q|xp\\\",\\\"[ASSERTION]: Associates a space that will implement Agent's HALO with an Identity.\\\",\\\"o|18|xq|xr\\\",\\\"DeviceInfo\\\",\\\"IdentityInfo\\\",\\\"a|xt|xu\\\",\\\"a|8O|NH\\\",\\\"o|xw|8Q|2i\\\",\\\"o|18|xx|\\\",\\\"o|xv|xy|xy\\\",\\\"o|1|xz\\\",\\\"o|o|jo|q|\\\",\\\"o|8k|y1\\\",\\\"[ASSERTION]: Sets profile information.\\\",\\\"o|18|y2|y3\\\",\\\"a|Ar|IC\\\",\\\"Public key derived from the recovery seedphrase.\\\",\\\"o|o|4I|v|y6\\\",\\\"o|y5|8Q|y7\\\",\\\"[ASSERTION]: Grants recovery permissions to a recovery key.\\\",\\\"o|18|y8|y9\\\",\\\"a|N5\\\",\\\"o|yB|NE\\\",\\\"o|ND|6h\\\",\\\"Subject must be a key being referenced.\\\",\\\"o|1s|yC|yD|yE\\\",\\\"kubeKey\\\",\\\"capabilities\\\",\\\"a|yG|Ar|yH\\\",\\\"o|yI|8Q|MF|Ub\\\",\\\"o|18|yJ|\\\",\\\"o|t|jo|14|z|\\\",\\\"o|8k|yL\\\",\\\"o|1s|9x|yM|\\\",\\\"proofs\\\",\\\"a|MT|yO\\\",\\\"o|12|13|uG|q|\\\",\\\"o|12|13|uT|v|\\\",\\\"o|yP|yQ|yR\\\",\\\"o|18|yS|\\\",\\\"_avatarCid\\\",\\\"_data\\\",\\\"a|N7|yU|yV\\\",\\\"avatarCid\\\",\\\"a|yX\\\",\\\"o|f|yY\\\",\\\"o|f|d7\\\",\\\"o|yW|NJ|yZ|ya\\\",\\\"a|NH|yX|bd\\\",\\\"Custom user data.\\\",\\\"o|t|Al|CL|z|yd\\\",\\\"o|yc|6h|32|ye\\\",\\\"o|1s|yb|yf|\\\",\\\"_chain\\\",\\\"a|IG|yh\\\",\\\"chain\\\",\\\"a|yj\\\",\\\"o|f|yk\\\",\\\"o|yi|IK|yl\\\",\\\"creationDate\\\",\\\"signer\\\",\\\"a|M|yn|yo|II|N|yj\\\",\\\"Signature (excluded from signed data).\\\",\\\"o|o|67|4J|yq\\\",\\\"Must be present if signer is not credential issuer.\\\\nEstablishes the authority of the signer. Proves that the signer can issue such credentials.\\\\nExcluded from signed data.\\\",\\\"o|t|uE|4M|z|ys\\\",\\\"o|yp|1j|jV|fN|bs|yr|yt\\\",\\\"o|1s|ym|yu|\\\",\\\"_serverMetadata\\\",\\\"a|yw\\\",\\\"serverMetadata\\\",\\\"a|yy\\\",\\\"o|f|yz\\\",\\\"o|yx|z0\\\",\\\"serverName\\\",\\\"serverKey\\\",\\\"a|z2|yy|z3|Ar|yH\\\",\\\"o|t|Al|v|z|\\\",\\\"o|z4|1j|z5|fN|eC|Nd\\\",\\\"o|1s|z1|z6|\\\",\\\"_invitationCredentialId\\\",\\\"a|9k|z8\\\",\\\"invitationCredentialId\\\",\\\"a|zA\\\",\\\"o|f|zB\\\",\\\"o|z9|9m|zC\\\",\\\"a|3y|Bp|8j|kH|zA\\\",\\\"Role\\\",\\\"o|o|zF|v|\\\",\\\"Needed so that the admitted member can start replicating the space based on this credential alone.\\\",\\\"o|o|4I|2S|zH\\\",\\\"Present to associate SpaceMember admissions with delegated invitations.\\\",\\\"o|t|4I|4J|z|zJ\\\",\\\"o|zE|8Q|zG|yL|zI|zK\\\",\\\"a|zF\\\",\\\"INVALID\\\",\\\"ADMIN\\\",\\\"EDITOR\\\",\\\"READER\\\",\\\"OWNER\\\",\\\"a|zN|zO|zP|zQ|zR|A6\\\",\\\"o|zS|1R|q|v|14|2S|4J\\\",\\\"Manage members.\\\",\\\"Read and write.\\\",\\\"Read-only.\\\",\\\"Admin that can't be removed.\\\",\\\"Revoked membership.\\\",\\\"o|zS||zU|zV|zW|zX|zY\\\",\\\"o|1N|zT||zZ\\\",\\\"o|zM|za\\\",\\\"o|b|zD|zL|zb|\\\",\\\"o|uW|ut|vF|vH|vK|vP|vU|vs|vw|wI|wR|wt|xm|xs|y0|y4|yA|yF|yK|yN|yT|yg|yv|z7|bI|zc\\\",\\\"o|Mc|u9|zd\\\",\\\"AdmissionRequest\\\",\\\"AdmissionResponse\\\",\\\"AuthenticationResponse\\\",\\\"CancelDelegatedInvitation\\\",\\\"DelegateSpaceInvitation\\\",\\\"DeviceAdmissionCredentials\\\",\\\"DeviceAdmissionRequest\\\",\\\"IntroductionRequest\\\",\\\"IntroductionResponse\\\",\\\"InvitationHostService\\\",\\\"Options\\\",\\\"SpaceAdmissionCredentials\\\",\\\"SpaceAdmissionRequest\\\",\\\"a|zf|zg|7F|zh|zi|zj|zk|zl|zm|zn|zo|zp|zq|zr\\\",\\\"device\\\",\\\"space\\\",\\\"a|zt|zu\\\",\\\"o|5J|zv|\\\",\\\"o|5I|zw\\\",\\\"o|o|zl|q|\\\",\\\"o|o|zr|v|\\\",\\\"o|zv|zy|zz\\\",\\\"o|1s|zx|100|\\\",\\\"o|o|zk|q|\\\",\\\"o|o|zq|v|\\\",\\\"o|zv|102|103\\\",\\\"o|1s|zx|104|\\\",\\\"_signedChallenge\\\",\\\"a|BD|106\\\",\\\"signedChallenge\\\",\\\"a|108\\\",\\\"o|f|109\\\",\\\"o|107|BT|10A\\\",\\\"a|8W|108\\\",\\\"Present when auth_method is SHARED_SECRET.\\\",\\\"o|t|1D|q|z|10D\\\",\\\"Present when auth_method is KNOWN_PUBLIC_KEY.\\\",\\\"o|t|67|v|z|10F\\\",\\\"o|10C|10E|10G\\\",\\\"o|1s|10B|10H|\\\",\\\"a|3c\\\",\\\"o|10J|3l\\\",\\\"o|t|p|q|z|\\\",\\\"o|1Z|10L\\\",\\\"a|p\\\",\\\"OK\\\",\\\"INVALID_OTP\\\",\\\"INVALID_OPT_ATTEMPTS\\\",\\\"INTERNAL_ERROR\\\",\\\"INVALID_SIGNATURE\\\",\\\"a|10O|10P|10Q|10R|10S\\\",\\\"o|10T|1R|q|v|14|2S\\\",\\\"o|10T|||||\\\",\\\"o|1N|10U||10V\\\",\\\"o|10N|10W\\\",\\\"o|b|10K|10M|10X|\\\",\\\"credentialId\\\",\\\"a|10Z\\\",\\\"o|10a|8Q\\\",\\\"o|18|10b|\\\",\\\"_guestKey\\\",\\\"_expiresOn\\\",\\\"a|10d|10e\\\",\\\"guestKey\\\",\\\"a|10g\\\",\\\"o|f|10h\\\",\\\"expiresOn\\\",\\\"a|10j\\\",\\\"o|f|10k\\\",\\\"o|10f|10i|10l\\\",\\\"a|8V|Bt|Bu|Bp|10g|10j|Bg\\\",\\\"dxos.client.services.Invitation.AuthMethod\\\",\\\"o|o|10o|v|\\\",\\\"Present for AuthMethod.KNOWN_PUBLIC_KEY, where guess needs to prove possession of a corresponding private key\\\",\\\"o|t|4I|4J|z|10q\\\",\\\"o|o|97|4O|\\\",\\\"o|10n|1j|10p|fN|Kw|10r|JP|10s\\\",\\\"o|1s|10m|10t|\\\",\\\"a|kE\\\",\\\"o|10v|kM\\\",\\\"haloSpaceKey\\\",\\\"a|Ar|10x|kH|kK\\\",\\\"o|t|5a|2S|z|\\\",\\\"o|10y|8Q|MF|fN|10z\\\",\\\"o|1s|10w|110|\\\",\\\"a|9y|Jg|Jj|8j\\\",\\\"o|t|8E|2S|z|\\\",\\\"o|112|8Q|MF|fN|113\\\",\\\"o|1s|9x|114|\\\",\\\"_invitationId\\\",\\\"a|9k|116\\\",\\\"o|f|8a\\\",\\\"o|117|9m|118\\\",\\\"a|8j|8V\\\",\\\"Guest's profile.\\\",\\\"o|t|8l|q|z|11B\\\",\\\"o|11A|11C|32\\\",\\\"o|1s|119|11D|\\\",\\\"_challenge\\\",\\\"a|11F|3h\\\",\\\"challenge\\\",\\\"a|11H\\\",\\\"o|f|11I\\\",\\\"o|11G|11J|40\\\",\\\"a|Bt|11H|3y\\\",\\\"o|o|10o|q|\\\",\\\"Only present for testing invitation types.\\\",\\\"o|t|4I|Kf|z|11N\\\",\\\"o|11L|11M|10G|11O\\\",\\\"o|1s|11K|11P|\\\",\\\"Introduce\\\",\\\"Admit\\\",\\\"a|zp|11R|Dc|11S\\\",\\\"Both peers must call this method before any other.\\\",\\\"o|2p|zp|1e|11U\\\",\\\"Introduce guest to the host. Only on the host.\\\",\\\"o|2p|zm|zn|11W\\\",\\\"Authenticate request. Only on the host.\\\",\\\"o|2p|7F|zh|11Y\\\",\\\"Process admission credentials. Only on the host.\\\",\\\"o|2p|zf|zg|11a\\\",\\\"o|11T|11V|11X|11Z|11b\\\",\\\"o|1Y|11c|\\\",\\\"Role of the peer.\\\",\\\"o|o|zF|q|11e\\\",\\\"o|Bq|11f\\\",\\\"GUEST\\\",\\\"HOST\\\",\\\"a|11h|11i\\\",\\\"o|11j|1R|q\\\",\\\"o|11j||\\\",\\\"o|1N|11k||11l\\\",\\\"o|zM|11m\\\",\\\"o|En|11g|11n|\\\",\\\"a|kE|kF\\\",\\\"o|11p|kM|kP\\\",\\\"a|XK|kK|kN\\\",\\\"Credential of type `SpaceMember` that grants Guest's identity access to the space.\\\",\\\"o|o|KS|q|11s\\\",\\\"Hint to the guest about the current control timeframe.\\\",\\\"o|t|5a|v|z|11u\\\",\\\"Hint to the guest about the current data timeframe.\\\",\\\"o|t|5a|14|z|11w\\\",\\\"o|11r|11t|11v|11x\\\",\\\"o|1s|11q|11y|\\\",\\\"a|Ar|9y|Jg|Jj\\\",\\\"o|120|8Q|MF|fN|eC\\\",\\\"o|18|121|\\\",\\\"o|zs|101|105|10I|10Y|10c|10u|111|115|11E|11Q|11d|11o|11z|122\\\",\\\"o|1|123\\\",\\\"KeyRecord\\\",\\\"a|125\\\",\\\"o|8P|68|6i\\\",\\\"o|1s|8N|127|\\\",\\\"o|126|128\\\",\\\"o|1|129\\\",\\\"KeyChain\\\",\\\"KeyRecordList\\\",\\\"KeyType\\\",\\\"a|12B|125|12C|12D\\\",\\\"parents\\\",\\\"a|8O|E3|12F\\\",\\\"o|o|cI|v|\\\",\\\"o|12|13|12B|14|\\\",\\\"o|12G|8Q|12H|12I\\\",\\\"o|18|12J|\\\",\\\"_secretKey\\\",\\\"_hint\\\",\\\"_own\\\",\\\"_trusted\\\",\\\"_added\\\",\\\"a|12L|12M|12N|12O|12P|BG\\\",\\\"secretKey\\\",\\\"a|12R\\\",\\\"o|f|12S\\\",\\\"hint\\\",\\\"a|12U\\\",\\\"o|f|12V\\\",\\\"own\\\",\\\"a|12X\\\",\\\"o|f|12Y\\\",\\\"trusted\\\",\\\"a|12a\\\",\\\"o|f|12b\\\",\\\"added\\\",\\\"a|12d\\\",\\\"o|f|12e\\\",\\\"o|12Q|12T|12W|12Z|12c|12f|Bc\\\",\\\"a|M|8O|12R|12U|12X|12a|12d|Ba\\\",\\\"The `KeyType` type of the key. This is often unknown for keys from other sources.\\\",\\\"o|o|12D|q|12i\\\",\\\"The public key as a Buffer (required).\\\",\\\"o|o|4I|v|12k\\\",\\\"The secret key as a Buffer (this will never be visible outside the Keyring).\\\",\\\"o|t|8R|14|z|12m\\\",\\\"Is this key from a Greeting \\\\\\\"hint\\\\\\\"?\\\",\\\"o|t|97|2S|z|12o\\\",\\\"Determines if this is our key?\\\\nUsually true if `secret_key` is present; may be false for \\\\\\\"inception keys\\\\\\\" such as the Space key.\\\",\\\"o|t|97|4J|z|12q\\\",\\\"Is this key to be trusted?\\\",\\\"o|t|97|4M|z|12s\\\",\\\"An RFC-3339 date/time string for when the key was added to the Keyring.\\\",\\\"o|t|1D|4O|z|12u\\\",\\\"An RFC-3339 date/time string for when the key was created.\\\",\\\"o|t|1D|CF|z|12w\\\",\\\"o|12h|12j|12l|12n|12p|12r|12t|12v|12x\\\",\\\"o|1s|12g|12y|\\\",\\\"o|12|13|125|q|\\\",\\\"o|AS|130\\\",\\\"o|18|131|\\\",\\\"IDENTITY\\\",\\\"FEED\\\",\\\"DXNS_ADDRESS\\\",\\\"a|wJ|133|Cw|Cx|134|135\\\",\\\"o|136|1R|q|v|14|2S|4J\\\",\\\"o|136||||||\\\",\\\"o|1N|137||138\\\",\\\"o|12E|12K|12z|132|139\\\",\\\"o|1|13A\\\",\\\"SignedMessage\\\",\\\"a|nE|13C\\\",\\\"o|o|GQ|q|\\\",\\\"o|ad|13E\\\",\\\"o|18|13F|\\\",\\\"signatures\\\",\\\"a|u6|13H\\\",\\\"Signed\\\",\\\"The signed message contents.\\\",\\\"o|o|13J|q|13K\\\",\\\"Signature\\\",\\\"An array of Signatures, one for each key that signed the message.\\\",\\\"o|12|13|13M|v|13N\\\",\\\"o|13I|13L|13O\\\",\\\"a|13M|13J\\\",\\\"_keyChain\\\",\\\"a|13R\\\",\\\"keyChain\\\",\\\"a|13T\\\",\\\"o|f|13U\\\",\\\"o|13S|13V\\\",\\\"signature\\\",\\\"a|Ex|13X|13T\\\",\\\"The publicKey of the keypair that made this signature.\\\",\\\"o|o|4I|q|13Z\\\",\\\"The bytes of the signature.\\\",\\\"o|o|67|v|13b\\\",\\\"keys.KeyChain\\\",\\\"The certification chain of SignedMessages for this key.\\\",\\\"o|t|13d|14|z|13e\\\",\\\"o|13Y|13a|13c|13f\\\",\\\"o|1s|13W|13g|\\\",\\\"a|Ba|II|ac\\\",\\\"o|o|1D|q|QJ\\\",\\\"The payload to be signed.\\\",\\\"o|o|GQ|CL|13k\\\",\\\"o|13i|13j|n9|13l\\\",\\\"o|18|13m|\\\",\\\"o|13Q|13h|13n\\\",\\\"A generic container message used whenever messages are signed (e.g. SpaceCredential)\\\",\\\"o|En|13P|13o|13p\\\",\\\"o|13D|13G|13q\\\",\\\"o|1|13r\\\",\\\"o|u7|ze|124|12A|13B|13s\\\",\\\"o|1|13t\\\",\\\"AppContextRequest\\\",\\\"AppService\\\",\\\"InvitationUrlRequest\\\",\\\"LayoutRequest\\\",\\\"ShellDisplay\\\",\\\"ShellLayout\\\",\\\"ShellService\\\",\\\"WorkerService\\\",\\\"a|13v|13w|13x|13y|13z|140|141|3a|142\\\",\\\"_display\\\",\\\"_reload\\\",\\\"a|144|3h|BE|145\\\",\\\"display\\\",\\\"a|147\\\",\\\"o|f|148\\\",\\\"reload\\\",\\\"a|14A\\\",\\\"o|f|14B\\\",\\\"o|146|149|40|BW|14C\\\",\\\"a|147|3y|BU|14A\\\",\\\"The display mode that shell should use.\\\",\\\"o|t|13z|q|z|14F\\\",\\\"The key of the joined space.\\\",\\\"o|t|4I|v|z|14H\\\",\\\"Target to redirect to after a successful invitation.\\\",\\\"o|t|1D|14|z|14J\\\",\\\"Used after sign out/identity reset.\\\",\\\"o|t|97|2S|z|14L\\\",\\\"o|14E|14G|14I|14K|14M\\\",\\\"o|1s|14D|14N|\\\",\\\"SetContext\\\",\\\"a|14P\\\",\\\"o|2p|13v|1e|\\\",\\\"o|14Q|14R\\\",\\\"App RPCs for the shell.\\\",\\\"o|1Y|14S|14T\\\",\\\"invitationUrl\\\",\\\"deviceInvitationParam\\\",\\\"spaceInvitationParam\\\",\\\"a|14V|14W|14X\\\",\\\"Base URL for invitations.\\\",\\\"o|o|1D|q|14Z\\\",\\\"Query parameter for device invitations.\\\",\\\"o|o|1D|v|14b\\\",\\\"Query parameter for space invitations.\\\",\\\"o|o|1D|14|14d\\\",\\\"o|14Y|14a|14c|14e\\\",\\\"o|18|14f|\\\",\\\"_invitationCode\\\",\\\"a|14h|3h|BE\\\",\\\"invitationCode\\\",\\\"a|14j\\\",\\\"o|f|14k\\\",\\\"o|14i|14l|40|BW\\\",\\\"layout\\\",\\\"a|14n|14j|3y|BU\\\",\\\"Determins which panel of the shell is opened.\\\",\\\"o|o|140|q|14p\\\",\\\"Invitation code to join a space.\\\",\\\"o|t|1D|v|z|14r\\\",\\\"Key of the space to share.\\\",\\\"o|t|4I|14|z|14t\\\",\\\"Target to include in an invitation for redirecting after a successful invitation.\\\",\\\"o|t|1D|2S|z|14v\\\",\\\"o|14o|14q|14s|14u|14w\\\",\\\"o|1s|14m|14x|\\\",\\\"FULLSCREEN\\\",\\\"a|9V|14z\\\",\\\"o|150|1R|q\\\",\\\"o|150||\\\",\\\"o|1N|151||152\\\",\\\"DEFAULT\\\",\\\"INITIALIZE_IDENTITY\\\",\\\"INITIALIZE_IDENTITY_FROM_INVITATION\\\",\\\"SHARE_IDENTITY\\\",\\\"EDIT_PROFILE\\\",\\\"JOIN_SPACE\\\",\\\"STATUS\\\",\\\"a|154|155|156|133|157|158|Cx|159|15A\\\",\\\"o|15B|1R|q|v|14|2S|4J|4M|4O|CF\\\",\\\"o|15B|||||||||\\\",\\\"o|1N|15C||15D\\\",\\\"SetLayout\\\",\\\"SetInvitationUrl\\\",\\\"a|15F|15G\\\",\\\"o|2p|13y|1e|\\\",\\\"o|2p|13x|1e|\\\",\\\"o|15H|15I|15J\\\",\\\"Shell UI RPCs.\\\",\\\"o|1Y|15K|15L\\\",\\\"_lockKey\\\",\\\"_observabilityGroup\\\",\\\"_signalTelemetryEnabled\\\",\\\"a|15N|15O|15P\\\",\\\"lockKey\\\",\\\"a|15R\\\",\\\"o|f|15S\\\",\\\"observabilityGroup\\\",\\\"a|15U\\\",\\\"o|f|15V\\\",\\\"signalTelemetryEnabled\\\",\\\"a|15X\\\",\\\"o|f|15Y\\\",\\\"o|15Q|15T|15W|15Z\\\",\\\"origin\\\",\\\"a|15b|15R|15U|15X\\\",\\\"Key for the iframe resource lock used to determine when the service is closing.\\\",\\\"o|t|1D|v|z|15d\\\",\\\"o|15c|1j|15e|4g|H3\\\",\\\"o|1s|15a|15f|\\\",\\\"a|50|51\\\",\\\"o|2p|3a|1e|\\\",\\\"o|15h|15i|5D\\\",\\\"Iframe-to-worker RPCs.\\\",\\\"o|1Y|15j|15k\\\",\\\"o|143|14O|14U|14g|14y|153|15E|15M|15g|15l\\\",\\\"o|1|15m\\\",\\\"github.com/dxos/kube/proto/def/dxos/keys\\\",\\\"o|Me|15o\\\",\\\"PrivateKey\\\",\\\"PublicKey\\\",\\\"a|15q|15r\\\",\\\"o|d7|68\\\",\\\"o|18|15t|\\\",\\\"o|15s|15u|15u\\\",\\\"o|Mc|15p|15v\\\",\\\"bridge\\\",\\\"broadcast\\\",\\\"messaging\\\",\\\"muxer\\\",\\\"replicator\\\",\\\"teleport\\\",\\\"a|15x|15y|15z|160|9z|mW|161|Qh|FM|162\\\",\\\"BridgeEvent\\\",\\\"BridgeService\\\",\\\"CloseRequest\\\",\\\"ConnectionRequest\\\",\\\"DataRequest\\\",\\\"DetailsRequest\\\",\\\"DetailsResponse\\\",\\\"SignalRequest\\\",\\\"StatsRequest\\\",\\\"StatsResponse\\\",\\\"a|164|165|166|167|7H|168|169|16A|16B|16C|16D\\\",\\\"connection\\\",\\\"a|16F|Qh|bd\\\",\\\"o|5J|16G|\\\",\\\"o|NF|16H\\\",\\\"o|o|eO|q|\\\",\\\"SignalEvent\\\",\\\"o|o|16K|v|\\\",\\\"DataEvent\\\",\\\"o|o|16M|14|\\\",\\\"o|16G|16J|16L|16N\\\",\\\"a|eO|16M|16K\\\",\\\"a|Bv|C\\\",\\\"o|16Q|FQ|32\\\",\\\"o|1s|di|16R|\\\",\\\"o|ad|68\\\",\\\"o|18|16T|\\\",\\\"dxos.mesh.swarm.Signal\\\",\\\"o|o|16V|q|\\\",\\\"o|ad|16W\\\",\\\"o|18|16X|\\\",\\\"o|16P|16S|16U|16Y\\\",\\\"o|b|16I|16O|16Z|\\\",\\\"Open\\\",\\\"SendSignal\\\",\\\"SendData\\\",\\\"Close\\\",\\\"GetDetails\\\",\\\"GetStats\\\",\\\"a|16b|16c|16d|16e|16f|16g\\\",\\\"\\\",\\\"o|1d|167|164|y|16i\\\",\\\"o|2p|16B|1e|16i\\\",\\\"o|2p|168|1e|16i\\\",\\\"o|2p|166|1e|16i\\\",\\\"o|2p|169|16A|16i\\\",\\\"o|2p|16C|16D|16i\\\",\\\"o|16h|16j|16k|16l|16m|16n|16o\\\",\\\"o|1Y|16p|\\\",\\\"proxyId\\\",\\\"a|16r\\\",\\\"o|16s|8Q\\\",\\\"o|18|16t|\\\",\\\"initiator\\\",\\\"a|16r|16v\\\",\\\"o|16w|8Q|eA\\\",\\\"o|18|16x|\\\",\\\"a|zN|D3|D4|LS\\\",\\\"o|16z|1R|q|v|14\\\",\\\"o|16z||||\\\",\\\"o|1N|170||171\\\",\\\"a|16r|ac\\\",\\\"o|173|8Q|n9\\\",\\\"o|18|174|\\\",\\\"details\\\",\\\"a|176\\\",\\\"o|177|1j\\\",\\\"o|18|178|\\\",\\\"a|16r|Qh\\\",\\\"o|o|16V|v|\\\",\\\"o|17A|8Q|17B\\\",\\\"o|18|17C|\\\",\\\"o|o|Al|q|\\\",\\\"o|F3|17E\\\",\\\"o|18|17F|\\\",\\\"o|16E|16a|16q|16u|16y|172|175|16u|179|17D|16u|17G\\\",\\\"o|1|17H\\\",\\\"Packet\\\",\\\"a|17J\\\",\\\"_from\\\",\\\"a|17L\\\",\\\"from\\\",\\\"a|17N\\\",\\\"o|f|17O\\\",\\\"o|17M|17P\\\",\\\"a|cf|15b|17N|bd\\\",\\\"o|t|67|14|z|\\\",\\\"o|o|67|2S|\\\",\\\"o|17R|68|n9|17S|17T\\\",\\\"o|1s|17Q|17U|\\\",\\\"o|17K|17V\\\",\\\"o|1|17W\\\",\\\"Acknowledgement\\\",\\\"ReliablePayload\\\",\\\"a|17Y|17Z\\\",\\\"messageId\\\",\\\"a|17b\\\",\\\"MessageId of the Message that is being acknowledged.\\\",\\\"o|o|4I|q|17d\\\",\\\"o|17c|17e\\\",\\\"o|18|17f|\\\",\\\"a|17b|ac\\\",\\\"Unique message identifier. Used for Acknolegment.\\\",\\\"o|o|4I|q|17i\\\",\\\"Payload for signal server netwrok.\\\",\\\"o|o|GQ|v|17k\\\",\\\"o|17h|17j|17l\\\",\\\"o|18|17m|\\\",\\\"o|17a|17g|17n\\\",\\\"o|1|17o\\\",\\\"Data\\\",\\\"Destroy\\\",\\\"OpenChannel\\\",\\\"a|16e|5g|17q|17r|17s\\\",\\\"Error that caused the termination.\\\",\\\"o|t|1D|q|z|17u\\\",\\\"o|4c|17v\\\",\\\"o|1s|di|17w|\\\",\\\"openChannel\\\",\\\"destroy\\\",\\\"close\\\",\\\"a|17y|bd|17z|180\\\",\\\"o|5J|181|\\\",\\\"o|ad|182\\\",\\\"o|o|17s|q|\\\",\\\"o|o|17q|v|\\\",\\\"o|o|17r|14|\\\",\\\"o|o|16e|2S|\\\",\\\"o|181|184|185|186|187\\\",\\\"Root type for messages sent over the stream.\\\",\\\"o|1s|183|188|189\\\",\\\"channelId\\\",\\\"a|18B|bd\\\",\\\"Identifier for the channel as assigned by the remote peer.\\\\nNOTE: An OpenChannel message must received before any data is sent on a channel.\\\\nAny data messages sent before that, should be ignored.\\\",\\\"o|o|1z|q|18D\\\",\\\"o|18C|18E|n9\\\",\\\"o|18|18F|\\\",\\\"Terminate the connection. The other peer can expect the connection to be closed.\\\",\\\"o|1s|di|17w|18H\\\",\\\"a|fc\\\",\\\"o|18J|fi\\\",\\\"a|n|Nx|fg\\\",\\\"Session-specific ID for the channel.\\\",\\\"o|o|1z|q|18M\\\",\\\"Stable identifier for the channel that is agreed upon by both peers.\\\",\\\"o|o|1D|v|18O\\\",\\\"Optional Mime-type or URL describing the protocol that is hosted ober this stream. Used for introspection.\\\",\\\"o|t|1D|14|z|18Q\\\",\\\"o|18L|18N|18P|18R\\\",\\\"Notify the remote peer that we are opening a channel.\\\\n\\\\nMeans that we are ready to receive data on the channel.\\\\nThe remote peer could now send data messages with this channel id that will be atributed to this channel.\\\\n\\\\nThe local peer must buffer any data messages until the remote peer replies with OpenChannel for this tag.\\\",\\\"o|1s|18K|18S|18T\\\",\\\"o|17t|17x|18A|18G|18I|18U\\\",\\\"o|1|18V\\\",\\\"PeerState\\\",\\\"a|18X\\\",\\\"_peerId\\\",\\\"a|18Z\\\",\\\"o|f|rE\\\",\\\"o|18a|18b\\\",\\\"a|b5|Ar|rD\\\",\\\"Will be used to build network graph\\\",\\\"o|12|13|4I|q|18e\\\",\\\"Omitted when sent over the network.\\\",\\\"o|t|4I|14|z|18g\\\",\\\"o|18d|18f|MF|18h\\\",\\\"o|1s|18c|18i|\\\",\\\"o|18Y|18j\\\",\\\"o|1|18k\\\",\\\"Buffer\\\",\\\"a|18m|sK|nE\\\",\\\"code\\\",\\\"a|18o|E3\\\",\\\"o|18p|1j|2i\\\",\\\"o|18|18q|\\\",\\\"nmId\\\",\\\"nmResponse\\\",\\\"nmEphemeral\\\",\\\"nmData\\\",\\\"a|18s|18t|18u|18v\\\",\\\"o|o|97|14|\\\",\\\"o|o|GQ|2S|\\\",\\\"o|18w|1j|eA|18x|18y\\\",\\\"o|18|18z|\\\",\\\"o|18n|15u|18r|190\\\",\\\"o|1|191\\\",\\\"Container\\\",\\\"a|193|cu\\\",\\\"a|M|bd\\\",\\\"o|12|13|GQ|v|\\\",\\\"o|195|1j|196\\\",\\\"o|18|197|\\\",\\\"_discoveryKey\\\",\\\"a|Et|199\\\",\\\"discoveryKey\\\",\\\"a|19B\\\",\\\"o|f|19C\\\",\\\"o|19A|Ez|19D\\\",\\\"a|Ex|19B\\\",\\\"o|19F|6r|6i\\\",\\\"o|1s|19E|19G|\\\",\\\"o|194|198|19H\\\",\\\"o|1|19I\\\",\\\"github.com/dxos/kube/proto/def/dxos/mesh/signal\\\",\\\"o|Me|19K\\\",\\\"HostEvent\\\",\\\"JoinRequest\\\",\\\"PeerEvent\\\",\\\"ReceptionRequest\\\",\\\"SignalState\\\",\\\"SwarmEvent\\\",\\\"a|19M|19N|nE|19O|19P|FR|19Q|19R\\\",\\\"event\\\",\\\"a|19T\\\",\\\"announceBack\\\",\\\"a|19V\\\",\\\"o|5J|19W|\\\",\\\"o|19U|19X\\\",\\\"AnnounceBack\\\",\\\"o|o|19Z|q|\\\",\\\"o|19W|19a\\\",\\\"a|19Z\\\",\\\"peerAvailable\\\",\\\"a|FM|19d\\\",\\\"SwarmEvent.PeerAvailable\\\",\\\"o|o|19f|v|\\\",\\\"o|19e|68|19g\\\",\\\"o|18|19h|\\\",\\\"o|19c|19i\\\",\\\"Goes on a Pub/Sub host topic.\\\",\\\"o|b|19Y|19b|19j|19k\\\",\\\"_metadata\\\",\\\"a|19m\\\",\\\"o|f|dF\\\",\\\"o|19n|19o\\\",\\\"peer\\\",\\\"a|FM|19q|dE\\\",\\\"o|19r|68|n9|E6\\\",\\\"o|1s|19p|19s|\\\",\\\"author\\\",\\\"recipient\\\",\\\"a|19u|19v|ac|dE\\\",\\\"o|19w|68|n9|GR|sY\\\",\\\"o|1s|19p|19x|\\\",\\\"o|5J|sP|\\\",\\\"o|19U|19z\\\",\\\"o|o|nE|q|\\\",\\\"o|sP|1A1\\\",\\\"Goes on Pub/Sub peer topic.\\\",\\\"o|1s|1A0|1A2|1A3\\\",\\\"a|19q\\\",\\\"o|1A5|68\\\",\\\"o|18|1A6|\\\",\\\"Join\\\",\\\"ReceiveMessages\\\",\\\"SendMessage\\\",\\\"a|1A8|1A9|1AA\\\",\\\"o|1d|19N|19R|y|\\\",\\\"o|1d|19P|nE|y|\\\",\\\"o|2p|nE|1e|\\\",\\\"o|1AB|1AC|1AD|1AE\\\",\\\"o|1Y|1AF|\\\",\\\"RECONNECTING\\\",\\\"DISCONNECTED\\\",\\\"a|D3|1AH|D4|1AI|DA|LS\\\",\\\"o|1AJ|1R|q|v|14|2S|4J\\\",\\\"Connection is being established.\\\",\\\"Connection is being re-established.\\\",\\\"Connected.\\\",\\\"Server terminated the connection. Socket will be reconnected.\\\",\\\"Server terminated the connection with an ERROR. Socket will be reconnected.\\\",\\\"Socket was closed.\\\",\\\"o|1AJ|1AL|1AM|1AN|1AO|1AP|1AQ\\\",\\\"o|1N|1AK||1AR\\\",\\\"peerLeft\\\",\\\"a|19d|1AT\\\",\\\"o|5J|1AU|\\\",\\\"o|19U|1AV\\\",\\\"PeerAvailable\\\",\\\"The peer was announced as available on the swarm.\\\",\\\"o|o|1AX|q|1AY\\\",\\\"PeerLeft\\\",\\\"The peer left, or their announcement timed out.\\\",\\\"o|o|1Aa|v|1Ab\\\",\\\"o|1AU|1AZ|1Ac\\\",\\\"a|1AX|1Aa\\\",\\\"_until\\\",\\\"_announceBackToHost\\\",\\\"a|1Af|1Ag\\\",\\\"until\\\",\\\"a|1Ai\\\",\\\"o|f|1Aj\\\",\\\"announceBackToHost\\\",\\\"a|1Al\\\",\\\"o|f|1Am\\\",\\\"o|1Ah|1Ak|1An\\\",\\\"since\\\",\\\"a|19q|1Ap|1Ai|1Al\\\",\\\"Only relevant in Pub/Sub. Optional, the host topic to eagerly send PeerAvailable messages back to.\\\",\\\"o|t|67|2S|z|1Ar\\\",\\\"o|1Aq|68|jV|JN|1As\\\",\\\"o|1s|1Ao|1At|\\\",\\\"o|1Ae|1Au|1A7\\\",\\\"Goes on Pub/Sub swarm topic and as a Join stream in RPC.\\\",\\\"o|b|1AW|1Ad|1Av|1Aw\\\",\\\"o|19S|19l|19t|19y|1A4|1A7|1AG|1AS|1Ax\\\",\\\"o|Mc|19L|1Ay\\\",\\\"Answer\\\",\\\"MessageData\\\",\\\"Offer\\\",\\\"SignalBatch\\\",\\\"SwarmMessage\\\",\\\"a|1B0|1B1|1B2|FR|1B3|1B4\\\",\\\"_offerMessageId\\\",\\\"a|1B6\\\",\\\"offerMessageId\\\",\\\"a|1B8\\\",\\\"o|f|1B9\\\",\\\"o|1B7|1BA\\\",\\\"accept\\\",\\\"a|1BC|1B8\\\",\\\"MessageId of the Offer being answered.\\\",\\\"o|t|4I|v|z|1BE\\\",\\\"o|1BD|U1|1BF\\\",\\\"o|1s|1BB|1BG|\\\",\\\"offer\\\",\\\"answer\\\",\\\"signalBatch\\\",\\\"a|1BI|1BJ|Qh|1BK\\\",\\\"o|5J|1BL|\\\",\\\"o|ad|1BM\\\",\\\"o|o|1B2|q|\\\",\\\"o|o|1B0|v|\\\",\\\"@deprecated Use SignalBatch instead.\\\",\\\"o|o|FR|14|1BQ\\\",\\\"o|o|1B3|2S|\\\",\\\"o|1BL|1BO|1BP|1BR|1BS\\\",\\\"o|1s|1BN|1BT|\\\",\\\"o|ad|17E\\\",\\\"o|18|1BV|\\\",\\\"signals\\\",\\\"a|1BX\\\",\\\"o|12|13|FR|q|\\\",\\\"o|1BY|1BZ\\\",\\\"o|18|1Ba|\\\",\\\"a|av|fH|bd|17b\\\",\\\"Swarm identifier.\\\",\\\"o|o|4I|14|1Bd\\\",\\\"Unique connection identifier.\\\",\\\"o|o|4I|2S|1Bf\\\",\\\"Message payload.\\\",\\\"o|o|1B1|4J|1Bh\\\",\\\"Unique message identifier. Used for ACK and matching Answers to Offers.\\\",\\\"o|o|4I|4M|1Bj\\\",\\\"o|1Bc|1Be|1Bg|1Bi|1Bk\\\",\\\"Use for:\\\\n- Initial peer discovery (initiate session id between two peers).\\\\n- RTC negotiation (SDP offer/answer and ICE).\\\",\\\"o|18|1Bl|1Bm\\\",\\\"o|1B5|1BH|1BU|Za|1BW|1Bb|1Bn\\\",\\\"o|1|1Bo\\\",\\\"automerge\\\",\\\"blobsync\\\",\\\"control\\\",\\\"gossip\\\",\\\"notarization\\\",\\\"a|uB|1Bq|1Br|1Bs|1Bt|1Bu|161\\\",\\\"AuthenticateRequest\\\",\\\"AuthenticateResponse\\\",\\\"AuthService\\\",\\\"a|1Bw|1Bx|1By\\\",\\\"o|11I|68\\\",\\\"o|18|1C0|\\\",\\\"o|XL|68\\\",\\\"o|18|1C2|\\\",\\\"a|Dc\\\",\\\"o|2p|1Bw|1Bx|\\\",\\\"o|1C4|1C5\\\",\\\"o|1Y|1C6|\\\",\\\"o|1Bz|1C1|1C3|1C7\\\",\\\"o|1|1C8\\\",\\\"AutomergeReplicatorService\\\",\\\"SyncMessage\\\",\\\"a|1CA|b1|1CB\\\",\\\"StartReplication\\\",\\\"a|1CD|qT\\\",\\\"o|2p|b1|1e|\\\",\\\"o|2p|1CB|1e|\\\",\\\"o|1CE|1CF|1CG\\\",\\\"o|1Y|1CH|\\\",\\\"o|6K|1j\\\",\\\"o|18|1CJ|\\\",\\\"o|ad|n9\\\",\\\"o|18|1CL|\\\",\\\"o|1CC|1CI|1CK|1CM\\\",\\\"o|1|1CN\\\",\\\"BlobChunk\\\",\\\"BlobSyncService\\\",\\\"WantList\\\",\\\"a|1CP|1CQ|1CR\\\",\\\"_chunkSize\\\",\\\"_chunkOffset\\\",\\\"_totalLength\\\",\\\"a|1CT|1CU|1CV\\\",\\\"a|gU\\\",\\\"o|f|1CX\\\",\\\"chunkOffset\\\",\\\"a|1CZ\\\",\\\"o|f|1Ca\\\",\\\"totalLength\\\",\\\"a|1Cc\\\",\\\"o|f|1Cd\\\",\\\"o|1CW|1CY|1Cb|1Ce\\\",\\\"a|n|gU|1CZ|1Cc|ac\\\",\\\"In bytes\\\",\\\"o|t|1z|v|z|1Ch\\\",\\\"Offset from the start of blob in bytes.\\\",\\\"o|t|1z|14|z|1Cj\\\",\\\"Total length of blob.\\\",\\\"o|t|1z|2S|z|1Cl\\\",\\\"o|o|67|Kf|\\\",\\\"o|1Cg|68|1Ci|1Ck|1Cm|1Cn\\\",\\\"o|1s|1Cf|1Co|\\\",\\\"Want\\\",\\\"Push\\\",\\\"a|1Cq|1Cr\\\",\\\"Notify the peer that we want to receive specified objects.\\\",\\\"o|2p|1CR|1e|1Ct\\\",\\\"Send an object to the peer.\\\",\\\"o|2p|1CP|1e|1Cv\\\",\\\"o|1Cs|1Cu|1Cw\\\",\\\"Allows synchronization of opaque data objects between two peers.\\\\nLoosely based on Bittorrent protocol.\\\",\\\"o|1Y|1Cx|1Cy\\\",\\\"Entry\\\",\\\"Requested blobs. If bitfield is empty, all chunks are requested.\\\",\\\"o|12|13|1D0|q|1D1\\\",\\\"o|ao|1D2\\\",\\\"a|1D0\\\",\\\"a|1CT|gK\\\",\\\"o|1D5|1CY|gP\\\",\\\"a|n|gU|gN\\\",\\\"Size of chunk in bytes. Must be a power of 2. Default is 4096.\\\\nIf chunk_size is missing, host will provide it.\\\",\\\"o|t|1z|v|z|1D8\\\",\\\"Bitfield of requested chunks.\\\\nEvery bit represents a chunk.\\\\nChunks are indexed from MSB to LSB.\\\\n\\\\nIf bitfield is missing, all chunks are requested.\\\",\\\"o|t|67|14|z|1DA\\\",\\\"o|1D7|68|1D9|1DB\\\",\\\"o|1s|1D6|1DC|\\\",\\\"o|1D4|1DD\\\",\\\"o|En|1D3|1DE|\\\",\\\"o|1CS|1Cp|1Cz|1DF\\\",\\\"o|1|1DG\\\",\\\"ControlHeartbeatRequest\\\",\\\"ControlHeartbeatResponse\\\",\\\"ControlService\\\",\\\"RegisterExtensionRequest\\\",\\\"a|1DI|1DJ|1DK|1DL\\\",\\\"requestTimestamp\\\",\\\"a|1DN\\\",\\\"o|1DO|Ak\\\",\\\"o|18|1DP|\\\",\\\"RegisterExtension\\\",\\\"Heartbeat\\\",\\\"a|1DR|1DS\\\",\\\"o|2p|1DL|1e|\\\",\\\"o|2p|1DI|1DJ|\\\",\\\"o|1DT|1DU|1DV\\\",\\\"Controls the lifycycle of the teleport session and its exentsions.\\\",\\\"o|1Y|1DW|1DX\\\",\\\"Must not contain slashes: /[\\\\\\\\w_.]+/. Example: `dxos.mesh.teleport.control`.\\\",\\\"o|o|1D|q|1DZ\\\",\\\"o|ND|1Da\\\",\\\"o|18|1Db|\\\",\\\"o|1DM|1DQ|1DQ|1DY|1Dc\\\",\\\"o|1|1Dd\\\",\\\"GossipMessage\\\",\\\"GossipService\\\",\\\"a|1Df|1Dg\\\",\\\"a|rD|18B|17b|Ah|ac\\\",\\\"Used to route differnt payload types to correct listeners.\\\",\\\"o|o|1D|v|1Dj\\\",\\\"Peer tracks what had been sent by message id.\\\",\\\"o|o|4I|14|1Dl\\\",\\\"o|o|4G|2S|\\\",\\\"o|o|GQ|CL|\\\",\\\"o|1Di|8Q|1Dk|1Dm|1Dn|1Do\\\",\\\"o|18|1Dp|\\\",\\\"Announce\\\",\\\"a|1Dr\\\",\\\"o|2p|1Df|1e|\\\",\\\"o|1Ds|1Dt\\\",\\\"o|1Y|1Du|\\\",\\\"o|1Dh|1Dq|1Dv\\\",\\\"o|1|1Dw\\\",\\\"NotarizationService\\\",\\\"NotarizeRequest\\\",\\\"a|1Dy|1Dz\\\",\\\"Notarize\\\",\\\"a|1E1\\\",\\\"o|2p|1Dz|1e|\\\",\\\"o|1E2|1E3\\\",\\\"Allows peers to request their credentials be written to the control feed.\\\\nUseful for new devices bootstraping their feeds into the space.\\\",\\\"o|1Y|1E4|1E5\\\",\\\"a|MT\\\",\\\"Write specified credentials to the control feed of the space.\\\\nCredentials with ids that are already present in the control pipeline must be skipped.\\\",\\\"o|12|13|KS|q|1E8\\\",\\\"o|1E7|1E9\\\",\\\"o|18|1EA|\\\",\\\"o|1E0|1E6|1EB\\\",\\\"o|1|1EC\\\",\\\"FeedInfo\\\",\\\"ReplicatorService\\\",\\\"StartReplicationRequest\\\",\\\"StartReplicationResponse\\\",\\\"StopReplicationRequest\\\",\\\"UpdateFeedsRequest\\\",\\\"a|1EE|1EF|1EG|1EH|1EI|1EJ\\\",\\\"download\\\",\\\"upload\\\",\\\"a|cP|1EL|1EM\\\",\\\"set if the peer whishes to download the data from the feed.\\\",\\\"o|o|97|v|1EO\\\",\\\"set if the peer whishes to updload the data from the feed.\\\",\\\"o|o|97|14|1EQ\\\",\\\"o|1EN|8Q|1EP|1ER\\\",\\\"o|18|1ES|\\\",\\\"UpdateFeeds\\\",\\\"StopReplication\\\",\\\"a|1EU|1CD|1EV\\\",\\\"Notify about available feeds.\\\",\\\"o|2p|1EJ|1e|1EX\\\",\\\"Start replicating feed. If this feed is already being replicated, the existing replication session must be stopped.\\\",\\\"o|2p|1EG|1EH|1EZ\\\",\\\"Stop replicating feed.\\\",\\\"o|2p|1EI|1e|1Eb\\\",\\\"o|1EW|1EY|1Ea|1Ec\\\",\\\"RPC verbs for replication teleport extension.\\\\nAssumes one peer is designated an initiator.\\\\nThe initiator will start and stop replication streams.\\\\nThe other peer will send updates using the UpdateFeeds method.\\\",\\\"o|1Y|1Ed|1Ee\\\",\\\"o|o|1EE|q|\\\",\\\"o|x1|1Eg\\\",\\\"o|18|1Eh|\\\",\\\"_streamTag\\\",\\\"a|1Ej\\\",\\\"streamTag\\\",\\\"a|1El\\\",\\\"o|f|1Em\\\",\\\"o|1Ek|1En\\\",\\\"Tag of the stream the peers will use for the replication.\\\\nSet to null or \\\\\\\"\\\\\\\" (empty string) of the peer does not wish to replicate the feed.\\\\n\\\\nA new stream must be open with unique tag to start replicating. Existing streams cannot be reused.\\\",\\\"o|t|1D|q|z|1Ep\\\",\\\"o|1Em|1Eq\\\",\\\"o|1s|1Eo|1Er|\\\",\\\"o|12|13|1EE|q|\\\",\\\"o|ct|1Et\\\",\\\"o|18|1Eu|\\\",\\\"o|1EK|1ET|1Ef|1Ei|1Es|1Ei|1Ev\\\",\\\"o|1|1Ew\\\",\\\"o|1Bv|1C9|1CO|1DH|1De|1Dx|1ED|1Ex\\\",\\\"o|1|1Ey\\\",\\\"o|163|17I|17X|17p|18W|18l|192|19J|1Az|1Bp|1Ez\\\",\\\"o|1|1F0\\\",\\\"Record\\\",\\\"a|1F2\\\",\\\"a|BG|N7|N8|5H\\\",\\\"a|M|ac\\\",\\\"o|5J|1F5|\\\",\\\"o|1F4|Bc|NJ|NM|1F6\\\",\\\"a|Ba|NH|NK|NX|M|ac\\\",\\\"Record creation timetstamp.\\\",\\\"o|t|4G|q|z|1F9\\\",\\\"Human-readable name of record.\\\",\\\"o|t|1D|v|z|1FB\\\",\\\"Record description.\\\",\\\"o|t|1D|14|z|1FD\\\",\\\"Optional record tags.\\\",\\\"o|12|13|1D|2S|1FF\\\",\\\"Type record variant.\\\",\\\"o|o|Bz|Kf|1FH\\\",\\\"Extension\\\",\\\"Data record variant.\\\",\\\"o|o|1FJ|Nj|1FK\\\",\\\"o|1F8|1FA|1FC|1FE|1FG|1FI|1FL\\\",\\\"a|1FJ|Bz\\\",\\\"typeRecord\\\",\\\"a|1FO|bd\\\",\\\"CID of type record.\\\",\\\"o|o|67|q|1FQ\\\",\\\"Serialized payload data.\\\",\\\"o|o|67|v|1FS\\\",\\\"o|1FP|1FR|1FT\\\",\\\"Data with a reference to a type record that defines the encoding.\\\",\\\"o|18|1FU|1FV\\\",\\\"_protobufIpfsCid\\\",\\\"a|1FX\\\",\\\"protobufIpfsCid\\\",\\\"a|1FZ\\\",\\\"o|f|1Fa\\\",\\\"o|1FY|1Fb\\\",\\\"messageName\\\",\\\"protobufDefs\\\",\\\"a|1Fd|1Fe|1FZ\\\",\\\"FQ protobuf message name.\\\",\\\"o|o|1D|q|1Fg\\\",\\\"Set of protobuf messages encoded.\\\",\\\"o|o|Al|v|1Fi\\\",\\\"CID of protobuf source file.\\\",\\\"o|t|1D|14|z|1Fk\\\",\\\"o|1Ff|1Fh|1Fj|1Fl\\\",\\\"Types are system records that define protocol-buffer schema of other records.\\\",\\\"o|1s|1Fc|1Fm|1Fn\\\",\\\"o|1FN|1FW|1Fo\\\",\\\"o|b|1F7|1FM|1Fp|\\\",\\\"o|1F3|1Fq\\\",\\\"o|1|1Fr\\\",\\\"github.com/dxos/kube/proto/def/dxos/rpc\\\",\\\"o|Me|1Ft\\\",\\\"Bye\\\",\\\"MessageTrace\\\",\\\"Request\\\",\\\"Response\\\",\\\"RpcMessage\\\",\\\"StreamClose\\\",\\\"a|1Fv|1Fw|1Fx|1Fy|1Fz|1G0\\\",\\\"Request to close the connection.\\\\nConnection is closed once both sides have received the Bye message.\\\",\\\"o|18|ZZ|1G2\\\",\\\"direction\\\",\\\"a|1G4|bd\\\",\\\"Direction\\\",\\\"o|o|1G6|q|\\\",\\\"o|1G5|1G7|n9\\\",\\\"a|1G6\\\",\\\"INCOMING\\\",\\\"OUTGOING\\\",\\\"a|1GA|1GB\\\",\\\"o|1GC|1R|q\\\",\\\"o|1GC||\\\",\\\"o|1N|1GD||1GE\\\",\\\"o|1G9|1GF\\\",\\\"o|En|1G8|1GG|\\\",\\\"method\\\",\\\"stream\\\",\\\"a|n|1GI|ac|1GJ\\\",\\\"o|o|1z|q|\\\",\\\"o|1GK|1GL|2i|GR|g3\\\",\\\"o|18|1GM|\\\",\\\"content\\\",\\\"a|1GO\\\",\\\"streamReady\\\",\\\"a|ac|C|180|1GQ\\\",\\\"o|5J|1GR|\\\",\\\"o|1GP|1GS\\\",\\\"a|n|ac|C|180|1GQ\\\",\\\"o|o|E9|14|\\\",\\\"Sent when stream is closed without an error.\\\",\\\"o|o|97|2S|1GW\\\",\\\"Sent when the server has processed a request with a streaming response.\\\\nCan be skipped by the server.\\\\nIn this case the first payload should be treated as the server being ready.\\\",\\\"o|o|97|4J|1GY\\\",\\\"o|1GU|1GL|vS|1GV|1GX|1GZ\\\",\\\"o|1s|1GT|1Ga|\\\",\\\"request\\\",\\\"openAck\\\",\\\"streamClose\\\",\\\"bye\\\",\\\"a|1Gc|6n|J1|1Gd|1Ge|1Gf\\\",\\\"o|5J|1Gg|\\\",\\\"o|1GP|1Gh\\\",\\\"o|o|1Fx|q|\\\",\\\"o|o|1Fy|v|\\\",\\\"Means that the node is trying to open the connection.\\\",\\\"o|o|97|14|1Gl\\\",\\\"Means that the node has received the \\\\\\\"open\\\\\\\" message and is ready to perform requests.\\\",\\\"o|o|97|2S|1Gn\\\",\\\"o|o|1G0|4J|\\\",\\\"Request to close the connection.\\\",\\\"o|o|1Fv|4M|1Gq\\\",\\\"o|1Gg|1Gj|1Gk|1Gm|1Go|1Gp|1Gr\\\",\\\"o|1s|1Gi|1Gs|\\\",\\\"o|6K|1GL\\\",\\\"o|18|1Gu|\\\",\\\"o|1G1|1G3|1GH|1GN|1Gb|1Gt|1Gv\\\",\\\"o|Mc|1Fu|1Gw\\\",\\\"agentmanager\\\",\\\"a|1Gy|VQ|VT|NQ\\\",\\\"github.com/dxos/kube/proto/def/dxos/service/agentmanager\\\",\\\"o|Me|1H0\\\",\\\"AgentManager\\\",\\\"Authentication\\\",\\\"InitAuthSequenceRequest\\\",\\\"InitAuthSequenceResponse\\\",\\\"a|1H2|1Bx|1H3|1H4|1H5\\\",\\\"InitAuthSequence\\\",\\\"a|1H7|Dc\\\",\\\"o|2p|1H4|1H5|\\\",\\\"o|2p|1H3|1Bx|\\\",\\\"o|1H8|1H9|1HA\\\",\\\"o|1Y|1HB|\\\",\\\"_token\\\",\\\"a|1HD|XF\\\",\\\"token\\\",\\\"a|1HF\\\",\\\"o|f|1HG\\\",\\\"o|1HE|1HH|XM\\\",\\\"a|1HF|XK\\\",\\\"o|t|KS|v|z|\\\",\\\"o|1HJ|6h|1HK\\\",\\\"o|1s|1HI|1HL|\\\",\\\"a|IM\\\",\\\"o|1HN|IO\\\",\\\"o|18|1HO|\\\",\\\"_authToken\\\",\\\"a|1HQ\\\",\\\"authToken\\\",\\\"a|1HS\\\",\\\"o|f|1HT\\\",\\\"o|1HR|1HU\\\",\\\"o|1HT|6h\\\",\\\"o|1s|1HV|1HW|\\\",\\\"_agentmanagerKey\\\",\\\"_initAuthResponseReason\\\",\\\"a|IG|1HY|1HZ\\\",\\\"agentmanagerKey\\\",\\\"a|1Hb\\\",\\\"o|f|1Hc\\\",\\\"initAuthResponseReason\\\",\\\"a|1He\\\",\\\"o|f|1Hf\\\",\\\"o|1Ha|IK|1Hd|1Hg\\\",\\\"result\\\",\\\"a|1Hi|II|1Hb|1He\\\",\\\"InitAuthSequenceResult\\\",\\\"o|o|1Hk|q|\\\",\\\"o|1Hj|1Hl|6i|pM|Nc\\\",\\\"a|1Hk\\\",\\\"NOT_AUTHORIZED\\\",\\\"a|wJ|D7|1Ho|DA\\\",\\\"o|1Hp|1R|q|v|14\\\",\\\"o|1Hp||||\\\",\\\"o|1N|1Hq||1Hr\\\",\\\"o|1Hn|1Hs\\\",\\\"o|b|1Hh|1Hm|1Ht|\\\",\\\"o|1H6|1HC|1HM|1HP|1HX|1Hu\\\",\\\"o|Mc|1H1|1Hv\\\",\\\"github.com/dxos/kube/proto/def/dxos/service/publisher\\\",\\\"o|Me|1Hx\\\",\\\"ListResponse\\\",\\\"PublishRequest\\\",\\\"PublishResponse\\\",\\\"ResetResponse\\\",\\\"a|1Hz|Vw|1I0|1I1|1I2\\\",\\\"a|OG\\\",\\\"dxos.config.Module\\\",\\\"o|12|13|1I5|q|\\\",\\\"o|1I4|1I6\\\",\\\"o|18|1I7|\\\",\\\"Publish\\\",\\\"List\\\",\\\"a|1I9|1IA|Lo\\\",\\\"o|2p|1I0|1I1|\\\",\\\"o|2p|1e|1Hz|\\\",\\\"o|2p|1e|1I2|\\\",\\\"o|1IB|1IC|1ID|1IE\\\",\\\"o|1Y|1IF|\\\",\\\"_accessToken\\\",\\\"a|1IH\\\",\\\"accessToken\\\",\\\"a|1IJ\\\",\\\"o|f|1IK\\\",\\\"o|1II|1IL\\\",\\\"skipExisting\\\",\\\"a|6w|1IN|1IJ\\\",\\\"dxos.config.Package\\\",\\\"o|o|1IP|q|\\\",\\\"o|1IO|1IQ|eA|4g\\\",\\\"o|1s|1IM|1IR|\\\",\\\"PublishedModule\\\",\\\"o|12|13|1IT|q|\\\",\\\"o|1I4|1IU\\\",\\\"a|1IT\\\",\\\"module\\\",\\\"a|1IX|XH\\\",\\\"o|o|1I5|q|\\\",\\\"o|1IY|1IZ|Up\\\",\\\"o|18|1Ia|\\\",\\\"o|1IW|1Ib\\\",\\\"o|En|1IV|1Ic|\\\",\\\"count\\\",\\\"a|1Ie\\\",\\\"o|1If|1GL\\\",\\\"o|18|1Ig|\\\",\\\"o|1I3|1I8|1IG|1IS|1Id|1Ih\\\",\\\"o|Mc|1Hy|1Ii\\\",\\\"github.com/dxos/kube/proto/def/dxos/service/supervisor\\\",\\\"o|Me|1Ik\\\",\\\"ConfigPair\\\",\\\"Service\\\",\\\"SetConfigRequest\\\",\\\"SetConfigResponse\\\",\\\"WellKnown\\\",\\\"WellKnowns\\\",\\\"a|1Bx|1H3|1Im|Z2|1H5|1In|P8|1Io|1Ip|Vy|1Iq|1Ir\\\",\\\"o|l4|1j|2i\\\",\\\"o|18|1It|\\\",\\\"o|o|6O|q|\\\",\\\"o|6F|1Iv\\\",\\\"o|18|1Iw|\\\",\\\"a|II|yG\\\",\\\"o|1Iy|68|MF\\\",\\\"o|18|1Iz|\\\",\\\"addresses\\\",\\\"wellKnowns\\\",\\\"a|5K|k|1J1|M|1J2\\\",\\\"o|o|p|v|\\\",\\\"o|12|13|1D|2S|\\\",\\\"o|o|Bz|4J|\\\",\\\"o|12|13|1Iq|4M|\\\",\\\"o|1J3|1j|1J4|1J5|1J6|1J7\\\",\\\"a|p|Bz\\\",\\\"STARTED\\\",\\\"FAILED\\\",\\\"a|wJ|1JA|4j|1JB\\\",\\\"o|1JC|1R|q|v|14\\\",\\\"o|1JC||||\\\",\\\"o|1N|1JD||1JE\\\",\\\"PROCESS\\\",\\\"SERVICE\\\",\\\"a|9V|1JG|1JH\\\",\\\"o|1JI|1R|q|v\\\",\\\"o|1JI|||\\\",\\\"o|1N|1JJ||1JK\\\",\\\"o|1J9|1JF|1JL\\\",\\\"o|En|1J8|1JM|\\\",\\\"o|12|13|1In|q|\\\",\\\"o|7C|1JO\\\",\\\"o|18|1JP|\\\",\\\"o|o|1Im|q|\\\",\\\"o|6F|1JR\\\",\\\"o|18|1JS|\\\",\\\"a|Dc|1H7|Ll|q3|p\\\",\\\"o|2p|1e|1H5|\\\",\\\"o|2p|1Io|1Ip|\\\",\\\"o|2p|1e|P8|\\\",\\\"o|1JU|1HA|1JV|Zz|1JW|1JX\\\",\\\"o|1Y|1JY|\\\",\\\"a|OO|NK\\\",\\\"o|1Ja|1j|2i\\\",\\\"o|18|1Jb|\\\",\\\"a|1J2\\\",\\\"WellKnownsByService\\\",\\\"o|12|13|1Je|q|\\\",\\\"o|1Jd|1Jf\\\",\\\"a|1Je\\\",\\\"serviceName\\\",\\\"a|1Ji|1J2\\\",\\\"o|12|13|1Iq|v|\\\",\\\"o|1Jj|1j|1Jk\\\",\\\"o|18|1Jl|\\\",\\\"o|1Jh|1Jm\\\",\\\"o|En|1Jg|1Jn|\\\",\\\"o|1Is|1HM|1HP|1Iu|1Ix|1J0|1JN|1JQ|1JT|1JT|1JZ|1Jc|1Jo\\\",\\\"o|Mc|1Il|1Jp\\\",\\\"github.com/dxos/kube/proto/def/dxos/service/tunnel\\\",\\\"o|Me|1Jr\\\",\\\"ListTunnelsResponse\\\",\\\"Tunnel\\\",\\\"TunnelRequest\\\",\\\"TunnelResponse\\\",\\\"a|1Jt|1Ju|1Jv|1Jw\\\",\\\"tunnels\\\",\\\"a|1Jy\\\",\\\"o|12|13|1Jw|q|\\\",\\\"o|1Jz|1K0\\\",\\\"o|18|1K1|\\\",\\\"ListTunnels\\\",\\\"a|1Ju|1K3\\\",\\\"o|2p|1Jv|1Jw|\\\",\\\"o|2p|1e|1Jt|\\\",\\\"o|1K4|1K5|1K6\\\",\\\"o|1Y|1K7|\\\",\\\"a|5K|PR\\\",\\\"o|1K9|1j|eA\\\",\\\"o|18|1KA|\\\",\\\"a|5K|PR|OO\\\",\\\"o|1KC|1j|eA|1I\\\",\\\"o|18|1KD|\\\",\\\"o|1Jx|1K2|1K8|1KB|1KE\\\",\\\"o|Mc|1Js|1KF\\\",\\\"o|1Gz|1Hw|1Ij|1Jq|1KG\\\",\\\"o|1|1KH\\\",\\\"Metric\\\",\\\"Resource\\\",\\\"ResourceLink\\\",\\\"Span\\\",\\\"StreamTraceEvent\\\",\\\"TraceLevel\\\",\\\"TracingService\\\",\\\"a|1KJ|1KK|1KL|1KM|1KN|1KO|1KP\\\",\\\"a|kw\\\",\\\"counter\\\",\\\"timeSeries\\\",\\\"multiCounter\\\",\\\"custom\\\",\\\"a|1KS|1KT|1KU|1KV\\\",\\\"o|5J|1KW|\\\",\\\"o|1KR|1KX\\\",\\\"a|5K|1KS|1KT|1KU|1KV\\\",\\\"Counter\\\",\\\"o|o|1Ka|Kf|\\\",\\\"TimeSeries\\\",\\\"o|o|1Kc|Nj|\\\",\\\"MultiCounter\\\",\\\"n|1e\\\",\\\"o|o|1Ke|1Kf|\\\",\\\"Custom\\\",\\\"n|3D\\\",\\\"o|o|1Kh|1Ki|\\\",\\\"o|1KZ|1j|1Kb|1Kd|1Kg|1Kj\\\",\\\"a|1Ka|1Kh|1Ke|1Kc\\\",\\\"_units\\\",\\\"a|1Km\\\",\\\"units\\\",\\\"a|1Ko\\\",\\\"o|f|1Kp\\\",\\\"o|1Kn|1Kq\\\",\\\"a|N|1Ko\\\",\\\"double\\\",\\\"o|o|1Kt|q|\\\",\\\"o|1Ks|1Ku|32\\\",\\\"o|1s|1Kr|1Kv|\\\",\\\"records\\\",\\\"a|1Kx|1Ko\\\",\\\"o|12|13|1F2|q|\\\",\\\"o|1Ky|1Kz|32\\\",\\\"o|o|1Kt|v|\\\",\\\"o|l4|1j|1L1\\\",\\\"o|18|1L2|\\\",\\\"o|1F3|1L3\\\",\\\"o|b|1Kr|1L0|1L4|\\\",\\\"tracks\\\",\\\"a|1L6\\\",\\\"Track\\\",\\\"o|12|13|1L8|q|\\\",\\\"o|1L7|1L9\\\",\\\"Point\\\",\\\"a|1LB|1L8\\\",\\\"o|F0|1Ku\\\",\\\"o|18|1LD|\\\",\\\"points\\\",\\\"a|5K|1Ko|1LF|19\\\",\\\"o|12|13|1LB|CL|\\\",\\\"o|o|1Kt|CO|\\\",\\\"o|1LG|1j|32|1LH|1LI\\\",\\\"o|1s|1Kr|1LJ|\\\",\\\"o|1LC|1LE|1LK\\\",\\\"o|En|1LA|1LL|\\\",\\\"o|1Kl|1Kw|1BW|1L5|1LM\\\",\\\"o|b|1KY|1Kk|1LN|\\\",\\\"className\\\",\\\"instanceId\\\",\\\"links\\\",\\\"a|n|1LP|1LQ|x0|1LR|Hz\\\",\\\"o|o|Al|2S|\\\",\\\"o|12|13|1KL|4J|\\\",\\\"o|12|13|1KJ|4M|\\\",\\\"o|1LS|1GL|2i|d0|1LT|1LU|1LV\\\",\\\"o|18|1LW|\\\",\\\"to\\\",\\\"attributes\\\",\\\"a|17N|1LY|1LZ\\\",\\\"o|1La|1GL|ER|1LT\\\",\\\"o|18|1Lb|\\\",\\\"_endTs\\\",\\\"a|oS|EF|1Ld|4U\\\",\\\"endTs\\\",\\\"a|1Lf\\\",\\\"o|f|1Lg\\\",\\\"o|1Le|oY|EM|1Lh|4d\\\",\\\"methodName\\\",\\\"startTs\\\",\\\"a|n|oW|EK|1Lj|1Lk|1Lf|C\\\",\\\"o|t|E9|CO|z|\\\",\\\"o|1Ll|1GL|2Q|2R|U2|UT|Qw|1Lm\\\",\\\"o|1s|1Li|1Ln|\\\",\\\"resourceAdded\\\",\\\"resourceRemoved\\\",\\\"spanAdded\\\",\\\"logAdded\\\",\\\"a|1Lp|1Lq|1Lr|1Ls\\\",\\\"ResourceAdded\\\",\\\"o|12|13|1Lu|q|\\\",\\\"ResourceRemoved\\\",\\\"o|12|13|1Lw|v|\\\",\\\"SpanAdded\\\",\\\"o|12|13|1Ly|14|\\\",\\\"LogAdded\\\",\\\"o|12|13|1M0|2S|\\\",\\\"o|1Lt|1Lv|1Lx|1Lz|1M1\\\",\\\"a|1M0|1Lu|1Lw|1Ly\\\",\\\"dxos.client.services.LogEntry\\\",\\\"o|o|1M4|q|\\\",\\\"o|Rk|1M5\\\",\\\"o|18|1M6|\\\",\\\"resource\\\",\\\"a|1M8\\\",\\\"o|o|1KK|q|\\\",\\\"o|1M9|1MA\\\",\\\"o|18|1MB|\\\",\\\"span\\\",\\\"a|1MD\\\",\\\"o|o|1KM|q|\\\",\\\"o|1ME|1MF\\\",\\\"o|18|1MG|\\\",\\\"o|1M3|1M7|1MC|1Gv|1MH\\\",\\\"o|En|1M2|1MI|\\\",\\\"DISABLED\\\",\\\"PRODUCTION\\\",\\\"DEVELOPMENT\\\",\\\"a|1MK|1ML|1MM|Eg\\\",\\\"o|1MN|1R|CL|Io|n3\\\",\\\"o|1MN||||\\\",\\\"o|1N|1MO||1MP\\\",\\\"StreamTrace\\\",\\\"a|1MR\\\",\\\"o|1d|1e|1KN|y|\\\",\\\"o|1MS|1MT\\\",\\\"o|1Y|1MU|\\\",\\\"o|1KQ|1LO|1LX|1Lc|1Lo|1MJ|1MQ|1MV\\\",\\\"o|1|1MW\\\",\\\"BotFactory\\\",\\\"File\\\",\\\"IPFS\\\",\\\"KUBE\\\",\\\"StateMachine\\\",\\\"a|P2|Vj|3O|1MY|1MZ|1Ma|1Mb|Ml|1In|FR|1Mc\\\",\\\"_extension\\\",\\\"a|Mp|OA|N9|5H|1Me\\\",\\\"web\\\",\\\"a|1Mg\\\",\\\"o|5J|1Mh|\\\",\\\"extension\\\",\\\"a|1Mj\\\",\\\"o|f|1Mk\\\",\\\"o|1Mf|Mt|OE|NP|1Mi|1Ml\\\",\\\"a|Mr|OC|NZ|NN|1Mg|1Mj\\\",\\\"Optional **semver 2.0** compliant record version.\\\\nShould conform to the semver regex (see https://semver.org/).\\\",\\\"o|t|1D|q|z|1Mo\\\",\\\"o|12|13|Ml|14|\\\",\\\"App bundle content Id in the CID v0 format (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats).\\\",\\\"o|t|67|2S|z|1Mr\\\",\\\"Web\\\",\\\"o|o|1Mt|Kf|\\\",\\\"dxos.registry.Record.Extension\\\",\\\"o|t|1Mv|Nl|z|\\\",\\\"o|1Mn|1Mp|32|1Mq|1Ms|1Mu|1Mw\\\",\\\"a|1Mt\\\",\\\"_indexFile\\\",\\\"_entryPoint\\\",\\\"a|1Mz|1N0\\\",\\\"indexFile\\\",\\\"a|1N2\\\",\\\"o|f|1N3\\\",\\\"entryPoint\\\",\\\"a|1N5\\\",\\\"o|f|1N6\\\",\\\"o|1N1|1N4|1N7\\\",\\\"a|1N2|1N5\\\",\\\"Relative path in resource to entrypoint, defaults to index.html.\\\",\\\"o|t|1D|q|z|1NA\\\",\\\"Relative path in resource to entrypoint, defaults to main.js.\\\",\\\"o|t|1D|v|z|1NC\\\",\\\"o|1N9|1NB|1ND\\\",\\\"o|1s|1N8|1NE|\\\",\\\"o|1My|1NF\\\",\\\"o|b|1Mm|1Mx|1NG|\\\",\\\"a|OO|1Mj\\\",\\\"o|o|1Mv|Kf|\\\",\\\"o|1NI|1j|1NJ\\\",\\\"o|18|1NK|\\\",\\\"a|Mr|OC|NZ|NN|5M|1Mj\\\",\\\"o|o|1D|q|1Mo\\\",\\\"Bot bundle content Id in the CID v0 format (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats).\\\",\\\"o|o|67|2S|1NO\\\",\\\"This would be the path to the bot executable in bot-factory's file-system.\\\",\\\"o|o|1D|4J|1NQ\\\",\\\"o|1NM|1NN|2i|1Mq|1NP|1NR|1NJ\\\",\\\"o|18|1NS|\\\",\\\"a|av|1Mj\\\",\\\"o|1NU|1j|1NJ\\\",\\\"o|18|1NV|\\\",\\\"fileName\\\",\\\"a|fg|1NX|NN|1Mj\\\",\\\"File content Id in the CID v0 format (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats).\\\",\\\"o|o|67|14|1NZ\\\",\\\"o|1NY|1j|2i|1Na|1NJ\\\",\\\"o|18|1Nb|\\\",\\\"a|mW|1J1|1Mj\\\",\\\"o|1Nd|1j|Up|1NJ\\\",\\\"o|18|1Ne|\\\",\\\"o|OS|1j|2i|1I\\\",\\\"o|18|1Ng|\\\",\\\"a|M|Ot|1Mj\\\",\\\"o|1Ni|1j|n9|1NJ\\\",\\\"o|18|1Nj|\\\",\\\"a|Uk|OO|1Mj\\\",\\\"o|1Nl|1j|2i|1NJ\\\",\\\"o|18|1Nm|\\\",\\\"mutationProtobufDefs\\\",\\\"snapshotProtobufDefs\\\",\\\"codeIpfsCid\\\",\\\"a|1No|1Np|1Nq\\\",\\\"Set of protobuf messages.\\\",\\\"o|o|Al|q|1Ns\\\",\\\"o|o|Al|v|1Ns\\\",\\\"o|o|67|14|\\\",\\\"o|1Nr|1Nt|1Nu|1Nv\\\",\\\"o|18|1Nw|\\\",\\\"o|1Md|1NH|1NL|1NT|1NW|1Nc|1Nf|1NL|1Nh|1Nk|1Nn|1Nx\\\",\\\"o|1|1Ny\\\",\\\"Stats\\\",\\\"a|1O0|kw\\\",\\\"_min\\\",\\\"_max\\\",\\\"_mean\\\",\\\"_median\\\",\\\"_total\\\",\\\"_count\\\",\\\"a|1O2|1O3|1O4|1O5|1O6|1O7\\\",\\\"min\\\",\\\"a|1O9\\\",\\\"o|f|1OA\\\",\\\"max\\\",\\\"a|1OC\\\",\\\"o|f|1OD\\\",\\\"mean\\\",\\\"a|1OF\\\",\\\"o|f|1OG\\\",\\\"median\\\",\\\"a|1OI\\\",\\\"o|f|1OJ\\\",\\\"a|19\\\",\\\"o|f|1OL\\\",\\\"o|f|1If\\\",\\\"o|1O8|1OB|1OE|1OH|1OK|1OM|1ON\\\",\\\"a|1O9|1OC|1OF|1OI|19|1Ie\\\",\\\"o|t|mo|q|z|\\\",\\\"o|t|mo|v|z|\\\",\\\"o|t|mo|14|z|\\\",\\\"o|t|mo|2S|z|\\\",\\\"o|t|mo|4J|z|\\\",\\\"o|t|mo|4M|z|\\\",\\\"o|1OP|1OQ|1OR|1OS|1OT|1OU|1OV\\\",\\\"o|1s|1OO|1OW|\\\",\\\"_bool\\\",\\\"_string\\\",\\\"_int\\\",\\\"_float\\\",\\\"a|1OY|1OZ|1Oa|1Ob\\\",\\\"a|97\\\",\\\"o|f|1Od\\\",\\\"a|1D\\\",\\\"o|f|1Of\\\",\\\"a|mn\\\",\\\"o|f|1Oh\\\",\\\"a|mo\\\",\\\"o|f|1Oj\\\",\\\"o|1Oc|1Oe|1Og|1Oi|1Ok\\\",\\\"a|97|1D|mn|mo\\\",\\\"o|1Om|98|32|2R|1OT\\\",\\\"o|1s|1Ol|1On|\\\",\\\"o|1O1|1OX|1Oo\\\",\\\"o|1|1Op\\\",\\\"o|O|3N|7A|Mb|Yr|gA|sH|sd|u4|13u|15n|15w|1F1|1Fs|1Gx|1KI|1MX|1Nz|1Oq\\\",\\\"o|1|1Or\\\",\\\"testing\\\",\\\"a|1Ot\\\",\\\"a|bd|J\\\",\\\"TestItemMutation\\\",\\\"TestItemSnapshot\\\",\\\"TestListMutation\\\",\\\"TestPayload\\\",\\\"a|1Ow|1Ox|1Oy|1Oz\\\",\\\"o|12|13|1Ow|q|\\\",\\\"o|AS|1P1\\\",\\\"o|18|1P2|\\\",\\\"o|1P0|1Iu|1P3|d9|d9\\\",\\\"o|1|1P4\\\",\\\"github.com/dxos/kube/proto/def/example/testing/rpc\\\",\\\"o|Me|1P6\\\",\\\"MessageWithAny\\\",\\\"PingReponse\\\",\\\"PingRequest\\\",\\\"PingService\\\",\\\"TestAnyService\\\",\\\"TestRpcRequest\\\",\\\"TestRpcResponse\\\",\\\"TestService\\\",\\\"TestServiceWithStreams\\\",\\\"TestStreamRpcRequest\\\",\\\"TestStreamRpcResponse\\\",\\\"TestStreamService\\\",\\\"a|1P8|1P9|1PA|1PB|1PC|1PD|1PE|1PF|1PG|1PH|1PI|1PJ\\\",\\\"o|IJ|1GL\\\",\\\"o|18|1PL|\\\",\\\"Ping\\\",\\\"a|1PN\\\",\\\"o|2p|1PA|1P9|\\\",\\\"o|1PO|1PP\\\",\\\"o|1Y|1PQ|\\\",\\\"TestCall\\\",\\\"a|1PS\\\",\\\"o|2p|1P8|1P8|\\\",\\\"o|1PT|1PU\\\",\\\"o|1Y|1PV|\\\",\\\"VoidCall\\\",\\\"a|1PS|1PX\\\",\\\"o|2p|1PD|1PE|\\\",\\\"o|1PY|1PZ|5D\\\",\\\"o|1Y|1Pa|\\\",\\\"RequestTestStream\\\",\\\"CloseTestStream\\\",\\\"a|1Pc|1Pd\\\",\\\"o|2p|1PH|1PE|\\\",\\\"o|2p|1PD|1PI|\\\",\\\"o|1Pe|1Pf|1Pg\\\",\\\"o|1Y|1Ph|\\\",\\\"streamLoadInterval\\\",\\\"streamLoadChunkSize\\\",\\\"a|bd|1Pj|1Pk\\\",\\\"o|1Pl|1j|c3|c4\\\",\\\"o|18|1Pm|\\\",\\\"sendErrors\\\",\\\"receiveErrors\\\",\\\"runningTime\\\",\\\"a|bd|fq|fr|1Po|1Pp|1Pq\\\",\\\"o|o|G8|4J|\\\",\\\"o|o|G8|4M|\\\",\\\"o|1Pr|1j|c3|c4|c5|1Ps|1Pt\\\",\\\"o|18|1Pu|\\\",\\\"o|1d|1PD|1PE|y|\\\",\\\"o|1PT|1Pw\\\",\\\"o|1Y|1Px|\\\",\\\"o|1PK|13G|1PM|1PM|1PR|1PW|d9|d9|1Pb|1Pi|1Pn|1Pv|1Py\\\",\\\"o|Mc|1P7|1Pz\\\",\\\"o|1Ov|1P5|1Q0\\\",\\\"o|1|1Q1\\\",\\\"o|1Ou|1Q2\\\",\\\"o|1|1Q3\\\",\\\"protobuf\\\",\\\"a|1Q5\\\",\\\"Any\\\",\\\"BoolValue\\\",\\\"BytesValue\\\",\\\"DescriptorProto\\\",\\\"DoubleValue\\\",\\\"Empty\\\",\\\"EnumDescriptorProto\\\",\\\"EnumOptions\\\",\\\"EnumValueDescriptorProto\\\",\\\"EnumValueOptions\\\",\\\"FieldDescriptorProto\\\",\\\"FieldOptions\\\",\\\"FileDescriptorProto\\\",\\\"FileDescriptorSet\\\",\\\"FileOptions\\\",\\\"FloatValue\\\",\\\"GeneratedCodeInfo\\\",\\\"Int32Value\\\",\\\"Int64Value\\\",\\\"ListValue\\\",\\\"MessageOptions\\\",\\\"MethodDescriptorProto\\\",\\\"MethodOptions\\\",\\\"NullValue\\\",\\\"OneofDescriptorProto\\\",\\\"OneofOptions\\\",\\\"ServiceDescriptorProto\\\",\\\"ServiceOptions\\\",\\\"SourceCodeInfo\\\",\\\"StringValue\\\",\\\"Struct\\\",\\\"Timestamp\\\",\\\"UInt32Value\\\",\\\"UInt64Value\\\",\\\"UninterpretedOption\\\",\\\"a|1Q7|1Q8|1Q9|1QA|1QB|1QC|1QD|1QE|1QF|1QG|1QH|1QI|1QJ|1QK|1QL|1QM|1QN|1QO|1QP|1QQ|1QR|1QS|1QT|1QU|1QV|1QW|1QX|1QY|1QZ|1Qa|1Qb|1Qc|1Qd|1Qe|1Qf|kw\\\",\\\"type_url\\\",\\\"a|1Qh|N\\\",\\\"a|M|n\\\",\\\"o|1Qj|1D|q\\\",\\\"o|1Qj|67|v\\\",\\\"o|1Qi|1Qk|1Ql\\\",\\\"o|18|1Qm|\\\",\\\"o|1Qj|97|q\\\",\\\"o|F0|1Qo\\\",\\\"o|18|1Qp|\\\",\\\"o|1Qj|67|q\\\",\\\"o|F0|1Qr\\\",\\\"o|18|1Qs|\\\",\\\"nestedType\\\",\\\"enumType\\\",\\\"extensionRange\\\",\\\"oneofDecl\\\",\\\"reservedRange\\\",\\\"reservedName\\\",\\\"a|5K|in|1Mj|1Qu|1Qv|1Qw|1Qx|s|1Qy|1Qz\\\",\\\"a|11|M|n\\\",\\\"o|1R1|13|1QH|v\\\",\\\"o|1R1|13|1QH|4M\\\",\\\"o|1R1|13|1QA|14\\\",\\\"o|1R1|13|1QD|2S\\\",\\\"ExtensionRange\\\",\\\"o|1R1|13|1R6|4J\\\",\\\"o|1R1|13|1QV|CF\\\",\\\"o|1Qj|1QR|4O\\\",\\\"ReservedRange\\\",\\\"o|1R1|13|1RA|CI\\\",\\\"o|1R1|13|1D|CL\\\",\\\"o|1R0|1Qk|1R2|1R3|1R4|1R5|1R7|1R8|1R9|1RB|1RC\\\",\\\"a|1R6|1RA\\\",\\\"start\\\",\\\"end\\\",\\\"a|1RF|1RG\\\",\\\"o|1Qj|1z|q\\\",\\\"o|1Qj|1z|v\\\",\\\"o|1RH|1RI|1RJ\\\",\\\"o|18|1RK|\\\",\\\"o|1RE|1RL|1RL\\\",\\\"o|En|1RD|1RM|\\\",\\\"o|1Qj|1Kt|q\\\",\\\"o|F0|1RO\\\",\\\"o|18|1RP|\\\",\\\"a|5K|N|s\\\",\\\"o|1R1|13|1QF|v\\\",\\\"o|1Qj|1QE|14\\\",\\\"o|1RR|1Qk|1RS|1RT\\\",\\\"o|18|1RU|\\\",\\\"extensions\\\",\\\"a|Z|1RW|a\\\",\\\"allowAlias\\\",\\\"deprecated\\\",\\\"uninterpretedOption\\\",\\\"a|1RY|1RZ|1Ra\\\",\\\"o|1Qj|97|v\\\",\\\"o|1Qj|97|14\\\",\\\"n|G7\\\",\\\"o|1R1|13|1Qf|1Re\\\",\\\"o|1Rb|1Rc|1Rd|1Rf\\\",\\\"n|aKeeF\\\",\\\"a|N2|1Rh\\\",\\\"a|1Ri\\\",\\\"o|1RX|1Rg|1Rj|\\\",\\\"a|5K|wg|s\\\",\\\"o|1Qj|1QG|14\\\",\\\"o|1Rl|1Qk|1RJ|1Rm\\\",\\\"o|18|1Rn|\\\",\\\"a|1RZ|1Ra\\\",\\\"o|1Rp|1Qo|1Rf\\\",\\\"o|1RX|1Rq|1Rj|\\\",\\\"typeName\\\",\\\"extendee\\\",\\\"defaultValue\\\",\\\"oneofIndex\\\",\\\"jsonName\\\",\\\"a|5K|wg|dS|M|1Rs|1Rt|1Ru|1Rv|1Rw|s\\\",\\\"o|1Qj|1z|14\\\",\\\"Label\\\",\\\"o|1Qj|1Rz|2S\\\",\\\"o|1Qj|Bz|4J\\\",\\\"o|1Qj|1D|4M\\\",\\\"o|1Qj|1D|v\\\",\\\"o|1Qj|1D|4O\\\",\\\"o|1Qj|1z|CI\\\",\\\"o|1Qj|1D|CL\\\",\\\"o|1Qj|1QI|CF\\\",\\\"o|1Rx|1Qk|1Ry|1S0|1S1|1S2|1S3|1S4|1S5|1S6|1S7\\\",\\\"a|1Rz|Bz\\\",\\\"a|1L|1M\\\",\\\"LABEL_OPTIONAL\\\",\\\"LABEL_REQUIRED\\\",\\\"LABEL_REPEATED\\\",\\\"a|1SB|1SC|1SD\\\",\\\"o|1SE|q|v|14\\\",\\\"o|1SA|1SF|ZZ\\\",\\\"TYPE_DOUBLE\\\",\\\"TYPE_FLOAT\\\",\\\"TYPE_INT64\\\",\\\"TYPE_UINT64\\\",\\\"TYPE_INT32\\\",\\\"TYPE_FIXED64\\\",\\\"TYPE_FIXED32\\\",\\\"TYPE_BOOL\\\",\\\"TYPE_STRING\\\",\\\"TYPE_GROUP\\\",\\\"TYPE_MESSAGE\\\",\\\"TYPE_BYTES\\\",\\\"TYPE_UINT32\\\",\\\"TYPE_ENUM\\\",\\\"TYPE_SFIXED32\\\",\\\"TYPE_SFIXED64\\\",\\\"TYPE_SINT32\\\",\\\"TYPE_SINT64\\\",\\\"a|1SH|1SI|1SJ|1SK|1SL|1SM|1SN|1SO|1SP|1SQ|1SR|1SS|1ST|1SU|1SV|1SW|1SX|1SY\\\",\\\"o|1SZ|q|v|14|2S|4J|4M|4O|CF|CI|CL|CO|CR|CU|CW|CY|Cb|Ce|Ci\\\",\\\"o|1SA|1Sa|ZZ\\\",\\\"o|1S9|1SG|1Sb\\\",\\\"o|En|1S8|1Sc|\\\",\\\"a|Z|1RW|9i|0|a\\\",\\\"ctype\\\",\\\"packed\\\",\\\"jstype\\\",\\\"lazy\\\",\\\"weak\\\",\\\"a|1Sf|1Sg|1Sh|1Si|1RZ|1Sj|1Ra\\\",\\\"a|M|n|s\\\",\\\"CType\\\",\\\"default\\\",\\\"a|1Sn\\\",\\\"STRING\\\",\\\"o|1So|1Sp\\\",\\\"o|1Sl|1Sm|q|1Sq\\\",\\\"JSType\\\",\\\"JS_NORMAL\\\",\\\"o|1So|1St\\\",\\\"o|1Sl|1Ss|4M|1Su\\\",\\\"o|1Qj|97|4J\\\",\\\"o|1Qj|97|CL\\\",\\\"o|1Sk|1Sr|1Rc|1Sv|1Sw|1Rd|1Sx|1Rf\\\",\\\"a|2S|2S\\\",\\\"a|1Sz\\\",\\\"a|1Sm|1Ss\\\",\\\"CORD\\\",\\\"STRING_PIECE\\\",\\\"a|1Sp|1T2|1T3\\\",\\\"o|1T4|1R|q|v\\\",\\\"o|1SA|1T5|ZZ\\\",\\\"JS_STRING\\\",\\\"JS_NUMBER\\\",\\\"a|1St|1T7|1T8\\\",\\\"o|1T9|1R|q|v\\\",\\\"o|1SA|1TA|ZZ\\\",\\\"o|1T1|1T6|1TB\\\",\\\"o|1Se|1Sy|1Rj|1T0|1TC|\\\",\\\"dependency\\\",\\\"publicDependency\\\",\\\"weakDependency\\\",\\\"messageType\\\",\\\"sourceCodeInfo\\\",\\\"syntax\\\",\\\"a|5K|6w|1TE|1TF|1TG|1TH|1Qv|K|1Mj|s|1TI|1TJ\\\",\\\"o|1R1|13|1D|14\\\",\\\"a|11|M|n|s\\\",\\\"a|1Sg\\\",\\\"b|F\\\",\\\"o|1TN|1TO\\\",\\\"o|1TM|13|1z|CL|1TP\\\",\\\"o|1TM|13|1z|CO|1TP\\\",\\\"o|1R1|13|1QA|2S\\\",\\\"o|1R1|13|1QD|4J\\\",\\\"o|1R1|13|1QX|4M\\\",\\\"o|1R1|13|1QH|4O\\\",\\\"o|1Qj|1QL|CF\\\",\\\"o|1Qj|1QZ|CI\\\",\\\"o|1Qj|1D|CR\\\",\\\"o|1TK|1Qk|1S3|1TL|1TQ|1TR|1TS|1TT|1TU|1TV|1TW|1TX|1TY\\\",\\\"o|18|1TZ|\\\",\\\"a|EO\\\",\\\"o|1R1|13|1QJ|q\\\",\\\"o|1Tb|1Tc\\\",\\\"o|18|1Td|\\\",\\\"javaPackage\\\",\\\"javaOuterClassname\\\",\\\"javaMultipleFiles\\\",\\\"javaGenerateEqualsAndHash\\\",\\\"javaStringCheckUtf8\\\",\\\"optimizeFor\\\",\\\"goPackage\\\",\\\"ccGenericServices\\\",\\\"javaGenericServices\\\",\\\"pyGenericServices\\\",\\\"ccEnableArenas\\\",\\\"objcClassPrefix\\\",\\\"csharpNamespace\\\",\\\"a|1Tf|1Tg|1Th|1Ti|1Tj|1Tk|1Tl|1Tm|1Tn|1To|1RZ|1Tp|1Tq|1Tr|1Ra\\\",\\\"o|1Qj|1D|CF\\\",\\\"a|1RZ\\\",\\\"o|1Tu|y\\\",\\\"o|1Sl|97|Io|1Tv\\\",\\\"n|R\\\",\\\"o|1Qj|97|1Tx\\\",\\\"OptimizeMode\\\",\\\"SPEED\\\",\\\"o|1So|1U0\\\",\\\"o|1Sl|1Tz|CI|1U1\\\",\\\"o|1Qj|1D|CO\\\",\\\"o|1Qj|97|Cb\\\",\\\"o|1Qj|97|Ce\\\",\\\"o|1Qj|97|Ci\\\",\\\"n|N\\\",\\\"o|1Qj|97|1U7\\\",\\\"n|V\\\",\\\"o|1Qj|97|1U9\\\",\\\"n|a\\\",\\\"o|1Qj|1D|1UB\\\",\\\"n|b\\\",\\\"o|1Qj|1D|1UD\\\",\\\"o|1Ts|1Qk|1Tt|1Sx|1Tw|1Ty|1U2|1U3|1U4|1U5|1U6|1U8|1UA|1UC|1UE|1Rf\\\",\\\"n|c\\\",\\\"a|1UG|1UG\\\",\\\"a|1UH\\\",\\\"a|1Tz\\\",\\\"CODE_SIZE\\\",\\\"LITE_RUNTIME\\\",\\\"a|1U0|1UK|1UL\\\",\\\"o|1UM|q|v|14\\\",\\\"o|1SA|1UN|ZZ\\\",\\\"o|1UJ|1UO\\\",\\\"o|1Se|1UF|1Rj|1UI|1UP|\\\",\\\"o|1Qj|mo|q\\\",\\\"o|F0|1UR\\\",\\\"o|18|1US|\\\",\\\"annotation\\\",\\\"a|1UU\\\",\\\"Annotation\\\",\\\"o|1R1|13|1UW|q\\\",\\\"o|1UV|1UX\\\",\\\"a|1UW\\\",\\\"path\\\",\\\"sourceFile\\\",\\\"begin\\\",\\\"a|1Ua|1Ub|1Uc|1RG\\\",\\\"o|1R1|13|1z|q\\\",\\\"o|1Qj|1z|2S\\\",\\\"o|1Ud|1Ue|1S3|1Ry|1Uf\\\",\\\"o|18|1Ug|\\\",\\\"o|1UZ|1Uh\\\",\\\"o|En|1UY|1Ui|\\\",\\\"o|F0|1RI\\\",\\\"o|18|1Uk|\\\",\\\"o|1Qj|mv|q\\\",\\\"o|F0|1Um\\\",\\\"o|18|1Un|\\\",\\\"o|1R1|13|kw|q\\\",\\\"o|kz|1Up\\\",\\\"o|18|1Uq|\\\",\\\"a|Z|1RW|9i|a\\\",\\\"messageSetWireFormat\\\",\\\"noStandardDescriptorAccessor\\\",\\\"mapEntry\\\",\\\"a|1Ut|1Uu|1RZ|1Uv|1Ra\\\",\\\"o|1Qj|97|4O\\\",\\\"o|1Uw|1Qo|1Rc|1Rd|1Ux|1Rf\\\",\\\"a|CF|CF\\\",\\\"a|1Uz\\\",\\\"o|1Us|1Uy|1Rj|1V0|\\\",\\\"inputType\\\",\\\"outputType\\\",\\\"clientStreaming\\\",\\\"serverStreaming\\\",\\\"a|5K|1V2|1V3|s|1V4|1V5\\\",\\\"o|1Qj|1D|14\\\",\\\"o|1Qj|1QT|2S\\\",\\\"o|1Qj|97|4M\\\",\\\"o|1V6|1Qk|1S3|1V7|1V8|1Sw|1V9\\\",\\\"o|18|1VA|\\\",\\\"n|X\\\",\\\"o|1Qj|97|1VC\\\",\\\"o|1Rp|1VD|1Rf\\\",\\\"o|1RX|1VE|1Rj|\\\",\\\"NULL_VALUE\\\",\\\"a|1VG\\\",\\\"o|1VH|1R\\\",\\\"o|1SA|1VI|ZZ\\\",\\\"a|5K|s\\\",\\\"o|1Qj|1QW|v\\\",\\\"o|1VK|1Qk|1VL\\\",\\\"o|18|1VM|\\\",\\\"a|1Ra\\\",\\\"o|1VO|1Rf\\\",\\\"o|1RX|1VP|1Rj|\\\",\\\"a|5K|1GI|s\\\",\\\"o|1R1|13|1QS|v\\\",\\\"o|1Qj|1QY|14\\\",\\\"o|1VR|1Qk|1VS|1VT\\\",\\\"o|18|1VU|\\\",\\\"location\\\",\\\"a|1VW\\\",\\\"Location\\\",\\\"o|1R1|13|1VY|q\\\",\\\"o|1VX|1VZ\\\",\\\"a|1VY\\\",\\\"leadingComments\\\",\\\"trailingComments\\\",\\\"leadingDetachedComments\\\",\\\"a|1Ua|1MD|1Vc|1Vd|1Ve\\\",\\\"o|1R1|13|1z|v\\\",\\\"o|1Qj|1D|2S\\\",\\\"o|1R1|13|1D|4M\\\",\\\"o|1Vf|1Ue|1Vg|1V7|1Vh|1Vi\\\",\\\"o|18|1Vj|\\\",\\\"o|1Vb|1Vk\\\",\\\"o|En|1Va|1Vl|\\\",\\\"o|F0|1Qk\\\",\\\"o|18|1Vn|\\\",\\\"a|Z\\\",\\\"a|x2|M|n\\\",\\\"o|1Vq|1D|kw|q\\\",\\\"o|1Vp|1Vr\\\",\\\"o|18|1Vs|\\\",\\\"seconds\\\",\\\"nanos\\\",\\\"a|1Vu|1Vv\\\",\\\"o|1Vw|1Um|1RJ\\\",\\\"o|18|1Vx|\\\",\\\"o|1Qj|G8|q\\\",\\\"o|F0|1Vz\\\",\\\"o|18|1W0|\\\",\\\"uint64\\\",\\\"o|1Qj|1W2|q\\\",\\\"o|F0|1W3\\\",\\\"o|18|1W4|\\\",\\\"identifierValue\\\",\\\"positiveIntValue\\\",\\\"negativeIntValue\\\",\\\"doubleValue\\\",\\\"stringValue\\\",\\\"aggregateValue\\\",\\\"a|5K|1W6|1W7|1W8|1W9|1WA|1WB\\\",\\\"NamePart\\\",\\\"o|1R1|13|1WD|v\\\",\\\"o|1Qj|1W2|2S\\\",\\\"o|1Qj|mv|4J\\\",\\\"o|1Qj|1Kt|4M\\\",\\\"o|1Qj|67|4O\\\",\\\"o|1WC|1WE|1V7|1WF|1WG|1WH|1WI|1Tt\\\",\\\"a|1WD\\\",\\\"namePart\\\",\\\"isExtension\\\",\\\"a|1WL|1WM\\\",\\\"required\\\",\\\"o|1R1|1WO|1D|q\\\",\\\"o|1R1|1WO|97|v\\\",\\\"o|1WN|1WP|1WQ\\\",\\\"o|18|1WR|\\\",\\\"o|1WK|1WS\\\",\\\"o|En|1WJ|1WT|\\\",\\\"nullValue\\\",\\\"numberValue\\\",\\\"boolValue\\\",\\\"structValue\\\",\\\"listValue\\\",\\\"a|1WV|1WW|1WA|1WX|1WY|1WZ\\\",\\\"o|f|1Wa\\\",\\\"o|5I|1Wb\\\",\\\"o|1Qj|1QU|q\\\",\\\"o|1Qj|1Kt|v\\\",\\\"o|1Qj|97|2S\\\",\\\"o|1Qj|1Qb|4J\\\",\\\"o|1Qj|1QQ|4M\\\",\\\"o|1Wa|1Wd|1We|1V7|1Wf|1Wg|1Wh\\\",\\\"o|1s|1Wc|1Wi|\\\",\\\"o|1Qg|1Qn|1Qq|1Qt|1RN|1RQ|Za|1RV|1Rk|1Ro|1Rr|1Sd|1TD|1Ta|1Te|1UQ|1UT|1Uj|1Ul|1Uo|1Ur|1V1|1VB|1VF|1VJ|1VN|1VQ|1VV|1VF|1Vm|1Vo|1Vt|1Vy|1W1|1W5|1WU|1Wj\\\",\\\"o|1|1Wk\\\",\\\"o|1Q6|1Wl\\\",\\\"o|1|1Wm\\\",\\\"o|5|1Os|1Q4|1Wn\\\",\\\"o|1|1Wo\\\"],\\\"1Wp\\\"]\"));\nexport const schema = Schema.fromJson(schemaJson, substitutions);\n//# sourceMappingURL=index.js.map","import \"@dxos/node-std/globals\";\n\n// inject-globals:@inject-globals\nimport {\n  global,\n  Buffer,\n  process\n} from \"@dxos/node-std/inject-globals\";\n\n// packages/core/mesh/rpc/src/rpc.ts\nimport { asyncTimeout, synchronized, Trigger } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { StackTrace as StackTrace2 } from \"@dxos/debug\";\nimport { invariant } from \"@dxos/invariant\";\nimport { log } from \"@dxos/log\";\nimport { encodeError, RpcClosedError, RpcNotOpenError, schema } from \"@dxos/protocols\";\nimport { exponentialBackoffInterval } from \"@dxos/util\";\n\n// packages/core/mesh/rpc/src/errors.ts\nimport { StackTrace } from \"@dxos/debug\";\nimport { decodeError } from \"@dxos/protocols\";\nvar decodeRpcError = (err, rpcMethod) => decodeError(err, {\n  appendStack: `\n    at RPC ${rpcMethod} \n` + new StackTrace().getStack(1)\n});\n\n// packages/core/mesh/rpc/src/rpc.ts\nfunction _ts_decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nvar __dxlog_file = \"/home/runner/work/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\";\nvar DEFAULT_TIMEOUT = 3e3;\nvar BYE_SEND_TIMEOUT = 2e3;\nvar DEBUG_CALLS = true;\nvar CLOSE_TIMEOUT = 3e3;\nvar PendingRpcRequest = class {\n  constructor(resolve, reject, stream) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.stream = stream;\n  }\n};\nvar RpcMessage = schema.getCodecForType(\"dxos.rpc.RpcMessage\");\nvar RpcState;\n(function(RpcState2) {\n  RpcState2[\"INITIAL\"] = \"INITIAL\";\n  RpcState2[\"OPENING\"] = \"OPENING\";\n  RpcState2[\"OPENED\"] = \"OPENED\";\n  RpcState2[\"CLOSING\"] = \"CLOSING\";\n  RpcState2[\"CLOSED\"] = \"CLOSED\";\n})(RpcState || (RpcState = {}));\nvar RpcPeer = class {\n  constructor(params) {\n    this._outgoingRequests = /* @__PURE__ */ new Map();\n    this._localStreams = /* @__PURE__ */ new Map();\n    this._remoteOpenTrigger = new Trigger();\n    /**\n    * Triggered when the peer starts closing.\n    */\n    this._closingTrigger = new Trigger();\n    /**\n    * Triggered when peer receives a bye message.\n    */\n    this._byeTrigger = new Trigger();\n    this._nextId = 0;\n    this._state = \"INITIAL\";\n    this._unsubscribeFromPort = void 0;\n    this._clearOpenInterval = void 0;\n    this._params = {\n      timeout: void 0,\n      streamHandler: void 0,\n      noHandshake: false,\n      ...params\n    };\n  }\n  /**\n  * Open the peer. Required before making any calls.\n  *\n  * Will block before the other peer calls `open`.\n  */\n  async open() {\n    if (this._state !== \"INITIAL\") {\n      return;\n    }\n    this._unsubscribeFromPort = this._params.port.subscribe(async (msg) => {\n      try {\n        await this._receive(msg);\n      } catch (err) {\n        log.catch(err, void 0, {\n          F: __dxlog_file,\n          L: 153,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n      }\n    });\n    this._state = \"OPENING\";\n    if (this._params.noHandshake) {\n      this._state = \"OPENED\";\n      this._remoteOpenTrigger.wake();\n      return;\n    }\n    log(\"sending open message\", {\n      state: this._state\n    }, {\n      F: __dxlog_file,\n      L: 165,\n      S: this,\n      C: (f, a) => f(...a)\n    });\n    await this._sendMessage({\n      open: true\n    });\n    if (this._state !== \"OPENING\") {\n      return;\n    }\n    this._clearOpenInterval = exponentialBackoffInterval(() => {\n      void this._sendMessage({\n        open: true\n      }).catch((err) => log.warn(err, void 0, {\n        F: __dxlog_file,\n        L: 174,\n        S: this,\n        C: (f, a) => f(...a)\n      }));\n    }, 50);\n    await Promise.race([\n      this._remoteOpenTrigger.wait(),\n      this._closingTrigger.wait()\n    ]);\n    this._clearOpenInterval?.();\n    if (this._state !== \"OPENED\") {\n      return;\n    }\n    log(\"sending second open message\", {\n      state: this._state\n    }, {\n      F: __dxlog_file,\n      L: 188,\n      S: this,\n      C: (f, a) => f(...a)\n    });\n    await this._sendMessage({\n      openAck: true\n    });\n  }\n  /**\n  * Close the peer.\n  * Stop taking or making requests.\n  * Will wait for confirmation from the other side.\n  * Any responses for RPC calls made before close will be delivered.\n  */\n  async close({ timeout = CLOSE_TIMEOUT } = {}) {\n    if (this._state === \"CLOSED\") {\n      return;\n    }\n    this._abortRequests();\n    if (this._state === \"OPENED\" && !this._params.noHandshake) {\n      try {\n        this._state = \"CLOSING\";\n        await this._sendMessage({\n          bye: {}\n        }, BYE_SEND_TIMEOUT);\n      } catch (err) {\n        log(\"error closing peer, sending bye\", {\n          err\n        }, {\n          F: __dxlog_file,\n          L: 210,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n      }\n      try {\n        log(\"closing waiting on bye\", void 0, {\n          F: __dxlog_file,\n          L: 213,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        await this._byeTrigger.wait({\n          timeout\n        });\n      } catch (err) {\n        log(\"error closing peer\", {\n          err\n        }, {\n          F: __dxlog_file,\n          L: 216,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        return;\n      }\n    }\n    this._disposeAndClose();\n  }\n  /**\n  * Dispose the connection without waiting for the other side.\n  */\n  async abort() {\n    if (this._state === \"CLOSED\") {\n      return;\n    }\n    this._abortRequests();\n    this._disposeAndClose();\n  }\n  _abortRequests() {\n    this._clearOpenInterval?.();\n    this._closingTrigger.wake();\n    for (const req of this._outgoingRequests.values()) {\n      req.reject(new RpcClosedError());\n    }\n    this._outgoingRequests.clear();\n  }\n  _disposeAndClose() {\n    this._unsubscribeFromPort?.();\n    this._unsubscribeFromPort = void 0;\n    this._clearOpenInterval?.();\n    this._state = \"CLOSED\";\n  }\n  /**\n  * Handle incoming message. Should be called as the result of other peer's `send` callback.\n  */\n  async _receive(msg) {\n    const decoded = RpcMessage.decode(msg, {\n      preserveAny: true\n    });\n    DEBUG_CALLS && log(\"received message\", {\n      type: Object.keys(decoded)[0]\n    }, {\n      F: __dxlog_file,\n      L: 260,\n      S: this,\n      C: (f, a) => f(...a)\n    });\n    if (decoded.request) {\n      if (this._state !== \"OPENED\" && this._state !== \"OPENING\") {\n        log(\"received request while closed\", void 0, {\n          F: __dxlog_file,\n          L: 264,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        await this._sendMessage({\n          response: {\n            id: decoded.request.id,\n            error: encodeError(new RpcClosedError())\n          }\n        });\n        return;\n      }\n      const req = decoded.request;\n      if (req.stream) {\n        log(\"stream request\", {\n          method: req.method\n        }, {\n          F: __dxlog_file,\n          L: 276,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        this._callStreamHandler(req, (response) => {\n          log(\"sending stream response\", {\n            method: req.method,\n            response: response.payload?.type_url,\n            error: response.error,\n            close: response.close\n          }, {\n            F: __dxlog_file,\n            L: 278,\n            S: this,\n            C: (f, a) => f(...a)\n          });\n          void this._sendMessage({\n            response\n          }).catch((err) => {\n            log.warn(\"failed during close\", err, {\n              F: __dxlog_file,\n              L: 286,\n              S: this,\n              C: (f, a) => f(...a)\n            });\n          });\n        });\n      } else {\n        DEBUG_CALLS && log(\"request\", {\n          method: req.method\n        }, {\n          F: __dxlog_file,\n          L: 290,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        const response = await this._callHandler(req);\n        DEBUG_CALLS && log(\"sending response\", {\n          method: req.method,\n          response: response.payload?.type_url,\n          error: response.error\n        }, {\n          F: __dxlog_file,\n          L: 293,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        await this._sendMessage({\n          response\n        });\n      }\n    } else if (decoded.response) {\n      if (this._state !== \"OPENED\") {\n        log(\"received response while closed\", void 0, {\n          F: __dxlog_file,\n          L: 302,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        return;\n      }\n      const responseId = decoded.response.id;\n      invariant(typeof responseId === \"number\", void 0, {\n        F: __dxlog_file,\n        L: 307,\n        S: this,\n        A: [\n          \"typeof responseId === 'number'\",\n          \"\"\n        ]\n      });\n      if (!this._outgoingRequests.has(responseId)) {\n        log(\"received response with invalid id\", {\n          responseId\n        }, {\n          F: __dxlog_file,\n          L: 309,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        return;\n      }\n      const item = this._outgoingRequests.get(responseId);\n      if (!item.stream) {\n        this._outgoingRequests.delete(responseId);\n      }\n      DEBUG_CALLS && log(\"response\", {\n        type_url: decoded.response.payload?.type_url\n      }, {\n        F: __dxlog_file,\n        L: 319,\n        S: this,\n        C: (f, a) => f(...a)\n      });\n      item.resolve(decoded.response);\n    } else if (decoded.open) {\n      log(\"received open message\", {\n        state: this._state\n      }, {\n        F: __dxlog_file,\n        L: 322,\n        S: this,\n        C: (f, a) => f(...a)\n      });\n      if (this._params.noHandshake) {\n        return;\n      }\n      await this._sendMessage({\n        openAck: true\n      });\n    } else if (decoded.openAck) {\n      log(\"received openAck message\", {\n        state: this._state\n      }, {\n        F: __dxlog_file,\n        L: 329,\n        S: this,\n        C: (f, a) => f(...a)\n      });\n      if (this._params.noHandshake) {\n        return;\n      }\n      this._state = \"OPENED\";\n      this._remoteOpenTrigger.wake();\n    } else if (decoded.streamClose) {\n      if (this._state !== \"OPENED\") {\n        log(\"received stream close while closed\", void 0, {\n          F: __dxlog_file,\n          L: 338,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        return;\n      }\n      log(\"received stream close\", {\n        id: decoded.streamClose.id\n      }, {\n        F: __dxlog_file,\n        L: 342,\n        S: this,\n        C: (f, a) => f(...a)\n      });\n      invariant(typeof decoded.streamClose.id === \"number\", void 0, {\n        F: __dxlog_file,\n        L: 343,\n        S: this,\n        A: [\n          \"typeof decoded.streamClose.id === 'number'\",\n          \"\"\n        ]\n      });\n      const stream = this._localStreams.get(decoded.streamClose.id);\n      if (!stream) {\n        log(\"no local stream\", {\n          id: decoded.streamClose.id\n        }, {\n          F: __dxlog_file,\n          L: 346,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        return;\n      }\n      this._localStreams.delete(decoded.streamClose.id);\n      await stream.close();\n    } else if (decoded.bye) {\n      this._byeTrigger.wake();\n      if (this._state !== \"CLOSING\" && this._state !== \"CLOSED\") {\n        log(\"replying to bye\", void 0, {\n          F: __dxlog_file,\n          L: 356,\n          S: this,\n          C: (f, a) => f(...a)\n        });\n        this._state = \"CLOSING\";\n        await this._sendMessage({\n          bye: {}\n        });\n        this._abortRequests();\n        this._disposeAndClose();\n      }\n    } else {\n      log.error(\"received malformed message\", {\n        msg\n      }, {\n        F: __dxlog_file,\n        L: 364,\n        S: this,\n        C: (f, a) => f(...a)\n      });\n      throw new Error(\"Malformed message.\");\n    }\n  }\n  /**\n  * Make RPC call. Will trigger a handler on the other side.\n  * Peer should be open before making this call.\n  */\n  async call(method, request, options) {\n    DEBUG_CALLS && log(\"calling\", {\n      method\n    }, {\n      F: __dxlog_file,\n      L: 374,\n      S: this,\n      C: (f, a) => f(...a)\n    });\n    throwIfNotOpen(this._state);\n    let response;\n    try {\n      const id = this._nextId++;\n      const responseReceived = new Promise((resolve, reject) => {\n        this._outgoingRequests.set(id, new PendingRpcRequest(resolve, reject, false));\n      });\n      const sending = this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: false\n        }\n      });\n      const timeout = options?.timeout ?? this._params.timeout;\n      const waiting = timeout === 0 ? responseReceived : asyncTimeout(responseReceived, timeout ?? DEFAULT_TIMEOUT);\n      await Promise.race([\n        sending,\n        waiting\n      ]);\n      response = await waiting;\n      invariant(response.id === id, void 0, {\n        F: __dxlog_file,\n        L: 402,\n        S: this,\n        A: [\n          \"response.id === id\",\n          \"\"\n        ]\n      });\n    } catch (err) {\n      if (err instanceof RpcClosedError) {\n        const error = new RpcClosedError();\n        error.stack += `\n\n info: RPC client was closed at:\n${err.stack?.split(\"\\n\").slice(1).join(\"\\n\")}`;\n        throw error;\n      }\n      throw err;\n    }\n    if (response.payload) {\n      return response.payload;\n    } else if (response.error) {\n      throw decodeRpcError(response.error, method);\n    } else {\n      throw new Error(\"Malformed response.\");\n    }\n  }\n  /**\n  * Make RPC call with a streaming response.\n  * Will trigger a handler on the other side.\n  * Peer should be open before making this call.\n  */\n  callStream(method, request, options) {\n    throwIfNotOpen(this._state);\n    const id = this._nextId++;\n    return new Stream(({ ready, next, close }) => {\n      const onResponse = (response) => {\n        if (response.streamReady) {\n          ready();\n        } else if (response.close) {\n          close();\n        } else if (response.error) {\n          close(decodeRpcError(response.error, method));\n        } else if (response.payload) {\n          next(response.payload);\n        } else {\n          throw new Error(\"Malformed response.\");\n        }\n      };\n      const stack = new StackTrace2();\n      const closeStream = (err) => {\n        if (!err) {\n          close();\n        } else {\n          err.stack += `\n\nError happened in the stream at:\n${stack.getStack()}`;\n          close(err);\n        }\n      };\n      this._outgoingRequests.set(id, new PendingRpcRequest(onResponse, closeStream, true));\n      this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: true\n        }\n      }).catch((err) => {\n        close(err);\n      });\n      return () => {\n        this._sendMessage({\n          streamClose: {\n            id\n          }\n        }).catch((err) => {\n          log.catch(err, void 0, {\n            F: __dxlog_file,\n            L: 475,\n            S: this,\n            C: (f, a) => f(...a)\n          });\n        });\n      };\n    });\n  }\n  async _sendMessage(message, timeout) {\n    DEBUG_CALLS && log(\"sending message\", {\n      type: Object.keys(message)[0]\n    }, {\n      F: __dxlog_file,\n      L: 482,\n      S: this,\n      C: (f, a) => f(...a)\n    });\n    await this._params.port.send(RpcMessage.encode(message, {\n      preserveAny: true\n    }), timeout);\n  }\n  async _callHandler(req) {\n    try {\n      invariant(typeof req.id === \"number\", void 0, {\n        F: __dxlog_file,\n        L: 488,\n        S: this,\n        A: [\n          \"typeof req.id === 'number'\",\n          \"\"\n        ]\n      });\n      invariant(req.payload, void 0, {\n        F: __dxlog_file,\n        L: 489,\n        S: this,\n        A: [\n          \"req.payload\",\n          \"\"\n        ]\n      });\n      invariant(req.method, void 0, {\n        F: __dxlog_file,\n        L: 490,\n        S: this,\n        A: [\n          \"req.method\",\n          \"\"\n        ]\n      });\n      const response = await this._params.callHandler(req.method, req.payload, this._params.handlerRpcOptions);\n      return {\n        id: req.id,\n        payload: response\n      };\n    } catch (err) {\n      return {\n        id: req.id,\n        error: encodeError(err)\n      };\n    }\n  }\n  _callStreamHandler(req, callback) {\n    try {\n      invariant(this._params.streamHandler, \"Requests with streaming responses are not supported.\", {\n        F: __dxlog_file,\n        L: 507,\n        S: this,\n        A: [\n          \"this._params.streamHandler\",\n          \"'Requests with streaming responses are not supported.'\"\n        ]\n      });\n      invariant(typeof req.id === \"number\", void 0, {\n        F: __dxlog_file,\n        L: 508,\n        S: this,\n        A: [\n          \"typeof req.id === 'number'\",\n          \"\"\n        ]\n      });\n      invariant(req.payload, void 0, {\n        F: __dxlog_file,\n        L: 509,\n        S: this,\n        A: [\n          \"req.payload\",\n          \"\"\n        ]\n      });\n      invariant(req.method, void 0, {\n        F: __dxlog_file,\n        L: 510,\n        S: this,\n        A: [\n          \"req.method\",\n          \"\"\n        ]\n      });\n      const responseStream = this._params.streamHandler(req.method, req.payload, this._params.handlerRpcOptions);\n      responseStream.onReady(() => {\n        callback({\n          id: req.id,\n          streamReady: true\n        });\n      });\n      responseStream.subscribe((msg) => {\n        callback({\n          id: req.id,\n          payload: msg\n        });\n      }, (error) => {\n        if (error) {\n          callback({\n            id: req.id,\n            error: encodeError(error)\n          });\n        } else {\n          callback({\n            id: req.id,\n            close: true\n          });\n        }\n      });\n      this._localStreams.set(req.id, responseStream);\n    } catch (err) {\n      callback({\n        id: req.id,\n        error: encodeError(err)\n      });\n    }\n  }\n};\n_ts_decorate([\n  synchronized\n], RpcPeer.prototype, \"open\", null);\nvar throwIfNotOpen = (state) => {\n  switch (state) {\n    case \"OPENED\": {\n      return;\n    }\n    case \"INITIAL\": {\n      throw new RpcNotOpenError();\n    }\n    case \"CLOSED\": {\n      throw new RpcClosedError();\n    }\n  }\n};\n\n// packages/core/mesh/rpc/src/service.ts\nimport { invariant as invariant2 } from \"@dxos/invariant\";\nvar __dxlog_file2 = \"/home/runner/work/dxos/dxos/packages/core/mesh/rpc/src/service.ts\";\nvar createServiceBundle = (services) => services;\nvar ProtoRpcPeer = class {\n  constructor(rpc, _peer) {\n    this.rpc = rpc;\n    this._peer = _peer;\n  }\n  async open() {\n    await this._peer.open();\n  }\n  async close() {\n    await this._peer.close();\n  }\n  async abort() {\n    await this._peer.abort();\n  }\n};\nvar createProtoRpcPeer = ({ requested, exposed, handlers, encodingOptions, ...rest }) => {\n  const exposedRpcs = {};\n  if (exposed) {\n    invariant2(handlers, void 0, {\n      F: __dxlog_file2,\n      L: 93,\n      S: void 0,\n      A: [\n        \"handlers\",\n        \"\"\n      ]\n    });\n    for (const serviceName of Object.keys(exposed)) {\n      const serviceFqn = exposed[serviceName].serviceProto.fullName.slice(1);\n      const serviceProvider = handlers[serviceName];\n      exposedRpcs[serviceFqn] = exposed[serviceName].createServer(serviceProvider, encodingOptions);\n    }\n  }\n  const peer = new RpcPeer({\n    ...rest,\n    callHandler: (method, request, options) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return exposedRpcs[serviceName].call(methodName, request, options);\n    },\n    streamHandler: (method, request, options) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return exposedRpcs[serviceName].callStream(methodName, request, options);\n    }\n  });\n  const requestedRpcs = {};\n  if (requested) {\n    for (const serviceName of Object.keys(requested)) {\n      const serviceFqn = requested[serviceName].serviceProto.fullName.slice(1);\n      requestedRpcs[serviceName] = requested[serviceName].createClient({\n        call: (method, req, options) => peer.call(`${serviceFqn}.${method}`, req, options),\n        callStream: (method, req, options) => peer.callStream(`${serviceFqn}.${method}`, req, options)\n      }, encodingOptions);\n    }\n  }\n  return new ProtoRpcPeer(requestedRpcs, peer);\n};\nvar parseMethodName = (method) => {\n  const separator = method.lastIndexOf(\".\");\n  const serviceName = method.slice(0, separator);\n  const methodName = method.slice(separator + 1);\n  if (serviceName.length === 0 || methodName.length === 0) {\n    throw new Error(`Invalid method: ${method}`);\n  }\n  return [\n    serviceName,\n    methodName\n  ];\n};\nvar createRpcClient = (serviceDef, options) => {\n  const peer = new RpcPeer({\n    ...options,\n    callHandler: () => {\n      throw new Error(\"Requests to client are not supported.\");\n    }\n  });\n  const client = serviceDef.createClient({\n    call: peer.call.bind(peer),\n    callStream: peer.callStream.bind(peer)\n  });\n  return new ProtoRpcPeer(client, peer);\n};\nvar createRpcServer = ({ service, handlers, ...rest }) => {\n  const server = service.createServer(handlers);\n  return new RpcPeer({\n    ...rest,\n    callHandler: server.call.bind(server),\n    streamHandler: server.callStream.bind(server)\n  });\n};\nvar createBundledRpcClient = (descriptors, options) => {\n  return createProtoRpcPeer({\n    requested: descriptors,\n    ...options\n  });\n};\nvar createBundledRpcServer = ({ services, handlers, ...rest }) => {\n  const rpc = {};\n  for (const serviceName of Object.keys(services)) {\n    const serviceFqn = services[serviceName].serviceProto.fullName.slice(1);\n    rpc[serviceFqn] = services[serviceName].createServer(handlers[serviceName]);\n  }\n  return new RpcPeer({\n    ...rest,\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return rpc[serviceName].call(methodName, request);\n    },\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return rpc[serviceName].callStream(methodName, request);\n    }\n  });\n};\n\n// packages/core/mesh/rpc/src/testing.ts\nvar createLinkedPorts = ({ delay } = {}) => {\n  let port1Received;\n  let port2Received;\n  const send = (handler, msg) => {\n    if (delay) {\n      setTimeout(() => handler?.(msg), delay);\n    } else {\n      void handler?.(msg);\n    }\n  };\n  const port1 = {\n    send: (msg) => send(port2Received, msg),\n    subscribe: (cb) => {\n      port1Received = cb;\n    }\n  };\n  const port2 = {\n    send: (msg) => send(port1Received, msg),\n    subscribe: (cb) => {\n      port2Received = cb;\n    }\n  };\n  return [\n    port1,\n    port2\n  ];\n};\n\n// packages/core/mesh/rpc/src/trace.ts\nimport { Event } from \"@dxos/async\";\nimport { MessageTrace } from \"@dxos/protocols/proto/dxos/rpc\";\nvar PortTracer = class {\n  constructor(_wrappedPort) {\n    this._wrappedPort = _wrappedPort;\n    this.message = new Event();\n    this._port = {\n      send: (msg) => {\n        this.message.emit({\n          direction: MessageTrace.Direction.OUTGOING,\n          data: msg\n        });\n        return this._wrappedPort.send(msg);\n      },\n      subscribe: (cb) => {\n        return this._wrappedPort.subscribe((msg) => {\n          this.message.emit({\n            direction: MessageTrace.Direction.INCOMING,\n            data: msg\n          });\n          cb(msg);\n        });\n      }\n    };\n  }\n  get port() {\n    return this._port;\n  }\n};\nexport {\n  PortTracer,\n  ProtoRpcPeer,\n  RpcPeer,\n  createBundledRpcClient,\n  createBundledRpcServer,\n  createLinkedPorts,\n  createProtoRpcPeer,\n  createRpcClient,\n  createRpcServer,\n  createServiceBundle,\n  decodeRpcError,\n  parseMethodName\n};\n//# sourceMappingURL=index.mjs.map\n","import * as Arr from \"../Array.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Either from \"../Either.js\";\nimport * as Equal from \"../Equal.js\";\nimport { constFalse, constTrue, dual, identity, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport { NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty, isFunction } from \"../Predicate.js\";\nimport { getBugErrorMessage } from \"./errors.js\";\nimport * as OpCodes from \"./opCodes/cause.js\";\n// -----------------------------------------------------------------------------\n// Models\n// -----------------------------------------------------------------------------\n/** @internal */\nconst CauseSymbolKey = \"effect/Cause\";\n/** @internal */\nexport const CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);\nconst variance = {\n  /* c8 ignore next */\n  _E: _ => _\n};\n/** @internal */\nconst proto = {\n  [CauseTypeId]: variance,\n  [Hash.symbol]() {\n    return pipe(Hash.hash(CauseSymbolKey), Hash.combine(Hash.hash(flattenCause(this))), Hash.cached(this));\n  },\n  [Equal.symbol](that) {\n    return isCause(that) && causeEquals(this, that);\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  toJSON() {\n    switch (this._tag) {\n      case \"Empty\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag\n        };\n      case \"Die\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          defect: toJSON(this.defect)\n        };\n      case \"Interrupt\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          fiberId: this.fiberId.toJSON()\n        };\n      case \"Fail\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          failure: toJSON(this.error)\n        };\n      case \"Sequential\":\n      case \"Parallel\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          left: toJSON(this.left),\n          right: toJSON(this.right)\n        };\n    }\n  },\n  toString() {\n    return pretty(this);\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n// -----------------------------------------------------------------------------\n// Constructors\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const empty = /*#__PURE__*/(() => {\n  const o = /*#__PURE__*/Object.create(proto);\n  o._tag = OpCodes.OP_EMPTY;\n  return o;\n})();\n/** @internal */\nexport const fail = error => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_FAIL;\n  o.error = error;\n  return o;\n};\n/** @internal */\nexport const die = defect => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_DIE;\n  o.defect = defect;\n  return o;\n};\n/** @internal */\nexport const interrupt = fiberId => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_INTERRUPT;\n  o.fiberId = fiberId;\n  return o;\n};\n/** @internal */\nexport const parallel = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_PARALLEL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n/** @internal */\nexport const sequential = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_SEQUENTIAL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n// -----------------------------------------------------------------------------\n// Refinements\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const isCause = u => hasProperty(u, CauseTypeId);\n/** @internal */\nexport const isEmptyType = self => self._tag === OpCodes.OP_EMPTY;\n/** @internal */\nexport const isFailType = self => self._tag === OpCodes.OP_FAIL;\n/** @internal */\nexport const isDieType = self => self._tag === OpCodes.OP_DIE;\n/** @internal */\nexport const isInterruptType = self => self._tag === OpCodes.OP_INTERRUPT;\n/** @internal */\nexport const isSequentialType = self => self._tag === OpCodes.OP_SEQUENTIAL;\n/** @internal */\nexport const isParallelType = self => self._tag === OpCodes.OP_PARALLEL;\n// -----------------------------------------------------------------------------\n// Getters\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const size = self => reduceWithContext(self, void 0, SizeCauseReducer);\n/** @internal */\nexport const isEmpty = self => {\n  if (self._tag === OpCodes.OP_EMPTY) {\n    return true;\n  }\n  return reduce(self, true, (acc, cause) => {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          return Option.some(acc);\n        }\n      case OpCodes.OP_DIE:\n      case OpCodes.OP_FAIL:\n      case OpCodes.OP_INTERRUPT:\n        {\n          return Option.some(false);\n        }\n      default:\n        {\n          return Option.none();\n        }\n    }\n  });\n};\n/** @internal */\nexport const isFailure = self => Option.isSome(failureOption(self));\n/** @internal */\nexport const isDie = self => Option.isSome(dieOption(self));\n/** @internal */\nexport const isInterrupted = self => Option.isSome(interruptOption(self));\n/** @internal */\nexport const isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);\n/** @internal */\nexport const failures = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_FAIL ? Option.some(pipe(list, Chunk.prepend(cause.error))) : Option.none()));\n/** @internal */\nexport const defects = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_DIE ? Option.some(pipe(list, Chunk.prepend(cause.defect))) : Option.none()));\n/** @internal */\nexport const interruptors = self => reduce(self, HashSet.empty(), (set, cause) => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(pipe(set, HashSet.add(cause.fiberId))) : Option.none());\n/** @internal */\nexport const failureOption = self => find(self, cause => cause._tag === OpCodes.OP_FAIL ? Option.some(cause.error) : Option.none());\n/** @internal */\nexport const failureOrCause = self => {\n  const option = failureOption(self);\n  switch (option._tag) {\n    case \"None\":\n      {\n        // no `E` inside this `Cause`, so it can be safely cast to `never`\n        return Either.right(self);\n      }\n    case \"Some\":\n      {\n        return Either.left(option.value);\n      }\n  }\n};\n/** @internal */\nexport const dieOption = self => find(self, cause => cause._tag === OpCodes.OP_DIE ? Option.some(cause.defect) : Option.none());\n/** @internal */\nexport const flipCauseOption = self => match(self, {\n  onEmpty: Option.some(empty),\n  onFail: failureOption => pipe(failureOption, Option.map(fail)),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: fiberId => Option.some(interrupt(fiberId)),\n  onSequential: (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(sequential(left.value, right.value));\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    return Option.none();\n  },\n  onParallel: (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(parallel(left.value, right.value));\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    return Option.none();\n  }\n});\n/** @internal */\nexport const interruptOption = self => find(self, cause => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(cause.fiberId) : Option.none());\n/** @internal */\nexport const keepDefects = self => match(self, {\n  onEmpty: Option.none(),\n  onFail: () => Option.none(),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: () => Option.none(),\n  onSequential: (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(sequential(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  },\n  onParallel: (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(parallel(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  }\n});\n/** @internal */\nexport const keepDefectsAndElectFailures = self => match(self, {\n  onEmpty: Option.none(),\n  onFail: failure => Option.some(die(failure)),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: () => Option.none(),\n  onSequential: (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(sequential(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  },\n  onParallel: (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(parallel(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  }\n});\n/** @internal */\nexport const linearize = self => match(self, {\n  onEmpty: HashSet.empty(),\n  onFail: error => HashSet.make(fail(error)),\n  onDie: defect => HashSet.make(die(defect)),\n  onInterrupt: fiberId => HashSet.make(interrupt(fiberId)),\n  onSequential: (leftSet, rightSet) => pipe(leftSet, HashSet.flatMap(leftCause => pipe(rightSet, HashSet.map(rightCause => sequential(leftCause, rightCause))))),\n  onParallel: (leftSet, rightSet) => pipe(leftSet, HashSet.flatMap(leftCause => pipe(rightSet, HashSet.map(rightCause => parallel(leftCause, rightCause)))))\n});\n/** @internal */\nexport const stripFailures = self => match(self, {\n  onEmpty: empty,\n  onFail: () => empty,\n  onDie: defect => die(defect),\n  onInterrupt: fiberId => interrupt(fiberId),\n  onSequential: sequential,\n  onParallel: parallel\n});\n/** @internal */\nexport const electFailures = self => match(self, {\n  onEmpty: empty,\n  onFail: failure => die(failure),\n  onDie: defect => die(defect),\n  onInterrupt: fiberId => interrupt(fiberId),\n  onSequential: (left, right) => sequential(left, right),\n  onParallel: (left, right) => parallel(left, right)\n});\n/** @internal */\nexport const stripSomeDefects = /*#__PURE__*/dual(2, (self, pf) => match(self, {\n  onEmpty: Option.some(empty),\n  onFail: error => Option.some(fail(error)),\n  onDie: defect => {\n    const option = pf(defect);\n    return Option.isSome(option) ? Option.none() : Option.some(die(defect));\n  },\n  onInterrupt: fiberId => Option.some(interrupt(fiberId)),\n  onSequential: (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(sequential(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  },\n  onParallel: (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(parallel(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  }\n}));\n// -----------------------------------------------------------------------------\n// Mapping\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const as = /*#__PURE__*/dual(2, (self, error) => map(self, () => error));\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, e => fail(f(e))));\n// -----------------------------------------------------------------------------\n// Sequencing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => match(self, {\n  onEmpty: empty,\n  onFail: error => f(error),\n  onDie: defect => die(defect),\n  onInterrupt: fiberId => interrupt(fiberId),\n  onSequential: (left, right) => sequential(left, right),\n  onParallel: (left, right) => parallel(left, right)\n}));\n/** @internal */\nexport const flatten = self => flatMap(self, identity);\n/** @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, f) => isFunction(f) ? flatMap(self, f) : flatMap(self, () => f));\n// -----------------------------------------------------------------------------\n// Equality\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const contains = /*#__PURE__*/dual(2, (self, that) => {\n  if (that._tag === OpCodes.OP_EMPTY || self === that) {\n    return true;\n  }\n  return reduce(self, false, (accumulator, cause) => {\n    return Option.some(accumulator || causeEquals(cause, that));\n  });\n});\n/** @internal */\nconst causeEquals = (left, right) => {\n  let leftStack = Chunk.of(left);\n  let rightStack = Chunk.of(right);\n  while (Chunk.isNonEmpty(leftStack) && Chunk.isNonEmpty(rightStack)) {\n    const [leftParallel, leftSequential] = pipe(Chunk.headNonEmpty(leftStack), reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))]);\n    }));\n    const [rightParallel, rightSequential] = pipe(Chunk.headNonEmpty(rightStack), reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))]);\n    }));\n    if (!Equal.equals(leftParallel, rightParallel)) {\n      return false;\n    }\n    leftStack = leftSequential;\n    rightStack = rightSequential;\n  }\n  return true;\n};\n// -----------------------------------------------------------------------------\n// Flattening\n// -----------------------------------------------------------------------------\n/**\n * Flattens a cause to a sequence of sets of causes, where each set represents\n * causes that fail in parallel and sequential sets represent causes that fail\n * after each other.\n *\n * @internal\n */\nconst flattenCause = cause => {\n  return flattenCauseLoop(Chunk.of(cause), Chunk.empty());\n};\n/** @internal */\nconst flattenCauseLoop = (causes, flattened) => {\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = pipe(causes, Arr.reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return [pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))];\n    }));\n    const updated = HashSet.size(parallel) > 0 ? pipe(flattened, Chunk.prepend(parallel)) : flattened;\n    if (Chunk.isEmpty(sequential)) {\n      return Chunk.reverse(updated);\n    }\n    causes = sequential;\n    flattened = updated;\n  }\n  throw new Error(getBugErrorMessage(\"Cause.flattenCauseLoop\"));\n};\n// -----------------------------------------------------------------------------\n// Finding\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const find = /*#__PURE__*/dual(2, (self, pf) => {\n  const stack = [self];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    const option = pf(item);\n    switch (option._tag) {\n      case \"None\":\n        {\n          switch (item._tag) {\n            case OpCodes.OP_SEQUENTIAL:\n            case OpCodes.OP_PARALLEL:\n              {\n                stack.push(item.right);\n                stack.push(item.left);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Some\":\n        {\n          return option;\n        }\n    }\n  }\n  return Option.none();\n});\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));\n// -----------------------------------------------------------------------------\n// Evaluation\n// -----------------------------------------------------------------------------\n/**\n * Takes one step in evaluating a cause, returning a set of causes that fail\n * in parallel and a list of causes that fail sequentially after those causes.\n *\n * @internal\n */\nconst evaluateCause = self => {\n  let cause = self;\n  const stack = [];\n  let _parallel = HashSet.empty();\n  let _sequential = Chunk.empty();\n  while (cause !== undefined) {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.error));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.defect));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.fiberId));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          switch (cause.left._tag) {\n            case OpCodes.OP_EMPTY:\n              {\n                cause = cause.right;\n                break;\n              }\n            case OpCodes.OP_SEQUENTIAL:\n              {\n                cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));\n                break;\n              }\n            case OpCodes.OP_PARALLEL:\n              {\n                cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));\n                break;\n              }\n            default:\n              {\n                _sequential = Chunk.prepend(_sequential, cause.right);\n                cause = cause.left;\n                break;\n              }\n          }\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          stack.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n    }\n  }\n  throw new Error(getBugErrorMessage(\"Cause.evaluateCauseLoop\"));\n};\n// -----------------------------------------------------------------------------\n// Reducing\n// -----------------------------------------------------------------------------\n/** @internal */\nconst SizeCauseReducer = {\n  emptyCase: () => 0,\n  failCase: () => 1,\n  dieCase: () => 1,\n  interruptCase: () => 1,\n  sequentialCase: (_, left, right) => left + right,\n  parallelCase: (_, left, right) => left + right\n};\n/** @internal */\nconst IsInterruptedOnlyCauseReducer = {\n  emptyCase: constTrue,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: constTrue,\n  sequentialCase: (_, left, right) => left && right,\n  parallelCase: (_, left, right) => left && right\n};\n/** @internal */\nconst FilterCauseReducer = predicate => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  sequentialCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return sequential(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  },\n  parallelCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return parallel(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  }\n});\nconst OP_SEQUENTIAL_CASE = \"SequentialCase\";\nconst OP_PARALLEL_CASE = \"ParallelCase\";\n/** @internal */\nexport const match = /*#__PURE__*/dual(2, (self, {\n  onDie,\n  onEmpty,\n  onFail,\n  onInterrupt,\n  onParallel,\n  onSequential\n}) => {\n  return reduceWithContext(self, void 0, {\n    emptyCase: () => onEmpty,\n    failCase: (_, error) => onFail(error),\n    dieCase: (_, defect) => onDie(defect),\n    interruptCase: (_, fiberId) => onInterrupt(fiberId),\n    sequentialCase: (_, left, right) => onSequential(left, right),\n    parallelCase: (_, left, right) => onParallel(left, right)\n  });\n});\n/** @internal */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, pf) => {\n  let accumulator = zero;\n  let cause = self;\n  const causes = [];\n  while (cause !== undefined) {\n    const option = pf(accumulator, cause);\n    accumulator = Option.isSome(option) ? option.value : accumulator;\n    switch (cause._tag) {\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      default:\n        {\n          cause = undefined;\n          break;\n        }\n    }\n    if (cause === undefined && causes.length > 0) {\n      cause = causes.pop();\n    }\n  }\n  return accumulator;\n});\n/** @internal */\nexport const reduceWithContext = /*#__PURE__*/dual(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const cause = input.pop();\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          output.push(Either.right(reducer.emptyCase(context)));\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          output.push(Either.right(reducer.failCase(context, cause.error)));\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          output.push(Either.right(reducer.dieCase(context, cause.defect)));\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          output.push(Either.right(reducer.interruptCase(context, cause.fiberId)));\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_SEQUENTIAL_CASE\n          }));\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_PARALLEL_CASE\n          }));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case OP_SEQUENTIAL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.sequentialCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case OP_PARALLEL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.parallelCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues\");\n  }\n  return accumulator.pop();\n});\n// -----------------------------------------------------------------------------\n// Pretty Printing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const pretty = cause => {\n  if (isInterruptedOnly(cause)) {\n    return \"All fibers interrupted without errors.\";\n  }\n  return prettyErrors(cause).map(e => e.stack).join(\"\\n\");\n};\nclass PrettyError extends globalThis.Error {\n  span = undefined;\n  constructor(originalError) {\n    const prevLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    super(prettyErrorMessage(originalError));\n    if (this.message === \"\") {\n      this.message = \"An error has occurred\";\n    }\n    Error.stackTraceLimit = prevLimit;\n    this.name = originalError instanceof Error ? originalError.name : \"Error\";\n    if (typeof originalError === \"object\" && originalError !== null) {\n      if (spanSymbol in originalError) {\n        this.span = originalError[spanSymbol];\n      }\n      Object.keys(originalError).forEach(key => {\n        if (!(key in this)) {\n          // @ts-expect-error\n          this[key] = originalError[key];\n        }\n      });\n    }\n    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : \"\", this.span);\n  }\n}\n/**\n * A utility function for generating human-readable error messages from a generic error of type `unknown`.\n *\n * Rules:\n *\n * 1) If the input `u` is already a string, it's considered a message.\n * 2) If `u` is an Error instance with a message defined, it uses the message.\n * 3) If `u` has a user-defined `toString()` method, it uses that method.\n * 4) Otherwise, it uses `JSON.stringify` to produce a string representation and uses it as the error message,\n *   with \"Error\" added as a prefix.\n *\n * @internal\n */\nexport const prettyErrorMessage = u => {\n  // 1)\n  if (typeof u === \"string\") {\n    return u;\n  }\n  // 2)\n  if (typeof u === \"object\" && u !== null && u instanceof Error) {\n    return u.message;\n  }\n  // 3)\n  try {\n    if (hasProperty(u, \"toString\") && isFunction(u[\"toString\"]) && u[\"toString\"] !== Object.prototype.toString && u[\"toString\"] !== globalThis.Array.prototype.toString) {\n      return u[\"toString\"]();\n    }\n  } catch {\n    // something's off, rollback to json\n  }\n  // 4)\n  return JSON.stringify(u);\n};\nconst locationRegex = /\\((.*)\\)/;\n/** @internal */\nexport const spanToTrace = /*#__PURE__*/globalValue(\"effect/Tracer/spanToTrace\", () => new WeakMap());\nconst prettyErrorStack = (message, stack, span) => {\n  const out = [message];\n  const lines = stack.startsWith(message) ? stack.slice(message.length).split(\"\\n\") : stack.split(\"\\n\");\n  for (let i = 1; i < lines.length; i++) {\n    if (lines[i].includes(\"Generator.next\")) {\n      break;\n    }\n    if (lines[i].includes(\"effect_internal_function\")) {\n      out.pop();\n      break;\n    }\n    out.push(lines[i].replace(/at .*effect_instruction_i.*\\((.*)\\)/, \"at $1\").replace(/EffectPrimitive\\.\\w+/, \"<anonymous>\"));\n  }\n  if (span) {\n    let current = span;\n    let i = 0;\n    while (current && current._tag === \"Span\" && i < 10) {\n      const stackFn = spanToTrace.get(current);\n      if (typeof stackFn === \"function\") {\n        const stack = stackFn();\n        const locationMatch = stack.match(locationRegex);\n        const location = locationMatch ? locationMatch[1] : stack.replace(/^at /, \"\");\n        out.push(`    at ${current.name} (${location})`);\n      } else {\n        out.push(`    at ${current.name}`);\n      }\n      current = Option.getOrUndefined(current.parent);\n      i++;\n    }\n  }\n  return out.join(\"\\n\");\n};\nconst spanSymbol = /*#__PURE__*/Symbol.for(\"effect/SpanAnnotation\");\n/** @internal */\nexport const prettyErrors = cause => reduceWithContext(cause, void 0, {\n  emptyCase: () => [],\n  dieCase: (_, unknownError) => {\n    return [new PrettyError(unknownError)];\n  },\n  failCase: (_, error) => {\n    return [new PrettyError(error)];\n  },\n  interruptCase: () => [],\n  parallelCase: (_, l, r) => [...l, ...r],\n  sequentialCase: (_, l, r) => [...l, ...r]\n});\n//# sourceMappingURL=cause.js.map","import * as Equal from \"../Equal.js\";\nimport { dual } from \"../Function.js\";\nimport * as Hash from \"../Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport { EffectPrototype, effectVariance } from \"./effectable.js\";\nimport * as option from \"./option.js\";\n/** @internal */\nexport const TagTypeId = /*#__PURE__*/Symbol.for(\"effect/Context/Tag\");\n/** @internal */\nconst STMSymbolKey = \"effect/STM\";\n/** @internal */\nexport const STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);\n/** @internal */\nexport const TagProto = {\n  ...EffectPrototype,\n  _tag: \"Tag\",\n  _op: \"Tag\",\n  [STMTypeId]: effectVariance,\n  [TagTypeId]: {\n    _Service: _ => _,\n    _Identifier: _ => _\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Tag\",\n      key: this.key,\n      stack: this.stack\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  of(self) {\n    return self;\n  },\n  context(self) {\n    return make(this, self);\n  }\n};\n/** @internal */\nexport const makeGenericTag = key => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  const tag = Object.create(TagProto);\n  Object.defineProperty(tag, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  tag.key = key;\n  return tag;\n};\n/** @internal */\nexport const Tag = id => () => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  function TagClass() {}\n  Object.setPrototypeOf(TagClass, TagProto);\n  TagClass.key = id;\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  return TagClass;\n};\n/** @internal */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/Context\");\n/** @internal */\nexport const ContextProto = {\n  [TypeId]: {\n    _Services: _ => _\n  },\n  [Equal.symbol](that) {\n    if (isContext(that)) {\n      if (this.unsafeMap.size === that.unsafeMap.size) {\n        for (const k of this.unsafeMap.keys()) {\n          if (!that.unsafeMap.has(k) || !Equal.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.number(this.unsafeMap.size));\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Context\",\n      services: Array.from(this.unsafeMap).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n/** @internal */\nexport const makeContext = unsafeMap => {\n  const context = Object.create(ContextProto);\n  context.unsafeMap = unsafeMap;\n  return context;\n};\nconst serviceNotFoundError = tag => {\n  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : \"\"}`);\n  if (tag.stack) {\n    const lines = tag.stack.split(\"\\n\");\n    if (lines.length > 2) {\n      const afterAt = lines[2].match(/at (.*)/);\n      if (afterAt) {\n        error.message = error.message + ` (defined at ${afterAt[1]})`;\n      }\n    }\n  }\n  if (error.stack) {\n    const lines = error.stack.split(\"\\n\");\n    lines.splice(1, 3);\n    error.stack = lines.join(\"\\n\");\n  }\n  return error;\n};\n/** @internal */\nexport const isContext = u => hasProperty(u, TypeId);\n/** @internal */\nexport const isTag = u => hasProperty(u, TagTypeId);\nconst _empty = /*#__PURE__*/makeContext( /*#__PURE__*/new Map());\n/** @internal */\nexport const empty = () => _empty;\n/** @internal */\nexport const make = (tag, service) => makeContext(new Map([[tag.key, service]]));\n/** @internal */\nexport const add = /*#__PURE__*/dual(3, (self, tag, service) => {\n  const map = new Map(self.unsafeMap);\n  map.set(tag.key, service);\n  return makeContext(map);\n});\n/** @internal */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    throw serviceNotFoundError(tag);\n  }\n  return self.unsafeMap.get(tag.key);\n});\n/** @internal */\nexport const get = unsafeGet;\n/** @internal */\nexport const getOption = /*#__PURE__*/dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return option.none;\n  }\n  return option.some(self.unsafeMap.get(tag.key));\n});\n/** @internal */\nexport const merge = /*#__PURE__*/dual(2, (self, that) => {\n  const map = new Map(self.unsafeMap);\n  for (const [tag, s] of that.unsafeMap) {\n    map.set(tag, s);\n  }\n  return makeContext(map);\n});\n/** @internal */\nexport const pick = (...tags) => self => {\n  const tagSet = new Set(tags.map(_ => _.key));\n  const newEnv = new Map();\n  for (const [tag, s] of self.unsafeMap.entries()) {\n    if (tagSet.has(tag)) {\n      newEnv.set(tag, s);\n    }\n  }\n  return makeContext(newEnv);\n};\n/** @internal */\nexport const omit = (...tags) => self => {\n  const newEnv = new Map(self.unsafeMap);\n  for (const tag of tags) {\n    newEnv.delete(tag.key);\n  }\n  return makeContext(newEnv);\n};\n//# sourceMappingURL=context.js.map","import * as internal from \"./internal/context.js\";\nconst TagTypeId = internal.TagTypeId;\n/**\n * Creates a new `Tag` instance with an optional key parameter.\n *\n * @param key - A key that will be used to compare tags.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.GenericTag(\"PORT\").key === Context.GenericTag(\"PORT\").key, true)\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const GenericTag = internal.makeGenericTag;\nconst TypeId = internal.TypeId;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const unsafeMake = internal.makeContext;\n/**\n * Checks if the provided argument is a `Context`.\n *\n * @param input - The value to be checked if it is a `Context`.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isContext = internal.isContext;\n/**\n * Checks if the provided argument is a `Tag`.\n *\n * @param input - The value to be checked if it is a `Tag`.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isTag(Context.GenericTag(\"Tag\")), true)\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isTag = internal.isTag;\n/**\n * Returns an empty `Context`.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = internal.empty;\n/**\n * Creates a new `Context` with a single service associated to the tag.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Adds a service to a given `Context`.\n *\n * @example\n * import { Context, pipe } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = Context.make(Port, { PORT: 8080 })\n *\n * const Services = pipe(\n *   someContext,\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n */\nexport const add = internal.add;\n/**\n * Get a service from the context that corresponds to the given tag.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import { pipe, Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n * @category getters\n */\nexport const get = internal.get;\n/**\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n * assert.throws(() => Context.unsafeGet(Services, Timeout))\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet = internal.unsafeGet;\n/**\n * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n * found, the `Option` object will be `None`.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import { Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n *\n * @since 2.0.0\n * @category getters\n */\nexport const getOption = internal.getOption;\n/**\n * Merges two `Context`s, returning a new `Context` containing the services of both.\n *\n * @param self - The first `Context` to merge.\n * @param that - The second `Context` to merge.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n *\n * const Services = Context.merge(firstContext, secondContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n */\nexport const merge = internal.merge;\n/**\n * Returns a new `Context` that contains only the specified services.\n *\n * @param self - The `Context` to prune services from.\n * @param tags - The list of `Tag`s to be included in the new `Context`.\n *\n * @example\n * import { pipe, Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * const Services = pipe(someContext, Context.pick(Port))\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n *\n * @since 2.0.0\n */\nexport const pick = internal.pick;\n/**\n * @since 2.0.0\n */\nexport const omit = internal.omit;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Tag = internal.Tag;\n//# sourceMappingURL=Context.js.map","/**\n * @since 2.0.0\n */\nimport * as Equal from \"./Equal.js\";\nimport * as Dual from \"./Function.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/MutableRef\");\nconst MutableRefProto = {\n  [TypeId]: TypeId,\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"MutableRef\",\n      current: toJSON(this.current)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = value => {\n  const ref = Object.create(MutableRefProto);\n  ref.current = value;\n  return ref;\n};\n/**\n * @since 2.0.0\n * @category general\n */\nexport const compareAndSet = /*#__PURE__*/Dual.dual(3, (self, oldValue, newValue) => {\n  if (Equal.equals(oldValue, self.current)) {\n    self.current = newValue;\n    return true;\n  }\n  return false;\n});\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const decrement = self => update(self, n => n - 1);\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const decrementAndGet = self => updateAndGet(self, n => n - 1);\n/**\n * @since 2.0.0\n * @category general\n */\nexport const get = self => self.current;\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const getAndDecrement = self => getAndUpdate(self, n => n - 1);\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const getAndIncrement = self => getAndUpdate(self, n => n + 1);\n/**\n * @since 2.0.0\n * @category general\n */\nexport const getAndSet = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  const ret = self.current;\n  self.current = value;\n  return ret;\n});\n/**\n * @since 2.0.0\n * @category general\n */\nexport const getAndUpdate = /*#__PURE__*/Dual.dual(2, (self, f) => getAndSet(self, f(get(self))));\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const increment = self => update(self, n => n + 1);\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const incrementAndGet = self => updateAndGet(self, n => n + 1);\n/**\n * @since 2.0.0\n * @category general\n */\nexport const set = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  self.current = value;\n  return self;\n});\n/**\n * @since 2.0.0\n * @category general\n */\nexport const setAndGet = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  self.current = value;\n  return self.current;\n});\n/**\n * @since 2.0.0\n * @category general\n */\nexport const update = /*#__PURE__*/Dual.dual(2, (self, f) => set(self, f(get(self))));\n/**\n * @since 2.0.0\n * @category general\n */\nexport const updateAndGet = /*#__PURE__*/Dual.dual(2, (self, f) => setAndGet(self, f(get(self))));\n/**\n * @since 2.0.0\n * @category boolean\n */\nexport const toggle = self => update(self, _ => !_);\n//# sourceMappingURL=MutableRef.js.map","import * as Equal from \"../Equal.js\";\nimport { dual, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport * as MutableRef from \"../MutableRef.js\";\nimport * as Option from \"../Option.js\";\nimport { hasProperty } from \"../Predicate.js\";\n/** @internal */\nconst FiberIdSymbolKey = \"effect/FiberId\";\n/** @internal */\nexport const FiberIdTypeId = /*#__PURE__*/Symbol.for(FiberIdSymbolKey);\n/** @internal */\nconst OP_NONE = \"None\";\n/** @internal */\nconst OP_RUNTIME = \"Runtime\";\n/** @internal */\nconst OP_COMPOSITE = \"Composite\";\nconst emptyHash = /*#__PURE__*/Hash.string(`${FiberIdSymbolKey}-${OP_NONE}`);\n/** @internal */\nclass None {\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_NONE;\n  id = -1;\n  startTimeMillis = -1;\n  [Hash.symbol]() {\n    return emptyHash;\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_NONE;\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nclass Runtime {\n  id;\n  startTimeMillis;\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_RUNTIME;\n  constructor(id, startTimeMillis) {\n    this.id = id;\n    this.startTimeMillis = startTimeMillis;\n  }\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag,\n      id: this.id,\n      startTimeMillis: this.startTimeMillis\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nclass Composite {\n  left;\n  right;\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_COMPOSITE;\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n  _hash;\n  [Hash.symbol]() {\n    return pipe(Hash.string(`${FiberIdSymbolKey}-${this._tag}`), Hash.combine(Hash.hash(this.left)), Hash.combine(Hash.hash(this.right)), Hash.cached(this));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_COMPOSITE && Equal.equals(this.left, that.left) && Equal.equals(this.right, that.right);\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag,\n      left: toJSON(this.left),\n      right: toJSON(this.right)\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nexport const none = /*#__PURE__*/new None();\n/** @internal */\nexport const runtime = (id, startTimeMillis) => {\n  return new Runtime(id, startTimeMillis);\n};\n/** @internal */\nexport const composite = (left, right) => {\n  return new Composite(left, right);\n};\n/** @internal */\nexport const isFiberId = self => hasProperty(self, FiberIdTypeId);\n/** @internal */\nexport const isNone = self => {\n  return self._tag === OP_NONE || pipe(toSet(self), HashSet.every(id => isNone(id)));\n};\n/** @internal */\nexport const isRuntime = self => {\n  return self._tag === OP_RUNTIME;\n};\n/** @internal */\nexport const isComposite = self => {\n  return self._tag === OP_COMPOSITE;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/dual(2, (self, that) => {\n  if (self._tag === OP_NONE) {\n    return that;\n  }\n  if (that._tag === OP_NONE) {\n    return self;\n  }\n  return new Composite(self, that);\n});\n/** @internal */\nexport const combineAll = fiberIds => {\n  return pipe(fiberIds, HashSet.reduce(none, (a, b) => combine(b)(a)));\n};\n/** @internal */\nexport const getOrElse = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? that : self);\n/** @internal */\nexport const ids = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return HashSet.empty();\n      }\n    case OP_RUNTIME:\n      {\n        return HashSet.make(self.id);\n      }\n    case OP_COMPOSITE:\n      {\n        return pipe(ids(self.left), HashSet.union(ids(self.right)));\n      }\n  }\n};\nconst _fiberCounter = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/Fiber/Id/_fiberCounter\"), () => MutableRef.make(0));\n/** @internal */\nexport const make = (id, startTimeSeconds) => {\n  return new Runtime(id, startTimeSeconds);\n};\n/** @internal */\nexport const threadName = self => {\n  const identifiers = Array.from(ids(self)).map(n => `#${n}`).join(\",\");\n  return identifiers;\n};\n/** @internal */\nexport const toOption = self => {\n  const fiberIds = toSet(self);\n  if (HashSet.size(fiberIds) === 0) {\n    return Option.none();\n  }\n  let first = true;\n  let acc;\n  for (const fiberId of fiberIds) {\n    if (first) {\n      acc = fiberId;\n      first = false;\n    } else {\n      // @ts-expect-error\n      acc = pipe(acc, combine(fiberId));\n    }\n  }\n  // @ts-expect-error\n  return Option.some(acc);\n};\n/** @internal */\nexport const toSet = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return HashSet.empty();\n      }\n    case OP_RUNTIME:\n      {\n        return HashSet.make(self);\n      }\n    case OP_COMPOSITE:\n      {\n        return pipe(toSet(self.left), HashSet.union(toSet(self.right)));\n      }\n  }\n};\n/** @internal */\nexport const unsafeMake = () => {\n  const id = MutableRef.get(_fiberCounter);\n  pipe(_fiberCounter, MutableRef.set(id + 1));\n  return new Runtime(id, Date.now());\n};\n//# sourceMappingURL=fiberId.js.map","import * as internal from \"./internal/fiberId.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FiberIdTypeId = internal.FiberIdTypeId;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const none = internal.none;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const runtime = internal.runtime;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const composite = internal.composite;\n/**\n * Returns `true` if the specified unknown value is a `FiberId`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isFiberId = internal.isFiberId;\n/**\n * Returns `true` if the `FiberId` is a `None`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isNone = internal.isNone;\n/**\n * Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isRuntime = internal.isRuntime;\n/**\n * Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isComposite = internal.isComposite;\n/**\n * Combine two `FiberId`s.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const combine = internal.combine;\n/**\n * Combines a set of `FiberId`s into a single `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const combineAll = internal.combineAll;\n/**\n * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const getOrElse = internal.getOrElse;\n/**\n * Get the set of identifiers for this `FiberId`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const ids = internal.ids;\n/**\n * Creates a new `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Creates a string representing the name of the current thread of execution\n * represented by the specified `FiberId`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const threadName = internal.threadName;\n/**\n * Convert a `FiberId` into an `Option<FiberId>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toOption = internal.toOption;\n/**\n * Convert a `FiberId` into a `HashSet<FiberId>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toSet = internal.toSet;\n/**\n * Unsafely creates a new `FiberId`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake = internal.unsafeMake;\n//# sourceMappingURL=FiberId.js.map","/**\n * @since 2.0.0\n */\nimport * as HM from \"./internal/hashMap.js\";\nimport * as _keySet from \"./internal/hashMap/keySet.js\";\nconst TypeId = HM.HashMapTypeId;\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHashMap = HM.isHashMap;\n/**\n * Creates a new `HashMap`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = HM.empty;\n/**\n * Constructs a new `HashMap` from an array of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = HM.make;\n/**\n * Creates a new `HashMap` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = HM.fromIterable;\n/**\n * Checks if the `HashMap` contains any entries.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEmpty = HM.isEmpty;\n/**\n * Safely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const get = HM.get;\n/**\n * Lookup the value for the specified key in the `HashMap` using a custom hash.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const getHash = HM.getHash;\n/**\n * Unsafely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet = HM.unsafeGet;\n/**\n * Checks if the specified key has an entry in the `HashMap`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const has = HM.has;\n/**\n * Checks if the specified key has an entry in the `HashMap` using a custom\n * hash.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const hasHash = HM.hasHash;\n/**\n * Sets the specified key to the specified value using the internal hashing\n * function.\n *\n * @since 2.0.0\n */\nexport const set = HM.set;\n/**\n * Returns an `IterableIterator` of the keys within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const keys = HM.keys;\n/**\n * Returns a `HashSet` of keys within the `HashMap`.\n *\n * @since 2.0.0\n * @category getter\n */\nexport const keySet = _keySet.keySet;\n/**\n * Returns an `IterableIterator` of the values within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const values = HM.values;\n/**\n * Returns an `IterableIterator` of the entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const entries = HM.entries;\n/**\n * Returns an `Array<[K, V]>` of the entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const toEntries = self => Array.from(entries(self));\n/**\n * Returns the number of entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = HM.size;\n/**\n * Marks the `HashMap` as mutable.\n *\n * @since 2.0.0\n */\nexport const beginMutation = HM.beginMutation;\n/**\n * Marks the `HashMap` as immutable.\n *\n * @since 2.0.0\n */\nexport const endMutation = HM.endMutation;\n/**\n * Mutates the `HashMap` within the context of the provided function.\n *\n * @since 2.0.0\n */\nexport const mutate = HM.mutate;\n/**\n * Set or remove the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * @since 2.0.0\n */\nexport const modifyAt = HM.modifyAt;\n/**\n * Alter the value of the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * This function will always either update or insert a value into the `HashMap`.\n *\n * @since 2.0.0\n */\nexport const modifyHash = HM.modifyHash;\n/**\n * Updates the value of the specified key within the `HashMap` if it exists.\n *\n * @since 2.0.0\n */\nexport const modify = HM.modify;\n/**\n * Performs a union of this `HashMap` and that `HashMap`.\n *\n * @since 2.0.0\n */\nexport const union = HM.union;\n/**\n * Remove the entry for the specified key in the `HashMap` using the internal\n * hashing function.\n *\n * @since 2.0.0\n */\nexport const remove = HM.remove;\n/**\n * Removes all entries in the `HashMap` which have the specified keys.\n *\n * @since 2.0.0\n */\nexport const removeMany = HM.removeMany;\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = HM.map;\n/**\n * Chains over the entries of the `HashMap` using the specified function.\n *\n * **NOTE**: the hash and equal of both maps have to be the same.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = HM.flatMap;\n/**\n * Applies the specified function to the entries of the `HashMap`.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach = HM.forEach;\n/**\n * Reduces the specified state over the entries of the `HashMap`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce = HM.reduce;\n/**\n * Filters entries out of a `HashMap` using the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter = HM.filter;\n/**\n * Filters out `None` values from a `HashMap` of `Options`s.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const compact = HM.compact;\n/**\n * Maps over the entries of the `HashMap` using the specified partial function\n * and filters out `None` values.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMap = HM.filterMap;\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst = HM.findFirst;\n//# sourceMappingURL=HashMap.js.map","/**\n * A data type for immutable linked lists representing ordered collections of elements of type `A`.\n *\n * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n *\n * **Performance**\n *\n * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.\n *\n * @since 2.0.0\n */\n/**\n * This file is ported from\n *\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n */\nimport * as Arr from \"./Array.js\";\nimport * as Chunk from \"./Chunk.js\";\nimport * as Either from \"./Either.js\";\nimport * as Equal from \"./Equal.js\";\nimport * as Equivalence from \"./Equivalence.js\";\nimport { dual, identity, unsafeCoerce } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/List\");\n/**\n * Converts the specified `List` to an `Array`.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray = self => Arr.fromIterable(self);\n/**\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = isEquivalent => Equivalence.mapInput(Arr.getEquivalence(isEquivalent), toArray);\nconst _equivalence = /*#__PURE__*/getEquivalence(Equal.equals);\nconst ConsProto = {\n  [TypeId]: TypeId,\n  _tag: \"Cons\",\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Cons\",\n      values: toArray(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag && _equivalence(this, that);\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.array(toArray(this)));\n  },\n  [Symbol.iterator]() {\n    let done = false;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let self = this;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (self._tag === \"Nil\") {\n          done = true;\n          return this.return();\n        }\n        const value = self.head;\n        self = self.tail;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeCons = (head, tail) => {\n  const cons = Object.create(ConsProto);\n  cons.head = head;\n  cons.tail = tail;\n  return cons;\n};\nconst NilHash = /*#__PURE__*/Hash.string(\"Nil\");\nconst NilProto = {\n  [TypeId]: TypeId,\n  _tag: \"Nil\",\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Nil\"\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [Hash.symbol]() {\n    return NilHash;\n  },\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag;\n  },\n  [Symbol.iterator]() {\n    return {\n      next() {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst _Nil = /*#__PURE__*/Object.create(NilProto);\n/**\n * Returns `true` if the specified value is a `List`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isList = u => hasProperty(u, TypeId);\n/**\n * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isNil = self => self._tag === \"Nil\";\n/**\n * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isCons = self => self._tag === \"Cons\";\n/**\n * Returns the number of elements contained in the specified `List`\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = self => {\n  let these = self;\n  let len = 0;\n  while (!isNil(these)) {\n    len += 1;\n    these = these.tail;\n  }\n  return len;\n};\n/**\n * Constructs a new empty `List<A>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nil = () => _Nil;\n/**\n * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const cons = (head, tail) => makeCons(head, tail);\n/**\n * Constructs a new empty `List<A>`.\n *\n * Alias of {@link nil}.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = nil;\n/**\n * Constructs a new `List<A>` from the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const of = value => makeCons(value, _Nil);\n/**\n * Creates a new `List` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = prefix => {\n  const iterator = prefix[Symbol.iterator]();\n  let next;\n  if ((next = iterator.next()) && !next.done) {\n    const result = makeCons(next.value, _Nil);\n    let curr = result;\n    while ((next = iterator.next()) && !next.done) {\n      const temp = makeCons(next.value, _Nil);\n      curr.tail = temp;\n      curr = temp;\n    }\n    return result;\n  } else {\n    return _Nil;\n  }\n};\n/**\n * Constructs a new `List<A>` from the specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = (...elements) => fromIterable(elements);\n/**\n * Appends the specified element to the end of the `List`, creating a new `Cons`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append = /*#__PURE__*/dual(2, (self, element) => appendAll(self, of(element)));\n/**\n * Concatenates two lists, combining their elements.\n * If either list is non-empty, the result is also a non-empty list.\n *\n * @example\n * import { List } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n *   [1, 2, \"a\", \"b\"]\n * )\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll = /*#__PURE__*/dual(2, (self, that) => prependAll(that, self));\n/**\n * Prepends the specified element to the beginning of the list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend = /*#__PURE__*/dual(2, (self, element) => cons(element, self));\n/**\n * Prepends the specified prefix list to the beginning of the specified list.\n * If either list is non-empty, the result is also a non-empty list.\n *\n * @example\n * import { List } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n *   [\"a\", \"b\", 1, 2]\n * )\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll = /*#__PURE__*/dual(2, (self, prefix) => {\n  if (isNil(self)) {\n    return prefix;\n  } else if (isNil(prefix)) {\n    return self;\n  } else {\n    const result = makeCons(prefix.head, self);\n    let curr = result;\n    let that = prefix.tail;\n    while (!isNil(that)) {\n      const temp = makeCons(that.head, self);\n      curr.tail = temp;\n      curr = temp;\n      that = that.tail;\n    }\n    return result;\n  }\n});\n/**\n * Prepends the specified prefix list (in reverse order) to the beginning of the\n * specified list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAllReversed = /*#__PURE__*/dual(2, (self, prefix) => {\n  let out = self;\n  let pres = prefix;\n  while (isCons(pres)) {\n    out = makeCons(pres.head, out);\n    pres = pres.tail;\n  }\n  return out;\n});\n/**\n * Drops the first `n` elements from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const drop = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  }\n  if (n >= size(self)) {\n    return _Nil;\n  }\n  let these = self;\n  let i = 0;\n  while (!isNil(these) && i < n) {\n    these = these.tail;\n    i += 1;\n  }\n  return these;\n});\n/**\n * Check if a predicate holds true for every `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const every = /*#__PURE__*/dual(2, (self, refinement) => {\n  for (const a of self) {\n    if (!refinement(a)) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * Check if a predicate holds true for some `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const some = /*#__PURE__*/dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return true;\n    }\n    these = these.tail;\n  }\n  return false;\n});\n/**\n * Filters a list using the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => noneIn(self, predicate, false));\n// everything seen so far is not included\nconst noneIn = (self, predicate, isFlipped) => {\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    if (isNil(self)) {\n      return _Nil;\n    } else {\n      if (predicate(self.head) !== isFlipped) {\n        return allIn(self, self.tail, predicate, isFlipped);\n      } else {\n        self = self.tail;\n      }\n    }\n  }\n};\n// everything from 'start' is included, if everything from this point is in we can return the origin\n// start otherwise if we discover an element that is out we must create a new partial list.\nconst allIn = (start, remaining, predicate, isFlipped) => {\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    if (isNil(remaining)) {\n      return start;\n    } else {\n      if (predicate(remaining.head) !== isFlipped) {\n        remaining = remaining.tail;\n      } else {\n        return partialFill(start, remaining, predicate, isFlipped);\n      }\n    }\n  }\n};\n// we have seen elements that should be included then one that should be excluded, start building\nconst partialFill = (origStart, firstMiss, predicate, isFlipped) => {\n  const newHead = makeCons(unsafeHead(origStart), _Nil);\n  let toProcess = unsafeTail(origStart);\n  let currentLast = newHead;\n  // we know that all elements are :: until at least firstMiss.tail\n  while (!(toProcess === firstMiss)) {\n    const newElem = makeCons(unsafeHead(toProcess), _Nil);\n    currentLast.tail = newElem;\n    currentLast = unsafeCoerce(newElem);\n    toProcess = unsafeCoerce(toProcess.tail);\n  }\n  // at this point newHead points to a list which is a duplicate of all the 'in' elements up to the first miss.\n  // currentLast is the last element in that list.\n  // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n  let next = firstMiss.tail;\n  let nextToCopy = unsafeCoerce(next); // the next element we would need to copy to our list if we cant share.\n  while (!isNil(next)) {\n    // generally recommended is next.isNonEmpty but this incurs an extra method call.\n    const head = unsafeHead(next);\n    if (predicate(head) !== isFlipped) {\n      next = next.tail;\n    } else {\n      // its not a match - do we have outstanding elements?\n      while (!(nextToCopy === next)) {\n        const newElem = makeCons(unsafeHead(nextToCopy), _Nil);\n        currentLast.tail = newElem;\n        currentLast = newElem;\n        nextToCopy = unsafeCoerce(nextToCopy.tail);\n      }\n      nextToCopy = unsafeCoerce(next.tail);\n      next = next.tail;\n    }\n  }\n  // we have remaining elements - they are unchanged attach them to the end\n  if (!isNil(nextToCopy)) {\n    currentLast.tail = nextToCopy;\n  }\n  return newHead;\n};\n/**\n * Filters and maps a list using the specified partial function. The resulting\n * list may be smaller than the input list due to the possibility of the partial\n * function not being defined for some elements.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => {\n  const bs = [];\n  for (const a of self) {\n    const oa = f(a);\n    if (Option.isSome(oa)) {\n      bs.push(oa.value);\n    }\n  }\n  return fromIterable(bs);\n});\n/**\n * Removes all `None` values from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const compact = self => filterMap(self, identity);\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst = /*#__PURE__*/dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return Option.some(these.head);\n    }\n    these = these.tail;\n  }\n  return Option.none();\n});\n/**\n * Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  let rest = self;\n  let head = undefined;\n  let tail = undefined;\n  while (!isNil(rest)) {\n    let bs = f(rest.head);\n    while (!isNil(bs)) {\n      const next = makeCons(bs.head, _Nil);\n      if (tail === undefined) {\n        head = next;\n      } else {\n        tail.tail = next;\n      }\n      tail = next;\n      bs = bs.tail;\n    }\n    rest = rest.tail;\n  }\n  if (head === undefined) {\n    return _Nil;\n  }\n  return head;\n});\n/**\n * Applies the specified function to each element of the `List`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => {\n  let these = self;\n  while (!isNil(these)) {\n    f(these.head);\n    these = these.tail;\n  }\n});\n/**\n * Returns the first element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const head = self => isNil(self) ? Option.none() : Option.some(self.head);\n/**\n * Returns the last element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const last = self => isNil(self) ? Option.none() : Option.some(unsafeLast(self));\n/**\n * Applies the specified mapping function to each element of the list.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => {\n  if (isNil(self)) {\n    return self;\n  } else {\n    let i = 0;\n    const head = makeCons(f(self.head, i++), _Nil);\n    let nextHead = head;\n    let rest = self.tail;\n    while (!isNil(rest)) {\n      const next = makeCons(f(rest.head, i++), _Nil);\n      nextHead.tail = next;\n      nextHead = next;\n      rest = rest.tail;\n    }\n    return head;\n  }\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * that did not satisfy the specified predicate, and the second list contains\n * all elements that did satisfy the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    if (predicate(a)) {\n      right.push(a);\n    } else {\n      left.push(a);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * for which the specified function returned a `Left`, and the second list\n * contains all elements for which the specified function returned a `Right`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    const e = f(a);\n    if (Either.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Folds over the elements of the list using the specified function, using the\n * specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = self;\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Folds over the elements of the list using the specified function, beginning\n * with the last element of the list, using the specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduceRight = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = reverse(self);\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Returns a new list with the elements of the specified list in reverse order.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reverse = self => {\n  let result = empty();\n  let these = self;\n  while (!isNil(these)) {\n    result = prepend(result, these.head);\n    these = these.tail;\n  }\n  return result;\n};\n/**\n * Splits the specified list into two lists at the specified index.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const splitAt = /*#__PURE__*/dual(2, (self, n) => [take(self, n), drop(self, n)]);\n/**\n * Returns the tail of the specified list, or `None` if the list is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const tail = self => isNil(self) ? Option.none() : Option.some(self.tail);\n/**\n * Takes the specified number of elements from the beginning of the specified\n * list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const take = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return _Nil;\n  }\n  if (n >= size(self)) {\n    return self;\n  }\n  let these = make(unsafeHead(self));\n  let current = unsafeTail(self);\n  for (let i = 1; i < n; i++) {\n    these = makeCons(unsafeHead(current), these);\n    current = unsafeTail(current);\n  }\n  return reverse(these);\n});\n/**\n * Converts the specified `List` to a `Chunk`.\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const toChunk = self => Chunk.fromIterable(self);\nconst getExpectedListToBeNonEmptyErrorMessage = \"Expected List to be non-empty\";\n/**\n * Unsafely returns the first element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeHead = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  return self.head;\n};\n/**\n * Unsafely returns the last element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeLast = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  let these = self;\n  let scout = self.tail;\n  while (!isNil(scout)) {\n    these = scout;\n    scout = scout.tail;\n  }\n  return these.head;\n};\n/**\n * Unsafely returns the tail of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeTail = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  return self.tail;\n};\n//# sourceMappingURL=List.js.map","import * as Equal from \"../Equal.js\";\nimport * as Hash from \"../Hash.js\";\nimport { StructuralPrototype } from \"./effectable.js\";\n/** @internal */\nexport const ArrayProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(Array.prototype), {\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.array(this));\n  },\n  [Equal.symbol](that) {\n    if (Array.isArray(that) && this.length === that.length) {\n      return this.every((v, i) => Equal.equals(v, that[i]));\n    } else {\n      return false;\n    }\n  }\n});\n/** @internal */\nexport const Structural = /*#__PURE__*/function () {\n  function Structural(args) {\n    if (args) {\n      Object.assign(this, args);\n    }\n  }\n  Structural.prototype = StructuralPrototype;\n  return Structural;\n}();\n/** @internal */\nexport const struct = as => Object.assign(Object.create(StructuralPrototype), as);\n//# sourceMappingURL=data.js.map","import * as Chunk from \"../../Chunk.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Dual from \"../../Function.js\";\nimport { makeContext } from \"../context.js\";\nimport { Structural } from \"../data.js\";\n/** @internal */\nexport const ContextPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferContextPatch\");\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [ContextPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/**\n * @internal\n */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\nconst makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AddServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AddService\"\n});\nconst makeAddService = (key, service) => {\n  const o = Object.create(AddServiceProto);\n  o.key = key;\n  o.service = service;\n  return o;\n};\nconst RemoveServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"RemoveService\"\n});\nconst makeRemoveService = key => {\n  const o = Object.create(RemoveServiceProto);\n  o.key = key;\n  return o;\n};\nconst UpdateServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"UpdateService\"\n});\nconst makeUpdateService = (key, update) => {\n  const o = Object.create(UpdateServiceProto);\n  o.key = key;\n  o.update = update;\n  return o;\n};\n/** @internal */\nexport const diff = (oldValue, newValue) => {\n  const missingServices = new Map(oldValue.unsafeMap);\n  let patch = empty();\n  for (const [tag, newService] of newValue.unsafeMap.entries()) {\n    if (missingServices.has(tag)) {\n      const old = missingServices.get(tag);\n      missingServices.delete(tag);\n      if (!Equal.equals(old, newService)) {\n        patch = combine(makeUpdateService(tag, () => newService))(patch);\n      }\n    } else {\n      missingServices.delete(tag);\n      patch = combine(makeAddService(tag, newService))(patch);\n    }\n  }\n  for (const [tag] of missingServices.entries()) {\n    patch = combine(makeRemoveService(tag))(patch);\n  }\n  return patch;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(2, (self, context) => {\n  if (self._tag === \"Empty\") {\n    return context;\n  }\n  let wasServiceUpdated = false;\n  let patches = Chunk.of(self);\n  const updatedContext = new Map(context.unsafeMap);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AddService\":\n        {\n          updatedContext.set(head.key, head.service);\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(Chunk.prepend(tail, head.second), head.first);\n          break;\n        }\n      case \"RemoveService\":\n        {\n          updatedContext.delete(head.key);\n          patches = tail;\n          break;\n        }\n      case \"UpdateService\":\n        {\n          updatedContext.set(head.key, head.update(updatedContext.get(head.key)));\n          wasServiceUpdated = true;\n          patches = tail;\n          break;\n        }\n    }\n  }\n  if (!wasServiceUpdated) {\n    return makeContext(updatedContext);\n  }\n  const map = new Map();\n  for (const [tag] of context.unsafeMap) {\n    if (updatedContext.has(tag)) {\n      map.set(tag, updatedContext.get(tag));\n      updatedContext.delete(tag);\n    }\n  }\n  for (const [tag, s] of updatedContext) {\n    map.set(tag, s);\n  }\n  return makeContext(map);\n});\n//# sourceMappingURL=contextPatch.js.map","import * as Chunk from \"../../Chunk.js\";\nimport * as Dual from \"../../Function.js\";\nimport * as HashSet from \"../../HashSet.js\";\nimport { Structural } from \"../data.js\";\n/** @internal */\nexport const HashSetPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferHashSetPatch\");\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [HashSetPatchTypeId]: {\n    _Value: variance,\n    _Key: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/** @internal */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\n/** @internal */\nexport const makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AddProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Add\"\n});\n/** @internal */\nexport const makeAdd = value => {\n  const o = Object.create(AddProto);\n  o.value = value;\n  return o;\n};\nconst RemoveProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Remove\"\n});\n/** @internal */\nexport const makeRemove = value => {\n  const o = Object.create(RemoveProto);\n  o.value = value;\n  return o;\n};\n/** @internal */\nexport const diff = (oldValue, newValue) => {\n  const [removed, patch] = HashSet.reduce([oldValue, empty()], ([set, patch], value) => {\n    if (HashSet.has(value)(set)) {\n      return [HashSet.remove(value)(set), patch];\n    }\n    return [set, combine(makeAdd(value))(patch)];\n  })(newValue);\n  return HashSet.reduce(patch, (patch, value) => combine(makeRemove(value))(patch))(removed);\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(2, (self, oldValue) => {\n  if (self._tag === \"Empty\") {\n    return oldValue;\n  }\n  let set = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Add\":\n        {\n          set = HashSet.add(head.value)(set);\n          patches = tail;\n          break;\n        }\n      case \"Remove\":\n        {\n          set = HashSet.remove(head.value)(set);\n          patches = tail;\n        }\n    }\n  }\n  return set;\n});\n//# sourceMappingURL=hashSetPatch.js.map","import * as Arr from \"../../Array.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Dual from \"../../Function.js\";\nimport * as Data from \"../data.js\";\n/** @internal */\nexport const ReadonlyArrayPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferReadonlyArrayPatch\");\nfunction variance(a) {\n  return a;\n}\nconst PatchProto = {\n  ...Data.Structural.prototype,\n  [ReadonlyArrayPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/**\n * @internal\n */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\nconst makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AppendProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Append\"\n});\nconst makeAppend = values => {\n  const o = Object.create(AppendProto);\n  o.values = values;\n  return o;\n};\nconst SliceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Slice\"\n});\nconst makeSlice = (from, until) => {\n  const o = Object.create(SliceProto);\n  o.from = from;\n  o.until = until;\n  return o;\n};\nconst UpdateProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Update\"\n});\nconst makeUpdate = (index, patch) => {\n  const o = Object.create(UpdateProto);\n  o.index = index;\n  o.patch = patch;\n  return o;\n};\n/** @internal */\nexport const diff = options => {\n  let i = 0;\n  let patch = empty();\n  while (i < options.oldValue.length && i < options.newValue.length) {\n    const oldElement = options.oldValue[i];\n    const newElement = options.newValue[i];\n    const valuePatch = options.differ.diff(oldElement, newElement);\n    if (!Equal.equals(valuePatch, options.differ.empty)) {\n      patch = combine(patch, makeUpdate(i, valuePatch));\n    }\n    i = i + 1;\n  }\n  if (i < options.oldValue.length) {\n    patch = combine(patch, makeSlice(0, i));\n  }\n  if (i < options.newValue.length) {\n    patch = combine(patch, makeAppend(Arr.drop(i)(options.newValue)));\n  }\n  return patch;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(3, (self, oldValue, differ) => {\n  if (self._tag === \"Empty\") {\n    return oldValue;\n  }\n  let readonlyArray = oldValue.slice();\n  let patches = Arr.of(self);\n  while (Arr.isNonEmptyArray(patches)) {\n    const head = Arr.headNonEmpty(patches);\n    const tail = Arr.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          tail.unshift(head.first, head.second);\n          patches = tail;\n          break;\n        }\n      case \"Append\":\n        {\n          for (const value of head.values) {\n            readonlyArray.push(value);\n          }\n          patches = tail;\n          break;\n        }\n      case \"Slice\":\n        {\n          readonlyArray = readonlyArray.slice(head.from, head.until);\n          patches = tail;\n          break;\n        }\n      case \"Update\":\n        {\n          readonlyArray[head.index] = differ.patch(head.patch, readonlyArray[head.index]);\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return readonlyArray;\n});\n//# sourceMappingURL=readonlyArrayPatch.js.map","import * as Equal from \"../Equal.js\";\nimport * as Dual from \"../Function.js\";\nimport { constant, identity } from \"../Function.js\";\nimport * as ChunkPatch from \"./differ/chunkPatch.js\";\nimport * as ContextPatch from \"./differ/contextPatch.js\";\nimport * as HashMapPatch from \"./differ/hashMapPatch.js\";\nimport * as HashSetPatch from \"./differ/hashSetPatch.js\";\nimport * as OrPatch from \"./differ/orPatch.js\";\nimport * as ReadonlyArrayPatch from \"./differ/readonlyArrayPatch.js\";\n/** @internal */\nexport const DifferTypeId = /*#__PURE__*/Symbol.for(\"effect/Differ\");\n/** @internal */\nexport const DifferProto = {\n  [DifferTypeId]: {\n    _P: identity,\n    _V: identity\n  }\n};\n/** @internal */\nexport const make = params => {\n  const differ = Object.create(DifferProto);\n  differ.empty = params.empty;\n  differ.diff = params.diff;\n  differ.combine = params.combine;\n  differ.patch = params.patch;\n  return differ;\n};\n/** @internal */\nexport const environment = () => make({\n  empty: ContextPatch.empty(),\n  combine: (first, second) => ContextPatch.combine(second)(first),\n  diff: (oldValue, newValue) => ContextPatch.diff(oldValue, newValue),\n  patch: (patch, oldValue) => ContextPatch.patch(oldValue)(patch)\n});\n/** @internal */\nexport const chunk = differ => make({\n  empty: ChunkPatch.empty(),\n  combine: (first, second) => ChunkPatch.combine(second)(first),\n  diff: (oldValue, newValue) => ChunkPatch.diff({\n    oldValue,\n    newValue,\n    differ\n  }),\n  patch: (patch, oldValue) => ChunkPatch.patch(oldValue, differ)(patch)\n});\n/** @internal */\nexport const hashMap = differ => make({\n  empty: HashMapPatch.empty(),\n  combine: (first, second) => HashMapPatch.combine(second)(first),\n  diff: (oldValue, newValue) => HashMapPatch.diff({\n    oldValue,\n    newValue,\n    differ\n  }),\n  patch: (patch, oldValue) => HashMapPatch.patch(oldValue, differ)(patch)\n});\n/** @internal */\nexport const hashSet = () => make({\n  empty: HashSetPatch.empty(),\n  combine: (first, second) => HashSetPatch.combine(second)(first),\n  diff: (oldValue, newValue) => HashSetPatch.diff(oldValue, newValue),\n  patch: (patch, oldValue) => HashSetPatch.patch(oldValue)(patch)\n});\n/** @internal */\nexport const orElseEither = /*#__PURE__*/Dual.dual(2, (self, that) => make({\n  empty: OrPatch.empty(),\n  combine: (first, second) => OrPatch.combine(first, second),\n  diff: (oldValue, newValue) => OrPatch.diff({\n    oldValue,\n    newValue,\n    left: self,\n    right: that\n  }),\n  patch: (patch, oldValue) => OrPatch.patch(patch, {\n    oldValue,\n    left: self,\n    right: that\n  })\n}));\n/** @internal */\nexport const readonlyArray = differ => make({\n  empty: ReadonlyArrayPatch.empty(),\n  combine: (first, second) => ReadonlyArrayPatch.combine(first, second),\n  diff: (oldValue, newValue) => ReadonlyArrayPatch.diff({\n    oldValue,\n    newValue,\n    differ\n  }),\n  patch: (patch, oldValue) => ReadonlyArrayPatch.patch(patch, oldValue, differ)\n});\n/** @internal */\nexport const transform = /*#__PURE__*/Dual.dual(2, (self, {\n  toNew,\n  toOld\n}) => make({\n  empty: self.empty,\n  combine: (first, second) => self.combine(first, second),\n  diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),\n  patch: (patch, oldValue) => toNew(self.patch(patch, toOld(oldValue)))\n}));\n/** @internal */\nexport const update = () => updateWith((_, a) => a);\n/** @internal */\nexport const updateWith = f => make({\n  empty: identity,\n  combine: (first, second) => {\n    if (first === identity) {\n      return second;\n    }\n    if (second === identity) {\n      return first;\n    }\n    return a => second(first(a));\n  },\n  diff: (oldValue, newValue) => {\n    if (Equal.equals(oldValue, newValue)) {\n      return identity;\n    }\n    return constant(newValue);\n  },\n  patch: (patch, oldValue) => f(oldValue, patch(oldValue))\n});\n/** @internal */\nexport const zip = /*#__PURE__*/Dual.dual(2, (self, that) => make({\n  empty: [self.empty, that.empty],\n  combine: (first, second) => [self.combine(first[0], second[0]), that.combine(first[1], second[1])],\n  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],\n  patch: (patch, oldValue) => [self.patch(patch[0], oldValue[0]), that.patch(patch[1], oldValue[1])]\n}));\n//# sourceMappingURL=differ.js.map","import { dual } from \"../Function.js\";\n/** @internal */\nconst BIT_MASK = 0xff;\n/** @internal */\nconst BIT_SHIFT = 0x08;\n/** @internal */\nexport const active = patch => patch & BIT_MASK;\n/** @internal */\nexport const enabled = patch => patch >> BIT_SHIFT & BIT_MASK;\n/** @internal */\nexport const make = (active, enabled) => (active & BIT_MASK) + ((enabled & active & BIT_MASK) << BIT_SHIFT);\n/** @internal */\nexport const empty = /*#__PURE__*/make(0, 0);\n/** @internal */\nexport const enable = flag => make(flag, flag);\n/** @internal */\nexport const disable = flag => make(flag, 0);\n/** @internal */\nexport const isEmpty = patch => patch === 0;\n/** @internal */\nexport const isActive = /*#__PURE__*/dual(2, (self, flag) => (active(self) & flag) !== 0);\n/** @internal */\nexport const isEnabled = /*#__PURE__*/dual(2, (self, flag) => (enabled(self) & flag) !== 0);\n/** @internal */\nexport const isDisabled = /*#__PURE__*/dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);\n/** @internal */\nexport const exclude = /*#__PURE__*/dual(2, (self, flag) => make(active(self) & ~flag, enabled(self)));\n/** @internal */\nexport const both = /*#__PURE__*/dual(2, (self, that) => make(active(self) | active(that), enabled(self) & enabled(that)));\n/** @internal */\nexport const either = /*#__PURE__*/dual(2, (self, that) => make(active(self) | active(that), enabled(self) | enabled(that)));\n/** @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, that) => self | that);\n/** @internal */\nexport const inverse = patch => make(enabled(patch), invert(active(patch)));\n/** @internal */\nexport const invert = n => ~n >>> 0 & BIT_MASK;\n//# sourceMappingURL=runtimeFlagsPatch.js.map","import { dual } from \"../Function.js\";\nimport * as internalDiffer from \"./differ.js\";\nimport * as runtimeFlagsPatch from \"./runtimeFlagsPatch.js\";\n/** @internal */\nexport const None = 0;\n/** @internal */\nexport const Interruption = 1 << 0;\n/** @internal */\nexport const OpSupervision = 1 << 1;\n/** @internal */\nexport const RuntimeMetrics = 1 << 2;\n/** @internal */\nexport const WindDown = 1 << 4;\n/** @internal */\nexport const CooperativeYielding = 1 << 5;\n/** @internal */\nexport const allFlags = [None, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];\nconst print = flag => {\n  switch (flag) {\n    case CooperativeYielding:\n      {\n        return \"CooperativeYielding\";\n      }\n    case WindDown:\n      {\n        return \"WindDown\";\n      }\n    case RuntimeMetrics:\n      {\n        return \"RuntimeMetrics\";\n      }\n    case OpSupervision:\n      {\n        return \"OpSupervision\";\n      }\n    case Interruption:\n      {\n        return \"Interruption\";\n      }\n    case None:\n      {\n        return \"None\";\n      }\n  }\n};\n/** @internal */\nexport const cooperativeYielding = self => isEnabled(self, CooperativeYielding);\n/** @internal */\nexport const disable = /*#__PURE__*/dual(2, (self, flag) => self & ~flag);\n/** @internal */\nexport const disableAll = /*#__PURE__*/dual(2, (self, flags) => self & ~flags);\n/** @internal */\nexport const enable = /*#__PURE__*/dual(2, (self, flag) => self | flag);\n/** @internal */\nexport const enableAll = /*#__PURE__*/dual(2, (self, flags) => self | flags);\n/** @internal */\nexport const interruptible = self => interruption(self) && !windDown(self);\n/** @internal */\nexport const interruption = self => isEnabled(self, Interruption);\n/** @internal */\nexport const isDisabled = /*#__PURE__*/dual(2, (self, flag) => !isEnabled(self, flag));\n/** @internal */\nexport const isEnabled = /*#__PURE__*/dual(2, (self, flag) => (self & flag) !== 0);\n/** @internal */\nexport const make = (...flags) => flags.reduce((a, b) => a | b, 0);\n/** @internal */\nexport const none = /*#__PURE__*/make(None);\n/** @internal */\nexport const opSupervision = self => isEnabled(self, OpSupervision);\n/** @internal */\nexport const render = self => {\n  const active = [];\n  allFlags.forEach(flag => {\n    if (isEnabled(self, flag)) {\n      active.push(`${print(flag)}`);\n    }\n  });\n  return `RuntimeFlags(${active.join(\", \")})`;\n};\n/** @internal */\nexport const runtimeMetrics = self => isEnabled(self, RuntimeMetrics);\n/** @internal */\nexport const toSet = self => new Set(allFlags.filter(flag => isEnabled(self, flag)));\nexport const windDown = self => isEnabled(self, WindDown);\n// circular with RuntimeFlagsPatch\n/** @internal */\nexport const enabledSet = self => toSet(runtimeFlagsPatch.active(self) & runtimeFlagsPatch.enabled(self));\n/** @internal */\nexport const disabledSet = self => toSet(runtimeFlagsPatch.active(self) & ~runtimeFlagsPatch.enabled(self));\n/** @internal */\nexport const diff = /*#__PURE__*/dual(2, (self, that) => runtimeFlagsPatch.make(self ^ that, that));\n/** @internal */\nexport const patch = /*#__PURE__*/dual(2, (self, patch) => self & (runtimeFlagsPatch.invert(runtimeFlagsPatch.active(patch)) | runtimeFlagsPatch.enabled(patch)) | runtimeFlagsPatch.active(patch) & runtimeFlagsPatch.enabled(patch));\n/** @internal */\nexport const renderPatch = self => {\n  const enabled = Array.from(enabledSet(self)).map(flag => print(flag)).join(\", \");\n  const disabled = Array.from(disabledSet(self)).map(flag => print(flag)).join(\", \");\n  return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`;\n};\n/** @internal */\nexport const differ = /*#__PURE__*/internalDiffer.make({\n  empty: runtimeFlagsPatch.empty,\n  diff: (oldValue, newValue) => diff(oldValue, newValue),\n  combine: (first, second) => runtimeFlagsPatch.andThen(second)(first),\n  patch: (_patch, oldValue) => patch(oldValue, _patch)\n});\n//# sourceMappingURL=runtimeFlags.js.map","/**\n * @since 2.0.0\n */\nimport * as runtimeFlags from \"./internal/runtimeFlags.js\";\nimport * as internal from \"./internal/runtimeFlagsPatch.js\";\n/**\n * The empty `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = internal.empty;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const enable = internal.enable;\n/**\n * Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const disable = internal.disable;\n/**\n * Returns `true` if the specified `RuntimeFlagsPatch` is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as active.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isActive = internal.isActive;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as enabled.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEnabled = internal.isEnabled;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as disabled.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isDisabled = internal.isDisabled;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` includes the specified\n * `RuntimeFlag`, `false` otherwise.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const includes = internal.isActive;\n/**\n * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\n * followed by `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const andThen = internal.andThen;\n/**\n * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\n * and `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const both = internal.both;\n/**\n * Creates a `RuntimeFlagsPatch` describing application of either the `self`\n * patch or `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const either = internal.either;\n/**\n * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n * `RuntimeFlag` from the set of `RuntimeFlags`.\n *\n * @category utils\n * @since 2.0.0\n */\nexport const exclude = internal.exclude;\n/**\n * Creates a `RuntimeFlagsPatch` which describes the inverse of the patch\n * specified by the provided `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const inverse = internal.inverse;\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * enabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const enabledSet = runtimeFlags.enabledSet;\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * disabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const disabledSet = runtimeFlags.disabledSet;\n/**\n * Renders the provided `RuntimeFlagsPatch` to a string.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const render = runtimeFlags.renderPatch;\n//# sourceMappingURL=RuntimeFlagsPatch.js.map","import * as Chunk from \"../Chunk.js\";\nimport * as Either from \"../Either.js\";\nimport * as Equal from \"../Equal.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport * as List from \"../List.js\";\nimport * as Option from \"../Option.js\";\nimport { hasProperty } from \"../Predicate.js\";\n/** @internal */\nexport const empty = {\n  _tag: \"Empty\"\n};\n/**\n * Combines this collection of blocked requests with the specified collection\n * of blocked requests, in parallel.\n *\n * @internal\n */\nexport const par = (self, that) => ({\n  _tag: \"Par\",\n  left: self,\n  right: that\n});\n/**\n * Combines this collection of blocked requests with the specified collection\n * of blocked requests, in sequence.\n *\n * @internal\n */\nexport const seq = (self, that) => ({\n  _tag: \"Seq\",\n  left: self,\n  right: that\n});\n/**\n * Constructs a collection of blocked requests from the specified blocked\n * request and data source.\n *\n * @internal\n */\nexport const single = (dataSource, blockedRequest) => ({\n  _tag: \"Single\",\n  dataSource: dataSource,\n  blockedRequest\n});\n/** @internal */\nexport const MapRequestResolversReducer = f => ({\n  emptyCase: () => empty,\n  parCase: (left, right) => par(left, right),\n  seqCase: (left, right) => seq(left, right),\n  singleCase: (dataSource, blockedRequest) => single(f(dataSource), blockedRequest)\n});\n/**\n * Transforms all data sources with the specified data source aspect, which\n * can change the environment type of data sources but must preserve the\n * request type of each data source.\n *\n * @internal\n */\nexport const mapRequestResolvers = (self, f) => reduce(self, MapRequestResolversReducer(f));\n/**\n * Folds over the cases of this collection of blocked requests with the\n * specified functions.\n *\n * @internal\n */\nexport const reduce = (self, reducer) => {\n  let input = List.of(self);\n  let output = List.empty();\n  while (List.isCons(input)) {\n    const current = input.head;\n    switch (current._tag) {\n      case \"Empty\":\n        {\n          output = List.cons(Either.right(reducer.emptyCase()), output);\n          input = input.tail;\n          break;\n        }\n      case \"Par\":\n        {\n          output = List.cons(Either.left({\n            _tag: \"ParCase\"\n          }), output);\n          input = List.cons(current.left, List.cons(current.right, input.tail));\n          break;\n        }\n      case \"Seq\":\n        {\n          output = List.cons(Either.left({\n            _tag: \"SeqCase\"\n          }), output);\n          input = List.cons(current.left, List.cons(current.right, input.tail));\n          break;\n        }\n      case \"Single\":\n        {\n          const result = reducer.singleCase(current.dataSource, current.blockedRequest);\n          output = List.cons(Either.right(result), output);\n          input = input.tail;\n          break;\n        }\n    }\n  }\n  const result = List.reduce(output, List.empty(), (acc, current) => {\n    switch (current._tag) {\n      case \"Left\":\n        {\n          const left = List.unsafeHead(acc);\n          const right = List.unsafeHead(List.unsafeTail(acc));\n          const tail = List.unsafeTail(List.unsafeTail(acc));\n          switch (current.left._tag) {\n            case \"ParCase\":\n              {\n                return List.cons(reducer.parCase(left, right), tail);\n              }\n            case \"SeqCase\":\n              {\n                return List.cons(reducer.seqCase(left, right), tail);\n              }\n          }\n        }\n      case \"Right\":\n        {\n          return List.cons(current.right, acc);\n        }\n    }\n  });\n  if (List.isNil(result)) {\n    throw new Error(\"BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/effect/issues\");\n  }\n  return result.head;\n};\n/**\n * Flattens a collection of blocked requests into a collection of pipelined\n * and batched requests that can be submitted for execution.\n *\n * @internal\n */\nexport const flatten = self => {\n  let current = List.of(self);\n  let updated = List.empty();\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = List.reduce(current, [parallelCollectionEmpty(), List.empty()], ([parallel, sequential], blockedRequest) => {\n      const [par, seq] = step(blockedRequest);\n      return [parallelCollectionCombine(parallel, par), List.appendAll(sequential, seq)];\n    });\n    updated = merge(updated, parallel);\n    if (List.isNil(sequential)) {\n      return List.reverse(updated);\n    }\n    current = sequential;\n  }\n  throw new Error(\"BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues\");\n};\n/**\n * Takes one step in evaluating a collection of blocked requests, returning a\n * collection of blocked requests that can be performed in parallel and a list\n * of blocked requests that must be performed sequentially after those\n * requests.\n */\nconst step = requests => {\n  let current = requests;\n  let parallel = parallelCollectionEmpty();\n  let stack = List.empty();\n  let sequential = List.empty();\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    switch (current._tag) {\n      case \"Empty\":\n        {\n          if (List.isNil(stack)) {\n            return [parallel, sequential];\n          }\n          current = stack.head;\n          stack = stack.tail;\n          break;\n        }\n      case \"Par\":\n        {\n          stack = List.cons(current.right, stack);\n          current = current.left;\n          break;\n        }\n      case \"Seq\":\n        {\n          const left = current.left;\n          const right = current.right;\n          switch (left._tag) {\n            case \"Empty\":\n              {\n                current = right;\n                break;\n              }\n            case \"Par\":\n              {\n                const l = left.left;\n                const r = left.right;\n                current = par(seq(l, right), seq(r, right));\n                break;\n              }\n            case \"Seq\":\n              {\n                const l = left.left;\n                const r = left.right;\n                current = seq(l, seq(r, right));\n                break;\n              }\n            case \"Single\":\n              {\n                current = left;\n                sequential = List.cons(right, sequential);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Single\":\n        {\n          parallel = parallelCollectionAdd(parallel, current);\n          if (List.isNil(stack)) {\n            return [parallel, sequential];\n          }\n          current = stack.head;\n          stack = stack.tail;\n          break;\n        }\n    }\n  }\n  throw new Error(\"BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues\");\n};\n/**\n * Merges a collection of requests that must be executed sequentially with a\n * collection of requests that can be executed in parallel. If the collections\n * are both from the same single data source then the requests can be\n * pipelined while preserving ordering guarantees.\n */\nconst merge = (sequential, parallel) => {\n  if (List.isNil(sequential)) {\n    return List.of(parallelCollectionToSequentialCollection(parallel));\n  }\n  if (parallelCollectionIsEmpty(parallel)) {\n    return sequential;\n  }\n  const seqHeadKeys = sequentialCollectionKeys(sequential.head);\n  const parKeys = parallelCollectionKeys(parallel);\n  if (seqHeadKeys.length === 1 && parKeys.length === 1 && Equal.equals(seqHeadKeys[0], parKeys[0])) {\n    return List.cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);\n  }\n  return List.cons(parallelCollectionToSequentialCollection(parallel), sequential);\n};\n//\n// circular\n//\n/** @internal */\nexport const EntryTypeId = /*#__PURE__*/Symbol.for(\"effect/RequestBlock/Entry\");\n/** @internal */\nclass EntryImpl {\n  request;\n  result;\n  listeners;\n  ownerId;\n  state;\n  [EntryTypeId] = blockedRequestVariance;\n  constructor(request, result, listeners, ownerId, state) {\n    this.request = request;\n    this.result = result;\n    this.listeners = listeners;\n    this.ownerId = ownerId;\n    this.state = state;\n  }\n}\nconst blockedRequestVariance = {\n  /* c8 ignore next */\n  _R: _ => _\n};\n/** @internal */\nexport const isEntry = u => hasProperty(u, EntryTypeId);\n/** @internal */\nexport const makeEntry = options => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);\n/** @internal */\nexport const RequestBlockParallelTypeId = /*#__PURE__*/Symbol.for(\"effect/RequestBlock/RequestBlockParallel\");\nconst parallelVariance = {\n  /* c8 ignore next */\n  _R: _ => _\n};\nclass ParallelImpl {\n  map;\n  [RequestBlockParallelTypeId] = parallelVariance;\n  constructor(map) {\n    this.map = map;\n  }\n}\n/** @internal */\nexport const parallelCollectionEmpty = () => new ParallelImpl(HashMap.empty());\n/** @internal */\nexport const parallelCollectionMake = (dataSource, blockedRequest) => new ParallelImpl(HashMap.make([dataSource, Chunk.of(blockedRequest)]));\n/** @internal */\nexport const parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(HashMap.modifyAt(self.map, blockedRequest.dataSource, _ => Option.orElseSome(Option.map(_, Chunk.append(blockedRequest.blockedRequest)), () => Chunk.of(blockedRequest.blockedRequest))));\n/** @internal */\nexport const parallelCollectionCombine = (self, that) => new ParallelImpl(HashMap.reduce(self.map, that.map, (map, value, key) => HashMap.set(map, key, Option.match(HashMap.get(map, key), {\n  onNone: () => value,\n  onSome: other => Chunk.appendAll(value, other)\n}))));\n/** @internal */\nexport const parallelCollectionIsEmpty = self => HashMap.isEmpty(self.map);\n/** @internal */\nexport const parallelCollectionKeys = self => Array.from(HashMap.keys(self.map));\n/** @internal */\nexport const parallelCollectionToSequentialCollection = self => sequentialCollectionMake(HashMap.map(self.map, x => Chunk.of(x)));\n// TODO\n// /** @internal */\n// export const parallelCollectionToChunk = <R>(\n//   self: ParallelCollection<R>\n// ): Array<[RequestResolver.RequestResolver<unknown, R>, Array<Request.Entry<unknown>>]> => Array.from(self.map) as any\n/** @internal */\nexport const SequentialCollectionTypeId = /*#__PURE__*/Symbol.for(\"effect/RequestBlock/RequestBlockSequential\");\nconst sequentialVariance = {\n  /* c8 ignore next */\n  _R: _ => _\n};\nclass SequentialImpl {\n  map;\n  [SequentialCollectionTypeId] = sequentialVariance;\n  constructor(map) {\n    this.map = map;\n  }\n}\n/** @internal */\nexport const sequentialCollectionMake = map => new SequentialImpl(map);\n/** @internal */\nexport const sequentialCollectionCombine = (self, that) => new SequentialImpl(HashMap.reduce(that.map, self.map, (map, value, key) => HashMap.set(map, key, Option.match(HashMap.get(map, key), {\n  onNone: () => Chunk.empty(),\n  onSome: a => Chunk.appendAll(a, value)\n}))));\n/** @internal */\nexport const sequentialCollectionIsEmpty = self => HashMap.isEmpty(self.map);\n/** @internal */\nexport const sequentialCollectionKeys = self => Array.from(HashMap.keys(self.map));\n/** @internal */\nexport const sequentialCollectionToChunk = self => Array.from(self.map);\n//# sourceMappingURL=blockedRequests.js.map","/** @internal */\nexport const OP_STATE_PENDING = \"Pending\";\n/** @internal */\nexport const OP_STATE_DONE = \"Done\";\n//# sourceMappingURL=deferred.js.map","import * as OpCodes from \"./opCodes/deferred.js\";\n/** @internal */\nconst DeferredSymbolKey = \"effect/Deferred\";\n/** @internal */\nexport const DeferredTypeId = /*#__PURE__*/Symbol.for(DeferredSymbolKey);\n/** @internal */\nexport const deferredVariance = {\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _A: _ => _\n};\n/** @internal */\nexport const pending = joiners => {\n  return {\n    _tag: OpCodes.OP_STATE_PENDING,\n    joiners\n  };\n};\n/** @internal */\nexport const done = effect => {\n  return {\n    _tag: OpCodes.OP_STATE_DONE,\n    effect\n  };\n};\n//# sourceMappingURL=deferred.js.map","/** @internal */\nexport class SingleShotGen {\n  self;\n  called = false;\n  constructor(self) {\n    this.self = self;\n  }\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  throw(e) {\n    throw e;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n//# sourceMappingURL=singleShotGen.js.map","/**\n * @since 2.0.0\n */\nimport * as Context from \"../Context.js\";\n/** @internal */\nexport const TracerTypeId = /*#__PURE__*/Symbol.for(\"effect/Tracer\");\n/** @internal */\nexport const make = options => ({\n  [TracerTypeId]: TracerTypeId,\n  ...options\n});\n/** @internal */\nexport const tracerTag = /*#__PURE__*/Context.GenericTag(\"effect/Tracer\");\n/** @internal */\nexport const spanTag = /*#__PURE__*/Context.GenericTag(\"effect/ParentSpan\");\nconst randomHexString = /*#__PURE__*/function () {\n  const characters = \"abcdef0123456789\";\n  const charactersLength = characters.length;\n  return function (length) {\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n      result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return result;\n  };\n}();\n/** @internal */\nexport class NativeSpan {\n  name;\n  parent;\n  context;\n  links;\n  startTime;\n  kind;\n  _tag = \"Span\";\n  spanId;\n  traceId = \"native\";\n  sampled = true;\n  status;\n  attributes;\n  events = [];\n  constructor(name, parent, context, links, startTime, kind) {\n    this.name = name;\n    this.parent = parent;\n    this.context = context;\n    this.links = links;\n    this.startTime = startTime;\n    this.kind = kind;\n    this.status = {\n      _tag: \"Started\",\n      startTime\n    };\n    this.attributes = new Map();\n    this.traceId = parent._tag === \"Some\" ? parent.value.traceId : randomHexString(32);\n    this.spanId = randomHexString(16);\n  }\n  end(endTime, exit) {\n    this.status = {\n      _tag: \"Ended\",\n      endTime,\n      exit,\n      startTime: this.status.startTime\n    };\n  }\n  attribute(key, value) {\n    this.attributes.set(key, value);\n  }\n  event(name, startTime, attributes) {\n    this.events.push([name, startTime, attributes ?? {}]);\n  }\n}\n/** @internal */\nexport const nativeTracer = /*#__PURE__*/make({\n  span: (name, parent, context, links, startTime, kind) => new NativeSpan(name, parent, context, links, startTime, kind),\n  context: f => f()\n});\n/** @internal */\nexport const externalSpan = options => ({\n  _tag: \"ExternalSpan\",\n  spanId: options.spanId,\n  traceId: options.traceId,\n  sampled: options.sampled ?? true,\n  context: options.context ?? Context.empty()\n});\n/** @internal */\nexport const addSpanStackTrace = options => {\n  if (options?.captureStackTrace === false) {\n    return options;\n  } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== \"boolean\") {\n    return options;\n  }\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 3;\n  const traceError = new Error();\n  Error.stackTraceLimit = limit;\n  let cache = false;\n  return {\n    ...options,\n    captureStackTrace: () => {\n      if (cache !== false) {\n        return cache;\n      }\n      if (traceError.stack !== undefined) {\n        const stack = traceError.stack.split(\"\\n\");\n        if (stack[3] !== undefined) {\n          cache = stack[3].trim();\n          return cache;\n        }\n      }\n    }\n  };\n};\n//# sourceMappingURL=tracer.js.map","import { internalCall } from \"effect/Utils\";\nimport * as Arr from \"../Array.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Context from \"../Context.js\";\nimport * as Either from \"../Either.js\";\nimport * as Equal from \"../Equal.js\";\nimport * as FiberId from \"../FiberId.js\";\nimport { dual, identity, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport * as List from \"../List.js\";\nimport * as MutableRef from \"../MutableRef.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty, isObject, isPromiseLike, isString } from \"../Predicate.js\";\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\";\nimport { YieldWrap } from \"../Utils.js\";\nimport * as _blockedRequests from \"./blockedRequests.js\";\nimport * as internalCause from \"./cause.js\";\nimport * as deferred from \"./deferred.js\";\nimport * as internalDiffer from \"./differ.js\";\nimport { effectVariance, StructuralCommitPrototype } from \"./effectable.js\";\nimport { getBugErrorMessage } from \"./errors.js\";\nimport * as DeferredOpCodes from \"./opCodes/deferred.js\";\nimport * as OpCodes from \"./opCodes/effect.js\";\nimport * as _runtimeFlags from \"./runtimeFlags.js\";\nimport { SingleShotGen } from \"./singleShotGen.js\";\nimport * as internalTracer from \"./tracer.js\";\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n/** @internal */\nconst EffectErrorSymbolKey = \"effect/EffectError\";\n/** @internal */\nexport const EffectErrorTypeId = /*#__PURE__*/Symbol.for(EffectErrorSymbolKey);\n/** @internal */\nexport const isEffectError = u => hasProperty(u, EffectErrorTypeId);\n/** @internal */\nexport const makeEffectError = cause => ({\n  [EffectErrorTypeId]: EffectErrorTypeId,\n  _tag: \"EffectError\",\n  cause\n});\n/**\n * @internal\n */\nexport const blocked = (blockedRequests, _continue) => {\n  const effect = new EffectPrimitive(\"Blocked\");\n  effect.effect_instruction_i0 = blockedRequests;\n  effect.effect_instruction_i1 = _continue;\n  return effect;\n};\n/**\n * @internal\n */\nexport const runRequestBlock = blockedRequests => {\n  const effect = new EffectPrimitive(\"RunBlocked\");\n  effect.effect_instruction_i0 = blockedRequests;\n  return effect;\n};\n/** @internal */\nexport const EffectTypeId = /*#__PURE__*/Symbol.for(\"effect/Effect\");\n/** @internal */\nexport class RevertFlags {\n  patch;\n  op;\n  _op = OpCodes.OP_REVERT_FLAGS;\n  constructor(patch, op) {\n    this.patch = patch;\n    this.op = op;\n  }\n}\nclass EffectPrimitive {\n  _op;\n  effect_instruction_i0 = undefined;\n  effect_instruction_i1 = undefined;\n  effect_instruction_i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n  }\n  [Equal.symbol](that) {\n    return this === that;\n  }\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.random(this));\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Effect\",\n      _op: this._op,\n      effect_instruction_i0: toJSON(this.effect_instruction_i0),\n      effect_instruction_i1: toJSON(this.effect_instruction_i1),\n      effect_instruction_i2: toJSON(this.effect_instruction_i2)\n    };\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this));\n  }\n}\n/** @internal */\nclass EffectPrimitiveFailure {\n  _op;\n  effect_instruction_i0 = undefined;\n  effect_instruction_i1 = undefined;\n  effect_instruction_i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n    // @ts-expect-error\n    this._tag = _op;\n  }\n  [Equal.symbol](that) {\n    return exitIsExit(that) && that._op === \"Failure\" &&\n    // @ts-expect-error\n    Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0);\n  }\n  [Hash.symbol]() {\n    return pipe(\n    // @ts-expect-error\n    Hash.string(this._tag),\n    // @ts-expect-error\n    Hash.combine(Hash.hash(this.effect_instruction_i0)), Hash.cached(this));\n  }\n  get cause() {\n    return this.effect_instruction_i0;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      cause: this.cause.toJSON()\n    };\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this));\n  }\n}\n/** @internal */\nclass EffectPrimitiveSuccess {\n  _op;\n  effect_instruction_i0 = undefined;\n  effect_instruction_i1 = undefined;\n  effect_instruction_i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n    // @ts-expect-error\n    this._tag = _op;\n  }\n  [Equal.symbol](that) {\n    return exitIsExit(that) && that._op === \"Success\" &&\n    // @ts-expect-error\n    Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0);\n  }\n  [Hash.symbol]() {\n    return pipe(\n    // @ts-expect-error\n    Hash.string(this._tag),\n    // @ts-expect-error\n    Hash.combine(Hash.hash(this.effect_instruction_i0)), Hash.cached(this));\n  }\n  get value() {\n    return this.effect_instruction_i0;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      value: toJSON(this.value)\n    };\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this));\n  }\n}\n/** @internal */\nexport const isEffect = u => hasProperty(u, EffectTypeId);\n/* @internal */\nexport const withFiberRuntime = withRuntime => {\n  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME);\n  effect.effect_instruction_i0 = withRuntime;\n  return effect;\n};\n/* @internal */\nexport const acquireUseRelease = /*#__PURE__*/dual(3, (acquire, use, release) => uninterruptibleMask(restore => flatMap(acquire, a => flatMap(exit(suspend(() => restore(use(a)))), exit => {\n  return suspend(() => release(a, exit)).pipe(matchCauseEffect({\n    onFailure: cause => {\n      switch (exit._tag) {\n        case OpCodes.OP_FAILURE:\n          return failCause(internalCause.parallel(exit.effect_instruction_i0, cause));\n        case OpCodes.OP_SUCCESS:\n          return failCause(cause);\n      }\n    },\n    onSuccess: () => exit\n  }));\n}))));\n/* @internal */\nexport const as = /*#__PURE__*/dual(2, (self, value) => flatMap(self, () => succeed(value)));\n/* @internal */\nexport const asVoid = self => as(self, void 0);\n/* @internal */\nexport const custom = function () {\n  const wrapper = new EffectPrimitive(OpCodes.OP_COMMIT);\n  switch (arguments.length) {\n    case 2:\n      {\n        wrapper.effect_instruction_i0 = arguments[0];\n        wrapper.commit = arguments[1];\n        break;\n      }\n    case 3:\n      {\n        wrapper.effect_instruction_i0 = arguments[0];\n        wrapper.effect_instruction_i1 = arguments[1];\n        wrapper.commit = arguments[2];\n        break;\n      }\n    case 4:\n      {\n        wrapper.effect_instruction_i0 = arguments[0];\n        wrapper.effect_instruction_i1 = arguments[1];\n        wrapper.effect_instruction_i2 = arguments[2];\n        wrapper.commit = arguments[3];\n        break;\n      }\n    default:\n      {\n        throw new Error(getBugErrorMessage(\"you're not supposed to end up here\"));\n      }\n  }\n  return wrapper;\n};\n/* @internal */\nexport const unsafeAsync = (register, blockingOn = FiberId.none) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ASYNC);\n  let cancelerRef = undefined;\n  effect.effect_instruction_i0 = resume => {\n    cancelerRef = register(resume);\n  };\n  effect.effect_instruction_i1 = blockingOn;\n  return cancelerRef !== undefined ? onInterrupt(effect, _ => cancelerRef) : effect;\n};\n/* @internal */\nexport const async = (register, blockingOn = FiberId.none) => {\n  return custom(register, function () {\n    let backingResume = undefined;\n    let pendingEffect = undefined;\n    function proxyResume(effect) {\n      if (backingResume) {\n        backingResume(effect);\n      } else if (pendingEffect === undefined) {\n        pendingEffect = effect;\n      }\n    }\n    const effect = new EffectPrimitive(OpCodes.OP_ASYNC);\n    effect.effect_instruction_i0 = resume => {\n      backingResume = resume;\n      if (pendingEffect) {\n        resume(pendingEffect);\n      }\n    };\n    effect.effect_instruction_i1 = blockingOn;\n    let cancelerRef = undefined;\n    let controllerRef = undefined;\n    if (this.effect_instruction_i0.length !== 1) {\n      controllerRef = new AbortController();\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));\n    } else {\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));\n    }\n    return cancelerRef || controllerRef ? onInterrupt(effect, _ => {\n      if (controllerRef) {\n        controllerRef.abort();\n      }\n      return cancelerRef ?? void_;\n    }) : effect;\n  });\n};\n/* @internal */\nexport const catchAllCause = /*#__PURE__*/dual(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_FAILURE);\n  effect.effect_instruction_i0 = self;\n  effect.effect_instruction_i1 = f;\n  return effect;\n});\n/* @internal */\nexport const catchAll = /*#__PURE__*/dual(2, (self, f) => matchEffect(self, {\n  onFailure: f,\n  onSuccess: succeed\n}));\n/* @internal */\nexport const catchIf = /*#__PURE__*/dual(3, (self, predicate, f) => catchAllCause(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      return predicate(either.left) ? f(either.left) : failCause(cause);\n    case \"Right\":\n      return failCause(either.right);\n  }\n}));\n/* @internal */\nexport const catchSome = /*#__PURE__*/dual(2, (self, pf) => catchAllCause(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      return pipe(pf(either.left), Option.getOrElse(() => failCause(cause)));\n    case \"Right\":\n      return failCause(either.right);\n  }\n}));\n/* @internal */\nexport const checkInterruptible = f => withFiberRuntime((_, status) => f(_runtimeFlags.interruption(status.runtimeFlags)));\nconst spanSymbol = /*#__PURE__*/Symbol.for(\"effect/SpanAnnotation\");\nconst originalSymbol = /*#__PURE__*/Symbol.for(\"effect/OriginalAnnotation\");\n/* @internal */\nexport const originalInstance = obj => {\n  if (hasProperty(obj, originalSymbol)) {\n    // @ts-expect-error\n    return obj[originalSymbol];\n  }\n  return obj;\n};\n/* @internal */\nconst capture = (obj, span) => {\n  if (Option.isSome(span)) {\n    return new Proxy(obj, {\n      has(target, p) {\n        return p === spanSymbol || p === originalSymbol || p in target;\n      },\n      get(target, p) {\n        if (p === spanSymbol) {\n          return span.value;\n        }\n        if (p === originalSymbol) {\n          return obj;\n        }\n        // @ts-expect-error\n        return target[p];\n      }\n    });\n  }\n  return obj;\n};\n/* @internal */\nexport const die = defect => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime(fiber => failCause(internalCause.die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(internalCause.die(defect));\n/* @internal */\nexport const dieMessage = message => failCauseSync(() => internalCause.die(new RuntimeException(message)));\n/* @internal */\nexport const dieSync = evaluate => flatMap(sync(evaluate), die);\n/* @internal */\nexport const either = self => matchEffect(self, {\n  onFailure: e => succeed(Either.left(e)),\n  onSuccess: a => succeed(Either.right(a))\n});\n/* @internal */\nexport const exit = self => matchCause(self, {\n  onFailure: exitFailCause,\n  onSuccess: exitSucceed\n});\n/* @internal */\nexport const fail = error => isObject(error) && !(spanSymbol in error) ? withFiberRuntime(fiber => failCause(internalCause.fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(internalCause.fail(error));\n/* @internal */\nexport const failSync = evaluate => flatMap(sync(evaluate), fail);\n/* @internal */\nexport const failCause = cause => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE);\n  effect.effect_instruction_i0 = cause;\n  return effect;\n};\n/* @internal */\nexport const failCauseSync = evaluate => flatMap(sync(evaluate), failCause);\n/* @internal */\nexport const fiberId = /*#__PURE__*/withFiberRuntime(state => succeed(state.id()));\n/* @internal */\nexport const fiberIdWith = f => withFiberRuntime(state => f(state.id()));\n/* @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS);\n  effect.effect_instruction_i0 = self;\n  effect.effect_instruction_i1 = f;\n  return effect;\n});\n/* @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => {\n  const b = typeof f === \"function\" ? f(a) : f;\n  if (isEffect(b)) {\n    return b;\n  } else if (isPromiseLike(b)) {\n    return async(resume => {\n      b.then(a => resume(succeed(a)), e => resume(fail(new UnknownException(e))));\n    });\n  }\n  return succeed(b);\n}));\n/* @internal */\nexport const step = self => {\n  const effect = new EffectPrimitive(\"OnStep\");\n  effect.effect_instruction_i0 = self;\n  return effect;\n};\n/* @internal */\nexport const flatten = self => flatMap(self, identity);\n/* @internal */\nexport const flip = self => matchEffect(self, {\n  onFailure: succeed,\n  onSuccess: fail\n});\n/* @internal */\nexport const matchCause = /*#__PURE__*/dual(2, (self, options) => matchCauseEffect(self, {\n  onFailure: cause => succeed(options.onFailure(cause)),\n  onSuccess: a => succeed(options.onSuccess(a))\n}));\n/* @internal */\nexport const matchCauseEffect = /*#__PURE__*/dual(2, (self, options) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS_AND_FAILURE);\n  effect.effect_instruction_i0 = self;\n  effect.effect_instruction_i1 = options.onFailure;\n  effect.effect_instruction_i2 = options.onSuccess;\n  return effect;\n});\n/* @internal */\nexport const matchEffect = /*#__PURE__*/dual(2, (self, options) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const defects = internalCause.defects(cause);\n    if (defects.length > 0) {\n      return failCause(internalCause.electFailures(cause));\n    }\n    const failures = internalCause.failures(cause);\n    if (failures.length > 0) {\n      return options.onFailure(Chunk.unsafeHead(failures));\n    }\n    return failCause(cause);\n  },\n  onSuccess: options.onSuccess\n}));\n/* @internal */\nexport const forEachSequential = /*#__PURE__*/dual(2, (self, f) => suspend(() => {\n  const arr = Arr.fromIterable(self);\n  const ret = Arr.allocate(arr.length);\n  let i = 0;\n  return as(whileLoop({\n    while: () => i < arr.length,\n    body: () => f(arr[i], i),\n    step: b => {\n      ret[i++] = b;\n    }\n  }), ret);\n}));\n/* @internal */\nexport const forEachSequentialDiscard = /*#__PURE__*/dual(2, (self, f) => suspend(() => {\n  const arr = Arr.fromIterable(self);\n  let i = 0;\n  return whileLoop({\n    while: () => i < arr.length,\n    body: () => f(arr[i], i),\n    step: () => {\n      i++;\n    }\n  });\n}));\n/* @internal */\nexport const if_ = /*#__PURE__*/dual(args => typeof args[0] === \"boolean\" || isEffect(args[0]), (self, options) => isEffect(self) ? flatMap(self, b => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());\n/* @internal */\nexport const interrupt = /*#__PURE__*/flatMap(fiberId, fiberId => interruptWith(fiberId));\n/* @internal */\nexport const interruptWith = fiberId => failCause(internalCause.interrupt(fiberId));\n/* @internal */\nexport const interruptible = self => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption);\n  effect.effect_instruction_i1 = () => self;\n  return effect;\n};\n/* @internal */\nexport const interruptibleMask = f => custom(f, function () {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption);\n  effect.effect_instruction_i1 = oldFlags => _runtimeFlags.interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible)) : internalCall(() => this.effect_instruction_i0(uninterruptible));\n  return effect;\n});\n/* @internal */\nexport const intoDeferred = /*#__PURE__*/dual(2, (self, deferred) => uninterruptibleMask(restore => flatMap(exit(restore(self)), exit => deferredDone(deferred, exit))));\n/* @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => sync(() => f(a))));\n/* @internal */\nexport const mapBoth = /*#__PURE__*/dual(2, (self, options) => matchEffect(self, {\n  onFailure: e => failSync(() => options.onFailure(e)),\n  onSuccess: a => sync(() => options.onSuccess(a))\n}));\n/* @internal */\nexport const mapError = /*#__PURE__*/dual(2, (self, f) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const either = internalCause.failureOrCause(cause);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          return failSync(() => f(either.left));\n        }\n      case \"Right\":\n        {\n          return failCause(either.right);\n        }\n    }\n  },\n  onSuccess: succeed\n}));\n/* @internal */\nexport const onError = /*#__PURE__*/dual(2, (self, cleanup) => onExit(self, exit => exitIsSuccess(exit) ? void_ : cleanup(exit.effect_instruction_i0)));\n/* @internal */\nexport const onExit = /*#__PURE__*/dual(2, (self, cleanup) => uninterruptibleMask(restore => matchCauseEffect(restore(self), {\n  onFailure: cause1 => {\n    const result = exitFailCause(cause1);\n    return matchCauseEffect(cleanup(result), {\n      onFailure: cause2 => exitFailCause(internalCause.sequential(cause1, cause2)),\n      onSuccess: () => result\n    });\n  },\n  onSuccess: success => {\n    const result = exitSucceed(success);\n    return zipRight(cleanup(result), result);\n  }\n})));\n/* @internal */\nexport const onInterrupt = /*#__PURE__*/dual(2, (self, cleanup) => onExit(self, exitMatch({\n  onFailure: cause => internalCause.isInterruptedOnly(cause) ? asVoid(cleanup(internalCause.interruptors(cause))) : void_,\n  onSuccess: () => void_\n})));\n/* @internal */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => attemptOrElse(self, that, succeed));\n/* @internal */\nexport const orDie = self => orDieWith(self, identity);\n/* @internal */\nexport const orDieWith = /*#__PURE__*/dual(2, (self, f) => matchEffect(self, {\n  onFailure: e => die(f(e)),\n  onSuccess: succeed\n}));\n/* @internal */\nexport const partitionMap = (elements, f) => Arr.fromIterable(elements).reduceRight(([lefts, rights], current) => {\n  const either = f(current);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return [[either.left, ...lefts], rights];\n      }\n    case \"Right\":\n      {\n        return [lefts, [either.right, ...rights]];\n      }\n  }\n}, [Arr.empty(), Arr.empty()]);\n/* @internal */\nexport const runtimeFlags = /*#__PURE__*/withFiberRuntime((_, status) => succeed(status.runtimeFlags));\n/* @internal */\nexport const succeed = value => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS);\n  effect.effect_instruction_i0 = value;\n  return effect;\n};\n/* @internal */\nexport const suspend = effect => flatMap(sync(effect), identity);\n/* @internal */\nexport const sync = evaluate => {\n  const effect = new EffectPrimitive(OpCodes.OP_SYNC);\n  effect.effect_instruction_i0 = evaluate;\n  return effect;\n};\n/* @internal */\nexport const tap = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => {\n  const b = typeof f === \"function\" ? f(a) : f;\n  if (isEffect(b)) {\n    return as(b, a);\n  } else if (isPromiseLike(b)) {\n    return async(resume => {\n      b.then(_ => resume(succeed(a)), e => resume(fail(new UnknownException(e))));\n    });\n  }\n  return succeed(a);\n}));\n/* @internal */\nexport const transplant = f => withFiberRuntime(state => {\n  const scopeOverride = state.getFiberRef(currentForkScopeOverride);\n  const scope = pipe(scopeOverride, Option.getOrElse(() => state.scope()));\n  return f(fiberRefLocally(currentForkScopeOverride, Option.some(scope)));\n});\n/* @internal */\nexport const attemptOrElse = /*#__PURE__*/dual(3, (self, that, onSuccess) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const defects = internalCause.defects(cause);\n    if (defects.length > 0) {\n      return failCause(Option.getOrThrow(internalCause.keepDefectsAndElectFailures(cause)));\n    }\n    return that();\n  },\n  onSuccess\n}));\n/* @internal */\nexport const uninterruptible = self => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption);\n  effect.effect_instruction_i1 = () => self;\n  return effect;\n};\n/* @internal */\nexport const uninterruptibleMask = f => custom(f, function () {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption);\n  effect.effect_instruction_i1 = oldFlags => _runtimeFlags.interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible)) : internalCall(() => this.effect_instruction_i0(uninterruptible));\n  return effect;\n});\nconst void_ = /*#__PURE__*/succeed(void 0);\nexport { /* @internal */\nvoid_ as void };\n/* @internal */\nexport const updateRuntimeFlags = patch => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = patch;\n  effect.effect_instruction_i1 = void 0;\n  return effect;\n};\n/* @internal */\nexport const whenEffect = /*#__PURE__*/dual(2, (self, condition) => flatMap(condition, b => {\n  if (b) {\n    return pipe(self, map(Option.some));\n  }\n  return succeed(Option.none());\n}));\n/* @internal */\nexport const whileLoop = options => {\n  const effect = new EffectPrimitive(OpCodes.OP_WHILE);\n  effect.effect_instruction_i0 = options.while;\n  effect.effect_instruction_i1 = options.body;\n  effect.effect_instruction_i2 = options.step;\n  return effect;\n};\n/* @internal */\nexport const withConcurrency = /*#__PURE__*/dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));\n/* @internal */\nexport const withRequestBatching = /*#__PURE__*/dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));\n/* @internal */\nexport const withRuntimeFlags = /*#__PURE__*/dual(2, (self, update) => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = update;\n  effect.effect_instruction_i1 = () => self;\n  return effect;\n});\n/** @internal */\nexport const withTracerEnabled = /*#__PURE__*/dual(2, (effect, enabled) => fiberRefLocally(effect, currentTracerEnabled, enabled));\n/** @internal */\nexport const withTracerTiming = /*#__PURE__*/dual(2, (effect, enabled) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled));\n/* @internal */\nexport const yieldNow = options => {\n  const effect = new EffectPrimitive(OpCodes.OP_YIELD);\n  return typeof options?.priority !== \"undefined\" ? withSchedulingPriority(effect, options.priority) : effect;\n};\n/* @internal */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => flatMap(self, a => map(that, b => [a, b])));\n/* @internal */\nexport const zipFlatten = /*#__PURE__*/dual(2, (self, that) => flatMap(self, a => map(that, b => [...a, b])));\n/* @internal */\nexport const zipLeft = /*#__PURE__*/dual(2, (self, that) => flatMap(self, a => as(that, a)));\n/* @internal */\nexport const zipRight = /*#__PURE__*/dual(2, (self, that) => flatMap(self, () => that));\n/* @internal */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => flatMap(self, a => map(that, b => f(a, b))));\n/* @internal */\nexport const never = /*#__PURE__*/async(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1);\n  return sync(() => clearInterval(interval));\n});\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n/* @internal */\nexport const interruptFiber = self => flatMap(fiberId, fiberId => pipe(self, interruptAsFiber(fiberId)));\n/* @internal */\nexport const interruptAsFiber = /*#__PURE__*/dual(2, (self, fiberId) => flatMap(self.interruptAsFork(fiberId), () => self.await));\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const logLevelAll = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelFatal = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelError = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelWarning = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelInfo = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelDebug = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelTrace = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelNone = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n/** @internal */\nconst FiberRefSymbolKey = \"effect/FiberRef\";\n/** @internal */\nexport const FiberRefTypeId = /*#__PURE__*/Symbol.for(FiberRefSymbolKey);\nconst fiberRefVariance = {\n  /* c8 ignore next */\n  _A: _ => _\n};\n/* @internal */\nexport const fiberRefGet = self => fiberRefModify(self, a => [a, a]);\n/* @internal */\nexport const fiberRefGetAndSet = /*#__PURE__*/dual(2, (self, value) => fiberRefModify(self, v => [v, value]));\n/* @internal */\nexport const fiberRefGetAndUpdate = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => [v, f(v)]));\n/* @internal */\nexport const fiberRefGetAndUpdateSome = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => [v, Option.getOrElse(pf(v), () => v)]));\n/* @internal */\nexport const fiberRefGetWith = /*#__PURE__*/dual(2, (self, f) => flatMap(fiberRefGet(self), f));\n/* @internal */\nexport const fiberRefSet = /*#__PURE__*/dual(2, (self, value) => fiberRefModify(self, () => [void 0, value]));\n/* @internal */\nexport const fiberRefDelete = self => withFiberRuntime(state => {\n  state.unsafeDeleteFiberRef(self);\n  return void_;\n});\n/* @internal */\nexport const fiberRefReset = self => fiberRefSet(self, self.initial);\n/* @internal */\nexport const fiberRefModify = /*#__PURE__*/dual(2, (self, f) => withFiberRuntime(state => {\n  const [b, a] = f(state.getFiberRef(self));\n  state.setFiberRef(self, a);\n  return succeed(b);\n}));\n/* @internal */\nexport const fiberRefModifySome = (self, def, f) => fiberRefModify(self, v => Option.getOrElse(f(v), () => [def, v]));\n/* @internal */\nexport const fiberRefUpdate = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => [void 0, f(v)]));\n/* @internal */\nexport const fiberRefUpdateSome = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => [void 0, Option.getOrElse(pf(v), () => v)]));\n/* @internal */\nexport const fiberRefUpdateAndGet = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => {\n  const result = f(v);\n  return [result, result];\n}));\n/* @internal */\nexport const fiberRefUpdateSomeAndGet = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => {\n  const result = Option.getOrElse(pf(v), () => v);\n  return [result, result];\n}));\n// circular\n/** @internal */\nconst RequestResolverSymbolKey = \"effect/RequestResolver\";\n/** @internal */\nexport const RequestResolverTypeId = /*#__PURE__*/Symbol.for(RequestResolverSymbolKey);\nconst requestResolverVariance = {\n  /* c8 ignore next */\n  _A: _ => _,\n  /* c8 ignore next */\n  _R: _ => _\n};\n/** @internal */\nexport class RequestResolverImpl {\n  runAll;\n  target;\n  [RequestResolverTypeId] = requestResolverVariance;\n  constructor(runAll, target) {\n    this.runAll = runAll;\n    this.target = target;\n  }\n  [Hash.symbol]() {\n    return Hash.cached(this, this.target ? Hash.hash(this.target) : Hash.random(this));\n  }\n  [Equal.symbol](that) {\n    return this.target ? isRequestResolver(that) && Equal.equals(this.target, that.target) : this === that;\n  }\n  identified(...ids) {\n    return new RequestResolverImpl(this.runAll, Chunk.fromIterable(ids));\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n/** @internal */\nexport const isRequestResolver = u => hasProperty(u, RequestResolverTypeId);\n// end\n/** @internal */\nexport const resolverLocally = /*#__PURE__*/dual(3, (use, self, value) => new RequestResolverImpl(requests => fiberRefLocally(use.runAll(requests), self, value), Chunk.make(\"Locally\", use, self, value)));\n/** @internal */\nexport const requestBlockLocally = (self, ref, value) => _blockedRequests.reduce(self, LocallyReducer(ref, value));\nconst LocallyReducer = (ref, value) => ({\n  emptyCase: () => _blockedRequests.empty,\n  parCase: (left, right) => _blockedRequests.par(left, right),\n  seqCase: (left, right) => _blockedRequests.seq(left, right),\n  singleCase: (dataSource, blockedRequest) => _blockedRequests.single(resolverLocally(dataSource, ref, value), blockedRequest)\n});\n/* @internal */\nexport const fiberRefLocally = /*#__PURE__*/dual(3, (use, self, value) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, oldValue => fiberRefSet(self, oldValue)));\n/* @internal */\nexport const fiberRefLocallyWith = /*#__PURE__*/dual(3, (use, self, f) => fiberRefGetWith(self, a => fiberRefLocally(use, self, f(a))));\n/** @internal */\nexport const fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {\n  differ: internalDiffer.update(),\n  fork: options?.fork ?? identity,\n  join: options?.join\n});\n/** @internal */\nexport const fiberRefUnsafeMakeHashSet = initial => {\n  const differ = internalDiffer.hashSet();\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  });\n};\n/** @internal */\nexport const fiberRefUnsafeMakeReadonlyArray = initial => {\n  const differ = internalDiffer.readonlyArray(internalDiffer.update());\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  });\n};\n/** @internal */\nexport const fiberRefUnsafeMakeContext = initial => {\n  const differ = internalDiffer.environment();\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  });\n};\n/** @internal */\nexport const fiberRefUnsafeMakePatch = (initial, options) => ({\n  [FiberRefTypeId]: fiberRefVariance,\n  initial,\n  diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),\n  combine: (first, second) => options.differ.combine(first, second),\n  patch: patch => oldValue => options.differ.patch(patch, oldValue),\n  fork: options.fork,\n  join: options.join ?? ((_, n) => n),\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n/** @internal */\nexport const fiberRefUnsafeMakeRuntimeFlags = initial => fiberRefUnsafeMakePatch(initial, {\n  differ: _runtimeFlags.differ,\n  fork: _runtimeFlags.differ.empty\n});\n/** @internal */\nexport const currentContext = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentContext\"), () => fiberRefUnsafeMakeContext(Context.empty()));\n/** @internal */\nexport const currentSchedulingPriority = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"), () => fiberRefUnsafeMake(0));\n/** @internal */\nexport const currentMaxOpsBeforeYield = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"), () => fiberRefUnsafeMake(2048));\n/** @internal */\nexport const currentLogAnnotations = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogAnnotation\"), () => fiberRefUnsafeMake(HashMap.empty()));\n/** @internal */\nexport const currentLogLevel = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogLevel\"), () => fiberRefUnsafeMake(logLevelInfo));\n/** @internal */\nexport const currentLogSpan = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogSpan\"), () => fiberRefUnsafeMake(List.empty()));\n/** @internal */\nexport const withSchedulingPriority = /*#__PURE__*/dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));\n/** @internal */\nexport const withMaxOpsBeforeYield = /*#__PURE__*/dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));\n/** @internal */\nexport const currentConcurrency = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentConcurrency\"), () => fiberRefUnsafeMake(\"unbounded\"));\n/**\n * @internal\n */\nexport const currentRequestBatching = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentRequestBatching\"), () => fiberRefUnsafeMake(true));\n/** @internal */\nexport const currentUnhandledErrorLogLevel = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"), () => fiberRefUnsafeMake(Option.some(logLevelDebug)));\n/** @internal */\nexport const withUnhandledErrorLogLevel = /*#__PURE__*/dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));\n/** @internal */\nexport const currentMetricLabels = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentMetricLabels\"), () => fiberRefUnsafeMakeReadonlyArray(Arr.empty()));\n/* @internal */\nexport const metricLabels = /*#__PURE__*/fiberRefGet(currentMetricLabels);\n/** @internal */\nexport const currentForkScopeOverride = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"), () => fiberRefUnsafeMake(Option.none(), {\n  fork: () => Option.none(),\n  join: (parent, _) => parent\n}));\n/** @internal */\nexport const currentInterruptedCause = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentInterruptedCause\"), () => fiberRefUnsafeMake(internalCause.empty, {\n  fork: () => internalCause.empty,\n  join: (parent, _) => parent\n}));\n/** @internal */\nexport const currentTracerEnabled = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerEnabled\"), () => fiberRefUnsafeMake(true));\n/** @internal */\nexport const currentTracerTimingEnabled = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerTiming\"), () => fiberRefUnsafeMake(true));\n/** @internal */\nexport const currentTracerSpanAnnotations = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerSpanAnnotations\"), () => fiberRefUnsafeMake(HashMap.empty()));\n/** @internal */\nexport const currentTracerSpanLinks = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerSpanLinks\"), () => fiberRefUnsafeMake(Chunk.empty()));\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const ScopeTypeId = /*#__PURE__*/Symbol.for(\"effect/Scope\");\n/** @internal */\nexport const CloseableScopeTypeId = /*#__PURE__*/Symbol.for(\"effect/CloseableScope\");\n/* @internal */\nexport const scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid(finalizer));\n/* @internal */\nexport const scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);\n/* @internal */\nexport const scopeClose = (self, exit) => self.close(exit);\n/* @internal */\nexport const scopeFork = (self, strategy) => self.fork(strategy);\n// -----------------------------------------------------------------------------\n// Cause\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const causeSquash = self => {\n  return causeSquashWith(identity)(self);\n};\n/** @internal */\nexport const causeSquashWith = /*#__PURE__*/dual(2, (self, f) => {\n  const option = pipe(self, internalCause.failureOption, Option.map(f));\n  switch (option._tag) {\n    case \"None\":\n      {\n        return pipe(internalCause.defects(self), Chunk.head, Option.match({\n          onNone: () => {\n            const interrupts = Arr.fromIterable(internalCause.interruptors(self)).flatMap(fiberId => Arr.fromIterable(FiberId.ids(fiberId)).map(id => `#${id}`));\n            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0);\n          },\n          onSome: identity\n        }));\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n});\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const YieldableError = /*#__PURE__*/function () {\n  class YieldableError extends globalThis.Error {\n    commit() {\n      return fail(this);\n    }\n    toString() {\n      return this.message ? `${this.name}: ${this.message}` : this.name;\n    }\n    toJSON() {\n      return {\n        ...this\n      };\n    }\n    [NodeInspectSymbol]() {\n      const stack = this.stack;\n      if (stack) {\n        return `${this.toString()}\\n${stack.split(\"\\n\").slice(1).join(\"\\n\")}`;\n      }\n      return this.toString();\n    }\n  }\n  Object.assign(YieldableError.prototype, StructuralCommitPrototype);\n  return YieldableError;\n}();\nconst makeException = (proto, tag) => {\n  class Base extends YieldableError {\n    _tag = tag;\n  }\n  Object.assign(Base.prototype, proto);\n  Base.prototype.name = tag;\n  return Base;\n};\n/** @internal */\nexport const RuntimeExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/RuntimeException\");\n/** @internal */\nexport const RuntimeException = /*#__PURE__*/makeException({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\");\n/** @internal */\nexport const isRuntimeException = u => hasProperty(u, RuntimeExceptionTypeId);\n/** @internal */\nexport const InterruptedExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/InterruptedException\");\n/** @internal */\nexport const InterruptedException = /*#__PURE__*/makeException({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\");\n/** @internal */\nexport const isInterruptedException = u => hasProperty(u, InterruptedExceptionTypeId);\n/** @internal */\nexport const IllegalArgumentExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/IllegalArgument\");\n/** @internal */\nexport const IllegalArgumentException = /*#__PURE__*/makeException({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\");\n/** @internal */\nexport const isIllegalArgumentException = u => hasProperty(u, IllegalArgumentExceptionTypeId);\n/** @internal */\nexport const NoSuchElementExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/NoSuchElement\");\n/** @internal */\nexport const NoSuchElementException = /*#__PURE__*/makeException({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\");\n/** @internal */\nexport const isNoSuchElementException = u => hasProperty(u, NoSuchElementExceptionTypeId);\n/** @internal */\nexport const InvalidPubSubCapacityExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/InvalidPubSubCapacityException\");\n/** @internal */\nexport const InvalidPubSubCapacityException = /*#__PURE__*/makeException({\n  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}, \"InvalidPubSubCapacityException\");\n/** @internal */\nexport const isInvalidCapacityError = u => hasProperty(u, InvalidPubSubCapacityExceptionTypeId);\n/** @internal */\nexport const TimeoutExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/Timeout\");\n/** @internal */\nexport const TimeoutException = /*#__PURE__*/makeException({\n  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}, \"TimeoutException\");\n/** @internal */\nexport const isTimeoutException = u => hasProperty(u, TimeoutExceptionTypeId);\n/** @internal */\nexport const UnknownExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/UnknownException\");\n/** @internal */\nexport const UnknownException = /*#__PURE__*/function () {\n  class UnknownException extends YieldableError {\n    error;\n    _tag = \"UnknownException\";\n    constructor(error, message) {\n      super(message ?? (hasProperty(error, \"message\") && isString(error.message) ? error.message : void 0));\n      this.error = error;\n    }\n  }\n  Object.assign(UnknownException.prototype, {\n    [UnknownExceptionTypeId]: UnknownExceptionTypeId,\n    name: \"UnknownException\"\n  });\n  return UnknownException;\n}();\n/** @internal */\nexport const isUnknownException = u => hasProperty(u, UnknownExceptionTypeId);\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const exitIsExit = u => isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\");\n/** @internal */\nexport const exitIsFailure = self => self._tag === \"Failure\";\n/** @internal */\nexport const exitIsSuccess = self => self._tag === \"Success\";\n/** @internal */\nexport const exitIsInterrupted = self => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return internalCause.isInterrupted(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return false;\n  }\n};\n/** @internal */\nexport const exitAs = /*#__PURE__*/dual(2, (self, value) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(self.effect_instruction_i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exitSucceed(value);\n      }\n  }\n});\n/** @internal */\nexport const exitAsVoid = self => exitAs(self, void 0);\n/** @internal */\nexport const exitCauseOption = self => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return Option.some(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return Option.none();\n  }\n};\n/** @internal */\nexport const exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? internalCause.parallel : internalCause.sequential);\n/** @internal */\nexport const exitDie = defect => exitFailCause(internalCause.die(defect));\n/** @internal */\nexport const exitExists = /*#__PURE__*/dual(2, (self, refinement) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return false;\n    case OpCodes.OP_SUCCESS:\n      return refinement(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitFail = error => exitFailCause(internalCause.fail(error));\n/** @internal */\nexport const exitFailCause = cause => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE);\n  effect.effect_instruction_i0 = cause;\n  return effect;\n};\n/** @internal */\nexport const exitFlatMap = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(self.effect_instruction_i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return f(self.effect_instruction_i0);\n      }\n  }\n});\n/** @internal */\nexport const exitFlatMapEffect = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return succeed(exitFailCause(self.effect_instruction_i0));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return f(self.effect_instruction_i0);\n      }\n  }\n});\n/** @internal */\nexport const exitFlatten = self => pipe(self, exitFlatMap(identity));\n/** @internal */\nexport const exitForEachEffect = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return succeed(exitFailCause(self.effect_instruction_i0));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exit(f(self.effect_instruction_i0));\n      }\n  }\n});\n/** @internal */\nexport const exitFromEither = either => {\n  switch (either._tag) {\n    case \"Left\":\n      return exitFail(either.left);\n    case \"Right\":\n      return exitSucceed(either.right);\n  }\n};\n/** @internal */\nexport const exitFromOption = option => {\n  switch (option._tag) {\n    case \"None\":\n      return exitFail(void 0);\n    case \"Some\":\n      return exitSucceed(option.value);\n  }\n};\n/** @internal */\nexport const exitGetOrElse = /*#__PURE__*/dual(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return orElse(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return self.effect_instruction_i0;\n  }\n});\n/** @internal */\nexport const exitInterrupt = fiberId => exitFailCause(internalCause.interrupt(fiberId));\n/** @internal */\nexport const exitMap = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(f(self.effect_instruction_i0));\n  }\n});\n/** @internal */\nexport const exitMapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(onFailure)));\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(onSuccess(self.effect_instruction_i0));\n  }\n});\n/** @internal */\nexport const exitMapError = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(f)));\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitMapErrorCause = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(f(self.effect_instruction_i0));\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitMatch = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitMatchEffect = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitSucceed = value => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS);\n  effect.effect_instruction_i0 = value;\n  return effect;\n};\n/** @internal */\nexport const exitVoid = /*#__PURE__*/exitSucceed(void 0);\n/** @internal */\nexport const exitZip = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, a2) => [a, a2],\n  onFailure: internalCause.sequential\n}));\n/** @internal */\nexport const exitZipLeft = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, _) => a,\n  onFailure: internalCause.sequential\n}));\n/** @internal */\nexport const exitZipRight = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (_, a2) => a2,\n  onFailure: internalCause.sequential\n}));\n/** @internal */\nexport const exitZipPar = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, a2) => [a, a2],\n  onFailure: internalCause.parallel\n}));\n/** @internal */\nexport const exitZipParLeft = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, _) => a,\n  onFailure: internalCause.parallel\n}));\n/** @internal */\nexport const exitZipParRight = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (_, a2) => a2,\n  onFailure: internalCause.parallel\n}));\n/** @internal */\nexport const exitZipWith = /*#__PURE__*/dual(3, (self, that, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        switch (that._tag) {\n          case OpCodes.OP_SUCCESS:\n            return exitFailCause(self.effect_instruction_i0);\n          case OpCodes.OP_FAILURE:\n            {\n              return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));\n            }\n        }\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        switch (that._tag) {\n          case OpCodes.OP_SUCCESS:\n            return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));\n          case OpCodes.OP_FAILURE:\n            return exitFailCause(that.effect_instruction_i0);\n        }\n      }\n  }\n});\nconst exitCollectAllInternal = (exits, combineCauses) => {\n  const list = Chunk.fromIterable(exits);\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none();\n  }\n  return pipe(Chunk.tailNonEmpty(list), Arr.reduce(pipe(Chunk.headNonEmpty(list), exitMap(Chunk.of)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {\n    onSuccess: (list, value) => pipe(list, Chunk.prepend(value)),\n    onFailure: combineCauses\n  }))), exitMap(Chunk.reverse), exitMap(chunk => Chunk.toReadonlyArray(chunk)), Option.some);\n};\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const deferredUnsafeMake = fiberId => ({\n  [deferred.DeferredTypeId]: deferred.deferredVariance,\n  state: MutableRef.make(deferred.pending([])),\n  blockingOn: fiberId,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n/* @internal */\nexport const deferredMake = () => flatMap(fiberId, id => deferredMakeAs(id));\n/* @internal */\nexport const deferredMakeAs = fiberId => sync(() => deferredUnsafeMake(fiberId));\n/* @internal */\nexport const deferredAwait = self => async(resume => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return resume(state.effect);\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        // we can push here as the internal state is mutable\n        state.joiners.push(resume);\n        return deferredInterruptJoiner(self, resume);\n      }\n  }\n}, self.blockingOn);\n/* @internal */\nexport const deferredComplete = /*#__PURE__*/dual(2, (self, effect) => intoDeferred(effect, self));\n/* @internal */\nexport const deferredCompleteWith = /*#__PURE__*/dual(2, (self, effect) => sync(() => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return false;\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        MutableRef.set(self.state, deferred.done(effect));\n        for (let i = 0, len = state.joiners.length; i < len; i++) {\n          state.joiners[i](effect);\n        }\n        return true;\n      }\n  }\n}));\n/* @internal */\nexport const deferredDone = /*#__PURE__*/dual(2, (self, exit) => deferredCompleteWith(self, exit));\n/* @internal */\nexport const deferredFail = /*#__PURE__*/dual(2, (self, error) => deferredCompleteWith(self, fail(error)));\n/* @internal */\nexport const deferredFailSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)));\n/* @internal */\nexport const deferredFailCause = /*#__PURE__*/dual(2, (self, cause) => deferredCompleteWith(self, failCause(cause)));\n/* @internal */\nexport const deferredFailCauseSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)));\n/* @internal */\nexport const deferredDie = /*#__PURE__*/dual(2, (self, defect) => deferredCompleteWith(self, die(defect)));\n/* @internal */\nexport const deferredDieSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)));\n/* @internal */\nexport const deferredInterrupt = self => flatMap(fiberId, fiberId => deferredCompleteWith(self, interruptWith(fiberId)));\n/* @internal */\nexport const deferredInterruptWith = /*#__PURE__*/dual(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)));\n/* @internal */\nexport const deferredIsDone = self => sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE);\n/* @internal */\nexport const deferredPoll = self => sync(() => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return Option.some(state.effect);\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        return Option.none();\n      }\n  }\n});\n/* @internal */\nexport const deferredSucceed = /*#__PURE__*/dual(2, (self, value) => deferredCompleteWith(self, succeed(value)));\n/* @internal */\nexport const deferredSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)));\n/** @internal */\nexport const deferredUnsafeDone = (self, effect) => {\n  const state = MutableRef.get(self.state);\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(self.state, deferred.done(effect));\n    for (let i = 0, len = state.joiners.length; i < len; i++) {\n      state.joiners[i](effect);\n    }\n  }\n};\nconst deferredInterruptJoiner = (self, joiner) => sync(() => {\n  const state = MutableRef.get(self.state);\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    const index = state.joiners.indexOf(joiner);\n    if (index >= 0) {\n      // we can splice here as the internal state is mutable\n      state.joiners.splice(index, 1);\n    }\n  }\n});\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\nconst constContext = /*#__PURE__*/fiberRefGet(currentContext);\n/* @internal */\nexport const context = () => constContext;\n/* @internal */\nexport const contextWith = f => map(context(), f);\n/* @internal */\nexport const contextWithEffect = f => flatMap(context(), f);\n/* @internal */\nexport const provideContext = /*#__PURE__*/dual(2, (self, context) => fiberRefLocally(currentContext, context)(self));\n/* @internal */\nexport const provideSomeContext = /*#__PURE__*/dual(2, (self, context) => fiberRefLocallyWith(currentContext, parent => Context.merge(parent, context))(self));\n/* @internal */\nexport const mapInputContext = /*#__PURE__*/dual(2, (self, f) => contextWithEffect(context => provideContext(self, f(context))));\n// -----------------------------------------------------------------------------\n// Tracing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const currentSpanFromFiber = fiber => {\n  const span = fiber.getFiberRef(currentContext).unsafeMap.get(internalTracer.spanTag.key);\n  return span !== undefined && span._tag === \"Span\" ? Option.some(span) : Option.none();\n};\nconst NoopSpanProto = {\n  _tag: \"Span\",\n  spanId: \"noop\",\n  traceId: \"noop\",\n  name: \"noop\",\n  sampled: false,\n  parent: /*#__PURE__*/Option.none(),\n  context: /*#__PURE__*/Context.empty(),\n  status: {\n    _tag: \"Ended\",\n    startTime: /*#__PURE__*/BigInt(0),\n    endTime: /*#__PURE__*/BigInt(0),\n    exit: exitVoid\n  },\n  attributes: /*#__PURE__*/new Map(),\n  links: [],\n  kind: \"internal\",\n  attribute() {},\n  event() {},\n  end() {}\n};\n/** @internal */\nexport const noopSpan = name => {\n  const span = Object.create(NoopSpanProto);\n  span.name = name;\n  return span;\n};\n//# sourceMappingURL=core.js.map","/**\n * @since 0.67.0\n */\nimport * as Effect from \"effect/Effect\";\nimport * as Option from \"effect/Option\";\nimport * as Predicate from \"effect/Predicate\";\nimport * as AST from \"./AST.js\";\nimport * as util_ from \"./internal/util.js\";\nconst make = (value, forest = []) => ({\n  value,\n  forest\n});\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const formatIssue = issue => Effect.map(go(issue), tree => drawTree(tree));\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const formatIssueSync = issue => Effect.runSync(formatIssue(issue));\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const formatError = error => formatIssue(error.error);\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const formatErrorSync = error => formatIssueSync(error.error);\nconst drawTree = tree => tree.value + draw(\"\\n\", tree.forest);\nconst draw = (indentation, forest) => {\n  let r = \"\";\n  const len = forest.length;\n  let tree;\n  for (let i = 0; i < len; i++) {\n    tree = forest[i];\n    const isLast = i === len - 1;\n    r += indentation + (isLast ? \"\" : \"\") + \" \" + tree.value;\n    r += draw(indentation + (len > 1 && !isLast ? \"  \" : \"   \"), tree.forest);\n  }\n  return r;\n};\nconst formatTransformationKind = kind => {\n  switch (kind) {\n    case \"Encoded\":\n      return \"Encoded side transformation failure\";\n    case \"Transformation\":\n      return \"Transformation process failure\";\n    case \"Type\":\n      return \"Type side transformation failure\";\n  }\n};\nconst formatRefinementKind = kind => {\n  switch (kind) {\n    case \"From\":\n      return \"From side refinement failure\";\n    case \"Predicate\":\n      return \"Predicate refinement failure\";\n  }\n};\nconst getInnerMessage = issue => {\n  switch (issue._tag) {\n    case \"Refinement\":\n      {\n        if (issue.kind === \"From\") {\n          return getMessage(issue.error);\n        }\n        break;\n      }\n    case \"Transformation\":\n      {\n        return getMessage(issue.error);\n      }\n  }\n  return Option.none();\n};\nconst getCurrentMessage = issue => AST.getMessageAnnotation(issue.ast).pipe(Effect.flatMap(annotation => {\n  const out = annotation(issue);\n  return Predicate.isString(out) ? Effect.succeed({\n    message: out,\n    override: false\n  }) : Effect.isEffect(out) ? Effect.map(out, message => ({\n    message,\n    override: false\n  })) : Predicate.isString(out.message) ? Effect.succeed({\n    message: out.message,\n    override: out.override\n  }) : Effect.map(out.message, message => ({\n    message,\n    override: out.override\n  }));\n}));\n/** @internal */\nexport const getMessage = issue => {\n  const current = getCurrentMessage(issue);\n  return getInnerMessage(issue).pipe(Effect.flatMap(inner => Effect.map(current, current => current.override ? current.message : inner)), Effect.catchAll(() => Effect.flatMap(current, current => {\n    if (!current.override && (issue._tag === \"Refinement\" && issue.kind !== \"Predicate\" || issue._tag === \"Transformation\" && issue.kind !== \"Transformation\")) {\n      return Option.none();\n    }\n    return Effect.succeed(current.message);\n  })));\n};\nconst getParseIssueTitleAnnotation = issue => Option.filterMap(AST.getParseIssueTitleAnnotation(issue.ast), annotation => Option.fromNullable(annotation(issue)));\n/** @internal */\nexport const formatTypeMessage = e => getMessage(e).pipe(Effect.orElse(() => getParseIssueTitleAnnotation(e)), Effect.orElse(() => e.message), Effect.catchAll(() => Effect.succeed(`Expected ${e.ast.toString(true)}, actual ${util_.formatUnknown(e.actual)}`)));\nconst getParseIssueTitle = issue => Option.getOrElse(getParseIssueTitleAnnotation(issue), () => String(issue.ast));\n/** @internal */\nexport const formatForbiddenMessage = e => Option.getOrElse(e.message, () => \"is forbidden\");\nconst getTree = (issue, onFailure) => Effect.matchEffect(getMessage(issue), {\n  onFailure,\n  onSuccess: message => Effect.succeed(make(message))\n});\nconst go = e => {\n  switch (e._tag) {\n    case \"Type\":\n      return Effect.map(formatTypeMessage(e), make);\n    case \"Forbidden\":\n      return Effect.succeed(make(getParseIssueTitle(e), [make(formatForbiddenMessage(e))]));\n    case \"Unexpected\":\n      return Effect.succeed(make(`is unexpected, expected ${e.ast.toString(true)}`));\n    case \"Missing\":\n      return Effect.succeed(make(\"is missing\"));\n    case \"Union\":\n      return getTree(e, () => Effect.map(Effect.forEach(e.errors, e => {\n        switch (e._tag) {\n          case \"Member\":\n            return Effect.map(go(e.error), tree => make(`Union member`, [tree]));\n          default:\n            return go(e);\n        }\n      }), forest => make(getParseIssueTitle(e), forest)));\n    case \"TupleType\":\n      return getTree(e, () => Effect.map(Effect.forEach(e.errors, index => Effect.map(go(index.error), tree => make(`[${util_.formatPropertyKey(index.index)}]`, [tree]))), forest => make(getParseIssueTitle(e), forest)));\n    case \"TypeLiteral\":\n      return getTree(e, () => Effect.map(Effect.forEach(e.errors, key => Effect.map(go(key.error), tree => make(`[${util_.formatPropertyKey(key.key)}]`, [tree]))), forest => make(getParseIssueTitle(e), forest)));\n    case \"Transformation\":\n      return getTree(e, () => Effect.map(go(e.error), tree => make(getParseIssueTitle(e), [make(formatTransformationKind(e.kind), [tree])])));\n    case \"Refinement\":\n      return getTree(e, () => Effect.map(go(e.error), tree => make(getParseIssueTitle(e), [make(formatRefinementKind(e.kind), [tree])])));\n    case \"Declaration\":\n      return getTree(e, () => {\n        const error = e.error;\n        const shouldSkipDefaultMessage = error._tag === \"Type\" && error.ast === e.ast;\n        return shouldSkipDefaultMessage ? go(error) : Effect.map(go(error), tree => make(getParseIssueTitle(e), [tree]));\n      });\n  }\n};\n//# sourceMappingURL=TreeFormatter.js.map","import \"@dxos/node-std/globals\";\nimport import$sodium_universal from 'sodium-universal';\nimport import$_dxos_node_std_events from '@dxos/node-std/events';\nimport * as import$sodium_universal_memory from 'sodium-universal/memory';\nimport * as import$sodium_universal_crypto_aead from 'sodium-universal/crypto_aead';\nimport * as import$sodium_universal_helpers from 'sodium-universal/helpers';\nimport * as import$sodium_universal_crypto_generichash from 'sodium-universal/crypto_generichash';\nimport * as import$sodium_universal_crypto_kx from 'sodium-universal/crypto_kx';\nimport * as import$sodium_universal_crypto_scalarmult from 'sodium-universal/crypto_scalarmult';\nimport * as import$streamx from 'streamx';\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// inject-globals:@inject-globals\nimport {\n  global,\n  Buffer as Buffer2,\n  process\n} from \"@dxos/node-std/inject-globals\";\nvar init_inject_globals = __esm({\n  \"inject-globals:@inject-globals\"() {\n  }\n});\n\n// node_modules/.pnpm/last-one-wins@1.0.4/node_modules/last-one-wins/index.js\nvar require_last_one_wins = __commonJS({\n  \"node_modules/.pnpm/last-one-wins@1.0.4/node_modules/last-one-wins/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = function(work) {\n      var pending = null;\n      var callback = null;\n      var callbacks = null;\n      var next = null;\n      return function(val2, cb) {\n        next = val2;\n        update(cb || noop);\n      };\n      function update(cb) {\n        if (callback) {\n          if (!pending)\n            pending = [];\n          pending.push(cb);\n          return;\n        }\n        var val2 = next;\n        next = null;\n        callback = cb;\n        work(val2, done);\n      }\n      function done(err) {\n        var cb = callback;\n        var cbs = callbacks;\n        callbacks = null;\n        callback = null;\n        if (pending) {\n          callbacks = pending;\n          pending = null;\n          update(noop);\n        }\n        if (cbs) {\n          for (var i = 0; i < cbs.length; i++)\n            cbs[i](err);\n        }\n        cb(err);\n      }\n    };\n    function noop(_) {\n    }\n  }\n});\n\n// node_modules/.pnpm/unordered-array-remove@1.0.2/node_modules/unordered-array-remove/index.js\nvar require_unordered_array_remove = __commonJS({\n  \"node_modules/.pnpm/unordered-array-remove@1.0.2/node_modules/unordered-array-remove/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = remove;\n    function remove(arr, i) {\n      if (i >= arr.length || i < 0)\n        return;\n      var last = arr.pop();\n      if (i < arr.length) {\n        var tmp = arr[i];\n        arr[i] = last;\n        return tmp;\n      }\n      return last;\n    }\n  }\n});\n\n// node_modules/.pnpm/unordered-set@2.0.1/node_modules/unordered-set/index.js\nvar require_unordered_set = __commonJS({\n  \"node_modules/.pnpm/unordered-set@2.0.1/node_modules/unordered-set/index.js\"(exports) {\n    init_inject_globals();\n    exports.add = add;\n    exports.has = has;\n    exports.remove = remove;\n    exports.swap = swap;\n    function add(list, item) {\n      if (has(list, item))\n        return item;\n      item._index = list.length;\n      list.push(item);\n      return item;\n    }\n    function has(list, item) {\n      return item._index < list.length && list[item._index] === item;\n    }\n    function remove(list, item) {\n      if (!has(list, item))\n        return null;\n      var last = list.pop();\n      if (last !== item) {\n        list[item._index] = last;\n        last._index = item._index;\n      }\n      return item;\n    }\n    function swap(list, a, b) {\n      if (!has(list, a) || !has(list, b))\n        return;\n      var tmp = a._index;\n      a._index = b._index;\n      list[a._index] = a;\n      b._index = tmp;\n      list[b._index] = b;\n    }\n  }\n});\n\n// node_modules/.pnpm/flat-tree@1.9.0/node_modules/flat-tree/index.js\nvar require_flat_tree = __commonJS({\n  \"node_modules/.pnpm/flat-tree@1.9.0/node_modules/flat-tree/index.js\"(exports) {\n    init_inject_globals();\n    exports.fullRoots = function(index, result) {\n      if (index & 1)\n        throw new Error(\"You can only look up roots for depth(0) blocks\");\n      if (!result)\n        result = [];\n      index /= 2;\n      var offset = 0;\n      var factor = 1;\n      while (true) {\n        if (!index)\n          return result;\n        while (factor * 2 <= index)\n          factor *= 2;\n        result.push(offset + factor - 1);\n        offset = offset + 2 * factor;\n        index -= factor;\n        factor = 1;\n      }\n    };\n    exports.depth = function(index) {\n      var depth = 0;\n      index += 1;\n      while (!(index & 1)) {\n        depth++;\n        index = rightShift(index);\n      }\n      return depth;\n    };\n    exports.sibling = function(index, depth) {\n      if (!depth)\n        depth = exports.depth(index);\n      var offset = exports.offset(index, depth);\n      return exports.index(depth, offset & 1 ? offset - 1 : offset + 1);\n    };\n    exports.parent = function(index, depth) {\n      if (!depth)\n        depth = exports.depth(index);\n      var offset = exports.offset(index, depth);\n      return exports.index(depth + 1, rightShift(offset));\n    };\n    exports.leftChild = function(index, depth) {\n      if (!(index & 1))\n        return -1;\n      if (!depth)\n        depth = exports.depth(index);\n      return exports.index(depth - 1, exports.offset(index, depth) * 2);\n    };\n    exports.rightChild = function(index, depth) {\n      if (!(index & 1))\n        return -1;\n      if (!depth)\n        depth = exports.depth(index);\n      return exports.index(depth - 1, 1 + exports.offset(index, depth) * 2);\n    };\n    exports.children = function(index, depth) {\n      if (!(index & 1))\n        return null;\n      if (!depth)\n        depth = exports.depth(index);\n      var offset = exports.offset(index, depth) * 2;\n      return [\n        exports.index(depth - 1, offset),\n        exports.index(depth - 1, offset + 1)\n      ];\n    };\n    exports.leftSpan = function(index, depth) {\n      if (!(index & 1))\n        return index;\n      if (!depth)\n        depth = exports.depth(index);\n      return exports.offset(index, depth) * twoPow(depth + 1);\n    };\n    exports.rightSpan = function(index, depth) {\n      if (!(index & 1))\n        return index;\n      if (!depth)\n        depth = exports.depth(index);\n      return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2;\n    };\n    exports.count = function(index, depth) {\n      if (!(index & 1))\n        return 1;\n      if (!depth)\n        depth = exports.depth(index);\n      return twoPow(depth + 1) - 1;\n    };\n    exports.countLeaves = function(index) {\n      return (exports.count(index) + 1) / 2;\n    };\n    exports.spans = function(index, depth) {\n      if (!(index & 1))\n        return [index, index];\n      if (!depth)\n        depth = exports.depth(index);\n      var offset = exports.offset(index, depth);\n      var width = twoPow(depth + 1);\n      return [offset * width, (offset + 1) * width - 2];\n    };\n    exports.index = function(depth, offset) {\n      return (1 + 2 * offset) * twoPow(depth) - 1;\n    };\n    exports.offset = function(index, depth) {\n      if (!(index & 1))\n        return index / 2;\n      if (!depth)\n        depth = exports.depth(index);\n      return ((index + 1) / twoPow(depth) - 1) / 2;\n    };\n    exports.iterator = function(index) {\n      var ite = new Iterator();\n      ite.seek(index || 0);\n      return ite;\n    };\n    function twoPow(n) {\n      return n < 31 ? 1 << n : (1 << 30) * (1 << n - 30);\n    }\n    function rightShift(n) {\n      return (n - (n & 1)) / 2;\n    }\n    function Iterator() {\n      this.index = 0;\n      this.offset = 0;\n      this.factor = 0;\n    }\n    Iterator.prototype.seek = function(index) {\n      this.index = index;\n      if (this.index & 1) {\n        this.offset = exports.offset(index);\n        this.factor = twoPow(exports.depth(index) + 1);\n      } else {\n        this.offset = index / 2;\n        this.factor = 2;\n      }\n    };\n    Iterator.prototype.isLeft = function() {\n      return (this.offset & 1) === 0;\n    };\n    Iterator.prototype.isRight = function() {\n      return (this.offset & 1) === 1;\n    };\n    Iterator.prototype.contains = function(index) {\n      return index > this.index ? index < this.index + this.factor / 2 : index < this.index ? index > this.index - this.factor / 2 : true;\n    };\n    Iterator.prototype.prev = function() {\n      if (!this.offset)\n        return this.index;\n      this.offset--;\n      this.index -= this.factor;\n      return this.index;\n    };\n    Iterator.prototype.next = function() {\n      this.offset++;\n      this.index += this.factor;\n      return this.index;\n    };\n    Iterator.prototype.count = function() {\n      if (!(this.index & 1))\n        return 1;\n      return this.factor - 1;\n    };\n    Iterator.prototype.countLeaves = function() {\n      return (this.count() + 1) / 2;\n    };\n    Iterator.prototype.sibling = function() {\n      return this.isLeft() ? this.next() : this.prev();\n    };\n    Iterator.prototype.parent = function() {\n      if (this.offset & 1) {\n        this.index -= this.factor / 2;\n        this.offset = (this.offset - 1) / 2;\n      } else {\n        this.index += this.factor / 2;\n        this.offset /= 2;\n      }\n      this.factor *= 2;\n      return this.index;\n    };\n    Iterator.prototype.leftSpan = function() {\n      this.index = this.index - this.factor / 2 + 1;\n      this.offset = this.index / 2;\n      this.factor = 2;\n      return this.index;\n    };\n    Iterator.prototype.rightSpan = function() {\n      this.index = this.index + this.factor / 2 - 1;\n      this.offset = this.index / 2;\n      this.factor = 2;\n      return this.index;\n    };\n    Iterator.prototype.leftChild = function() {\n      if (this.factor === 2)\n        return this.index;\n      this.factor /= 2;\n      this.index -= this.factor / 2;\n      this.offset *= 2;\n      return this.index;\n    };\n    Iterator.prototype.rightChild = function() {\n      if (this.factor === 2)\n        return this.index;\n      this.factor /= 2;\n      this.index += this.factor / 2;\n      this.offset = 2 * this.offset + 1;\n      return this.index;\n    };\n    Iterator.prototype.nextTree = function() {\n      this.index = this.index + this.factor / 2 + 1;\n      this.offset = this.index / 2;\n      this.factor = 2;\n      return this.index;\n    };\n    Iterator.prototype.prevTree = function() {\n      if (!this.offset) {\n        this.index = 0;\n        this.factor = 2;\n      } else {\n        this.index = this.index - this.factor / 2 - 1;\n        this.offset = this.index / 2;\n        this.factor = 2;\n      }\n      return this.index;\n    };\n    Iterator.prototype.fullRoot = function(index) {\n      if (index <= this.index || (this.index & 1) > 0)\n        return false;\n      while (index > this.index + this.factor + this.factor / 2) {\n        this.index += this.factor / 2;\n        this.factor *= 2;\n        this.offset /= 2;\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/.pnpm/merkle-tree-stream@4.0.0/node_modules/merkle-tree-stream/generator.js\nvar require_generator = __commonJS({\n  \"node_modules/.pnpm/merkle-tree-stream@4.0.0/node_modules/merkle-tree-stream/generator.js\"(exports, module) {\n    init_inject_globals();\n    var flat = require_flat_tree();\n    module.exports = class MerkleGenerator {\n      constructor(opts, roots) {\n        if (!opts || !opts.leaf || !opts.parent)\n          throw new Error(\"opts.leaf and opts.parent required\");\n        this.roots = roots || opts.roots || [];\n        this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0;\n        for (var i = 0; i < this.roots.length; i++) {\n          var r = this.roots[i];\n          if (r && !r.parent)\n            r.parent = flat.parent(r.index);\n        }\n        this._leaf = opts.leaf;\n        this._parent = opts.parent;\n      }\n      next(data, nodes) {\n        if (!Buffer2.isBuffer(data))\n          data = Buffer2.from(data);\n        if (!nodes)\n          nodes = [];\n        var index = 2 * this.blocks++;\n        var leaf = {\n          index,\n          parent: flat.parent(index),\n          hash: null,\n          size: data.length,\n          data\n        };\n        leaf.hash = this._leaf(leaf, this.roots);\n        this.roots.push(leaf);\n        nodes.push(leaf);\n        while (this.roots.length > 1) {\n          var left = this.roots[this.roots.length - 2];\n          var right = this.roots[this.roots.length - 1];\n          if (left.parent !== right.parent)\n            break;\n          this.roots.pop();\n          this.roots[this.roots.length - 1] = leaf = {\n            index: left.parent,\n            parent: flat.parent(left.parent),\n            hash: this._parent(left, right),\n            size: left.size + right.size,\n            data: null\n          };\n          nodes.push(leaf);\n        }\n        return nodes;\n      }\n    };\n  }\n});\n\n// node_modules/.pnpm/codecs@2.2.0/node_modules/codecs/index.js\nvar require_codecs = __commonJS({\n  \"node_modules/.pnpm/codecs@2.2.0/node_modules/codecs/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = codecs;\n    codecs.ascii = createString(\"ascii\");\n    codecs.utf8 = createString(\"utf-8\");\n    codecs.hex = createString(\"hex\");\n    codecs.base64 = createString(\"base64\");\n    codecs.ucs2 = createString(\"ucs2\");\n    codecs.utf16le = createString(\"utf16le\");\n    codecs.ndjson = createJSON(true);\n    codecs.json = createJSON(false);\n    codecs.binary = {\n      name: \"binary\",\n      encode: function encodeBinary(obj) {\n        return typeof obj === \"string\" ? Buffer2.from(obj, \"utf-8\") : Buffer2.isBuffer(obj) ? obj : Buffer2.from(obj.buffer, obj.byteOffset, obj.byteLength);\n      },\n      decode: function decodeBinary(buf) {\n        return Buffer2.isBuffer(buf) ? buf : Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      }\n    };\n    function codecs(fmt, fallback) {\n      if (typeof fmt === \"object\" && fmt && fmt.encode && fmt.decode)\n        return fmt;\n      switch (fmt) {\n        case \"ndjson\":\n          return codecs.ndjson;\n        case \"json\":\n          return codecs.json;\n        case \"ascii\":\n          return codecs.ascii;\n        case \"utf-8\":\n        case \"utf8\":\n          return codecs.utf8;\n        case \"hex\":\n          return codecs.hex;\n        case \"base64\":\n          return codecs.base64;\n        case \"ucs-2\":\n        case \"ucs2\":\n          return codecs.ucs2;\n        case \"utf16-le\":\n        case \"utf16le\":\n          return codecs.utf16le;\n      }\n      return fallback !== void 0 ? fallback : codecs.binary;\n    }\n    function createJSON(newline) {\n      return {\n        name: newline ? \"ndjson\" : \"json\",\n        encode: newline ? encodeNDJSON : encodeJSON,\n        decode: function decodeJSON(buf) {\n          return JSON.parse(buf.toString());\n        }\n      };\n      function encodeJSON(val2) {\n        return Buffer2.from(JSON.stringify(val2));\n      }\n      function encodeNDJSON(val2) {\n        return Buffer2.from(JSON.stringify(val2) + \"\\n\");\n      }\n    }\n    function createString(type) {\n      return {\n        name: type,\n        encode: function encodeString(val2) {\n          if (typeof val2 !== \"string\")\n            val2 = val2.toString();\n          return Buffer2.from(val2, type);\n        },\n        decode: function decodeString(buf) {\n          return buf.toString(type);\n        }\n      };\n    }\n  }\n});\n\n// node_modules/.pnpm/atomic-batcher@1.0.2/node_modules/atomic-batcher/index.js\nvar require_atomic_batcher = __commonJS({\n  \"node_modules/.pnpm/atomic-batcher@1.0.2/node_modules/atomic-batcher/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = batcher;\n    function batcher(run) {\n      var running = false;\n      var pendingBatch = null;\n      var pendingCallbacks = null;\n      var callbacks = null;\n      return append;\n      function done(err) {\n        if (callbacks)\n          callAll(callbacks, err);\n        running = false;\n        callbacks = pendingCallbacks;\n        var nextBatch = pendingBatch;\n        pendingBatch = null;\n        pendingCallbacks = null;\n        if (!nextBatch || !nextBatch.length) {\n          if (!callbacks || !callbacks.length) {\n            callbacks = null;\n            return;\n          }\n          if (!nextBatch)\n            nextBatch = [];\n        }\n        running = true;\n        run(nextBatch, done);\n      }\n      function append(val2, cb) {\n        if (running) {\n          if (!pendingBatch) {\n            pendingBatch = [];\n            pendingCallbacks = [];\n          }\n          pushAll(pendingBatch, val2);\n          if (cb)\n            pendingCallbacks.push(cb);\n        } else {\n          if (cb)\n            callbacks = [cb];\n          running = true;\n          run(Array.isArray(val2) ? val2 : [val2], done);\n        }\n      }\n    }\n    function pushAll(list, val2) {\n      if (Array.isArray(val2))\n        pushArray(list, val2);\n      else\n        list.push(val2);\n    }\n    function pushArray(list, val2) {\n      for (var i = 0; i < val2.length; i++)\n        list.push(val2[i]);\n    }\n    function callAll(list, err) {\n      for (var i = 0; i < list.length; i++)\n        list[i](err);\n    }\n  }\n});\n\n// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js\nvar require_inherits_browser = __commonJS({\n  \"node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js\"(exports, module) {\n    init_inject_globals();\n    if (typeof Object.create === \"function\") {\n      module.exports = function inherits(ctor, superCtor) {\n        if (superCtor) {\n          ctor.super_ = superCtor;\n          ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n              value: ctor,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n        }\n      };\n    } else {\n      module.exports = function inherits(ctor, superCtor) {\n        if (superCtor) {\n          ctor.super_ = superCtor;\n          var TempCtor = function() {\n          };\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        }\n      };\n    }\n  }\n});\n\n// node_modules/.pnpm/varint@4.0.1/node_modules/varint/encode.js\nvar require_encode = __commonJS({\n  \"node_modules/.pnpm/varint@4.0.1/node_modules/varint/encode.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = encode;\n    var MSB = 128;\n    var REST = 127;\n    var MSBALL = ~REST;\n    var INT = Math.pow(2, 31);\n    function encode(num, out, offset) {\n      out = out || [];\n      offset = offset || 0;\n      var oldOffset = offset;\n      while (num >= INT) {\n        out[offset++] = num & 255 | MSB;\n        num /= 128;\n      }\n      while (num & MSBALL) {\n        out[offset++] = num & 255 | MSB;\n        num >>>= 7;\n      }\n      out[offset] = num | 0;\n      encode.bytes = offset - oldOffset + 1;\n      return out;\n    }\n  }\n});\n\n// node_modules/.pnpm/varint@4.0.1/node_modules/varint/decode.js\nvar require_decode = __commonJS({\n  \"node_modules/.pnpm/varint@4.0.1/node_modules/varint/decode.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = read;\n    var MSB = 128;\n    var REST = 127;\n    function read(buf, offset) {\n      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n      do {\n        if (counter >= l) {\n          read.bytes = 0;\n          read.bytesRead = 0;\n          return void 0;\n        }\n        b = buf[counter++];\n        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);\n        shift += 7;\n      } while (b >= MSB);\n      read.bytes = counter - offset;\n      return res;\n    }\n  }\n});\n\n// node_modules/.pnpm/varint@4.0.1/node_modules/varint/length.js\nvar require_length = __commonJS({\n  \"node_modules/.pnpm/varint@4.0.1/node_modules/varint/length.js\"(exports, module) {\n    init_inject_globals();\n    var N1 = Math.pow(2, 7);\n    var N2 = Math.pow(2, 14);\n    var N3 = Math.pow(2, 21);\n    var N4 = Math.pow(2, 28);\n    var N5 = Math.pow(2, 35);\n    var N6 = Math.pow(2, 42);\n    var N7 = Math.pow(2, 49);\n    var N8 = Math.pow(2, 56);\n    var N9 = Math.pow(2, 63);\n    module.exports = function(value) {\n      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n    };\n  }\n});\n\n// node_modules/.pnpm/varint@4.0.1/node_modules/varint/index.js\nvar require_varint = __commonJS({\n  \"node_modules/.pnpm/varint@4.0.1/node_modules/varint/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = {\n      encode: require_encode(),\n      decode: require_decode(),\n      encodingLength: require_length()\n    };\n  }\n});\n\n// node_modules/.pnpm/buffer-alloc-unsafe@1.1.0/node_modules/buffer-alloc-unsafe/index.js\nvar require_buffer_alloc_unsafe = __commonJS({\n  \"node_modules/.pnpm/buffer-alloc-unsafe@1.1.0/node_modules/buffer-alloc-unsafe/index.js\"(exports, module) {\n    init_inject_globals();\n    function allocUnsafe(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be a number');\n      }\n      if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n      }\n      if (Buffer2.allocUnsafe) {\n        return Buffer2.allocUnsafe(size);\n      } else {\n        return new Buffer2(size);\n      }\n    }\n    module.exports = allocUnsafe;\n  }\n});\n\n// node_modules/.pnpm/bitfield-rle@2.2.1/node_modules/bitfield-rle/index.js\nvar require_bitfield_rle = __commonJS({\n  \"node_modules/.pnpm/bitfield-rle@2.2.1/node_modules/bitfield-rle/index.js\"(exports, module) {\n    init_inject_globals();\n    var varint = require_varint();\n    var alloc = require_buffer_alloc_unsafe();\n    module.exports = align(1);\n    function align(n) {\n      var exports2 = {};\n      exports2.align = align;\n      exports2.encode = encode;\n      exports2.encode.bytes = 0;\n      exports2.encodingLength = encodingLength;\n      exports2.decode = decode;\n      exports2.decode.bytes = 0;\n      exports2.decodingLength = decodingLength;\n      return exports2;\n      function State(input, output, offset) {\n        this.inputOffset = 0;\n        this.inputLength = input.length;\n        this.input = input;\n        this.outputOffset = offset;\n        this.output = output;\n      }\n      function encode(bitfield, buffer, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buffer)\n          buffer = alloc(encodingLength(bitfield));\n        var state = new State(bitfield, buffer, offset);\n        rle(state);\n        encode.bytes = state.outputOffset - offset;\n        return buffer;\n      }\n      function encodingLength(bitfield) {\n        var state = new State(bitfield, null, 0);\n        rle(state);\n        return state.outputOffset;\n      }\n      function decode(buffer, offset) {\n        if (!offset)\n          offset = 0;\n        var bitfield = alloc(decodingLength(buffer, offset));\n        var ptr = 0;\n        while (offset < buffer.length) {\n          var next = varint.decode(buffer, offset);\n          var repeat = next & 1;\n          var len = repeat ? (next - (next & 3)) / 4 : next / 2;\n          offset += varint.decode.bytes;\n          if (repeat) {\n            bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len);\n          } else {\n            buffer.copy(bitfield, ptr, offset, offset + len);\n            offset += len;\n          }\n          ptr += len;\n        }\n        bitfield.fill(0, ptr);\n        decode.bytes = buffer.length - offset;\n        return bitfield;\n      }\n      function decodingLength(buffer, offset) {\n        if (!offset)\n          offset = 0;\n        var len = 0;\n        while (offset < buffer.length) {\n          var next = varint.decode(buffer, offset);\n          offset += varint.decode.bytes;\n          var repeat = next & 1;\n          var slice = repeat ? (next - (next & 3)) / 4 : next / 2;\n          len += slice;\n          if (!repeat)\n            offset += slice;\n        }\n        if (offset > buffer.length)\n          throw new Error(\"Invalid RLE bitfield\");\n        if (len & n - 1)\n          return len + (n - (len & n - 1));\n        return len;\n      }\n      function rle(state) {\n        var len = 0;\n        var bits = 0;\n        var input = state.input;\n        while (state.inputLength > 0 && !input[state.inputLength - 1])\n          state.inputLength--;\n        for (var i = 0; i < state.inputLength; i++) {\n          if (input[i] === bits) {\n            len++;\n            continue;\n          }\n          if (len)\n            encodeUpdate(state, i, len, bits);\n          if (input[i] === 0 || input[i] === 255) {\n            bits = input[i];\n            len = 1;\n          } else {\n            len = 0;\n          }\n        }\n        if (len)\n          encodeUpdate(state, state.inputLength, len, bits);\n        encodeFinal(state);\n      }\n      function encodeHead(state, end) {\n        var headLength = end - state.inputOffset;\n        varint.encode(2 * headLength, state.output, state.outputOffset);\n        state.outputOffset += varint.encode.bytes;\n        state.input.copy(state.output, state.outputOffset, state.inputOffset, end);\n        state.outputOffset += headLength;\n      }\n      function encodeFinal(state) {\n        var headLength = state.inputLength - state.inputOffset;\n        if (!headLength)\n          return;\n        if (!state.output) {\n          state.outputOffset += headLength + varint.encodingLength(2 * headLength);\n        } else {\n          encodeHead(state, state.inputLength);\n        }\n        state.inputOffset = state.inputLength;\n      }\n      function encodeUpdate(state, i, len, bit) {\n        var headLength = i - len - state.inputOffset;\n        var headCost = headLength ? varint.encodingLength(2 * headLength) + headLength : 0;\n        var enc = 4 * len + (bit ? 2 : 0) + 1;\n        var encCost = headCost + varint.encodingLength(enc);\n        var baseCost = varint.encodingLength(2 * (i - state.inputOffset)) + i - state.inputOffset;\n        if (encCost >= baseCost)\n          return;\n        if (!state.output) {\n          state.outputOffset += encCost;\n          state.inputOffset = i;\n          return;\n        }\n        if (headLength)\n          encodeHead(state, i - len);\n        varint.encode(enc, state.output, state.outputOffset);\n        state.outputOffset += varint.encode.bytes;\n        state.inputOffset = i;\n      }\n    }\n  }\n});\n\n// node_modules/.pnpm/memory-pager@1.5.0/node_modules/memory-pager/index.js\nvar require_memory_pager = __commonJS({\n  \"node_modules/.pnpm/memory-pager@1.5.0/node_modules/memory-pager/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = Pager;\n    function Pager(pageSize, opts) {\n      if (!(this instanceof Pager))\n        return new Pager(pageSize, opts);\n      this.length = 0;\n      this.updates = [];\n      this.path = new Uint16Array(4);\n      this.pages = new Array(32768);\n      this.maxPages = this.pages.length;\n      this.level = 0;\n      this.pageSize = pageSize || 1024;\n      this.deduplicate = opts ? opts.deduplicate : null;\n      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;\n    }\n    Pager.prototype.updated = function(page) {\n      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {\n        page.deduplicate++;\n        if (page.deduplicate === this.deduplicate.length) {\n          page.deduplicate = 0;\n          if (page.buffer.equals && page.buffer.equals(this.deduplicate))\n            page.buffer = this.deduplicate;\n          break;\n        }\n      }\n      if (page.updated || !this.updates)\n        return;\n      page.updated = true;\n      this.updates.push(page);\n    };\n    Pager.prototype.lastUpdate = function() {\n      if (!this.updates || !this.updates.length)\n        return null;\n      var page = this.updates.pop();\n      page.updated = false;\n      return page;\n    };\n    Pager.prototype._array = function(i, noAllocate) {\n      if (i >= this.maxPages) {\n        if (noAllocate)\n          return;\n        grow(this, i);\n      }\n      factor(i, this.path);\n      var arr = this.pages;\n      for (var j = this.level; j > 0; j--) {\n        var p = this.path[j];\n        var next = arr[p];\n        if (!next) {\n          if (noAllocate)\n            return;\n          next = arr[p] = new Array(32768);\n        }\n        arr = next;\n      }\n      return arr;\n    };\n    Pager.prototype.get = function(i, noAllocate) {\n      var arr = this._array(i, noAllocate);\n      var first = this.path[0];\n      var page = arr && arr[first];\n      if (!page && !noAllocate) {\n        page = arr[first] = new Page(i, alloc(this.pageSize));\n        if (i >= this.length)\n          this.length = i + 1;\n      }\n      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {\n        page.buffer = copy(page.buffer);\n        page.deduplicate = 0;\n      }\n      return page;\n    };\n    Pager.prototype.set = function(i, buf) {\n      var arr = this._array(i, false);\n      var first = this.path[0];\n      if (i >= this.length)\n        this.length = i + 1;\n      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {\n        arr[first] = void 0;\n        return;\n      }\n      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {\n        buf = this.deduplicate;\n      }\n      var page = arr[first];\n      var b = truncate(buf, this.pageSize);\n      if (page)\n        page.buffer = b;\n      else\n        arr[first] = new Page(i, b);\n    };\n    Pager.prototype.toBuffer = function() {\n      var list = new Array(this.length);\n      var empty = alloc(this.pageSize);\n      var ptr = 0;\n      while (ptr < list.length) {\n        var arr = this._array(ptr, true);\n        for (var i = 0; i < 32768 && ptr < list.length; i++) {\n          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;\n        }\n      }\n      return Buffer2.concat(list);\n    };\n    function grow(pager, index) {\n      while (pager.maxPages < index) {\n        var old = pager.pages;\n        pager.pages = new Array(32768);\n        pager.pages[0] = old;\n        pager.level++;\n        pager.maxPages *= 32768;\n      }\n    }\n    function truncate(buf, len) {\n      if (buf.length === len)\n        return buf;\n      if (buf.length > len)\n        return buf.slice(0, len);\n      var cpy = alloc(len);\n      buf.copy(cpy);\n      return cpy;\n    }\n    function alloc(size) {\n      if (Buffer2.alloc)\n        return Buffer2.alloc(size);\n      var buf = new Buffer2(size);\n      buf.fill(0);\n      return buf;\n    }\n    function copy(buf) {\n      var cpy = Buffer2.allocUnsafe ? Buffer2.allocUnsafe(buf.length) : new Buffer2(buf.length);\n      buf.copy(cpy);\n      return cpy;\n    }\n    function Page(i, buf) {\n      this.offset = i * buf.length;\n      this.buffer = buf;\n      this.updated = false;\n      this.deduplicate = 0;\n    }\n    function factor(n, out) {\n      n = (n - (out[0] = n & 32767)) / 32768;\n      n = (n - (out[1] = n & 32767)) / 32768;\n      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;\n    }\n  }\n});\n\n// node_modules/.pnpm/sparse-bitfield@3.0.3/node_modules/sparse-bitfield/index.js\nvar require_sparse_bitfield = __commonJS({\n  \"node_modules/.pnpm/sparse-bitfield@3.0.3/node_modules/sparse-bitfield/index.js\"(exports, module) {\n    init_inject_globals();\n    var pager = require_memory_pager();\n    module.exports = Bitfield;\n    function Bitfield(opts) {\n      if (!(this instanceof Bitfield))\n        return new Bitfield(opts);\n      if (!opts)\n        opts = {};\n      if (Buffer2.isBuffer(opts))\n        opts = { buffer: opts };\n      this.pageOffset = opts.pageOffset || 0;\n      this.pageSize = opts.pageSize || 1024;\n      this.pages = opts.pages || pager(this.pageSize);\n      this.byteLength = this.pages.length * this.pageSize;\n      this.length = 8 * this.byteLength;\n      if (!powerOfTwo(this.pageSize))\n        throw new Error(\"The page size should be a power of two\");\n      this._trackUpdates = !!opts.trackUpdates;\n      this._pageMask = this.pageSize - 1;\n      if (opts.buffer) {\n        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {\n          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));\n        }\n        this.byteLength = opts.buffer.length;\n        this.length = 8 * this.byteLength;\n      }\n    }\n    Bitfield.prototype.get = function(i) {\n      var o = i & 7;\n      var j = (i - o) / 8;\n      return !!(this.getByte(j) & 128 >> o);\n    };\n    Bitfield.prototype.getByte = function(i) {\n      var o = i & this._pageMask;\n      var j = (i - o) / this.pageSize;\n      var page = this.pages.get(j, true);\n      return page ? page.buffer[o + this.pageOffset] : 0;\n    };\n    Bitfield.prototype.set = function(i, v) {\n      var o = i & 7;\n      var j = (i - o) / 8;\n      var b = this.getByte(j);\n      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));\n    };\n    Bitfield.prototype.toBuffer = function() {\n      var all = alloc(this.pages.length * this.pageSize);\n      for (var i = 0; i < this.pages.length; i++) {\n        var next = this.pages.get(i, true);\n        var allOffset = i * this.pageSize;\n        if (next)\n          next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);\n      }\n      return all;\n    };\n    Bitfield.prototype.setByte = function(i, b) {\n      var o = i & this._pageMask;\n      var j = (i - o) / this.pageSize;\n      var page = this.pages.get(j, false);\n      o += this.pageOffset;\n      if (page.buffer[o] === b)\n        return false;\n      page.buffer[o] = b;\n      if (i >= this.byteLength) {\n        this.byteLength = i + 1;\n        this.length = this.byteLength * 8;\n      }\n      if (this._trackUpdates)\n        this.pages.updated(page);\n      return true;\n    };\n    function alloc(n) {\n      if (Buffer2.alloc)\n        return Buffer2.alloc(n);\n      var b = new Buffer2(n);\n      b.fill(0);\n      return b;\n    }\n    function powerOfTwo(x) {\n      return !(x & x - 1);\n    }\n  }\n});\n\n// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/bitfield.js\nvar require_bitfield = __commonJS({\n  \"node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/bitfield.js\"(exports, module) {\n    init_inject_globals();\n    var flat = require_flat_tree();\n    var rle = require_bitfield_rle();\n    var pager = require_memory_pager();\n    var bitfield = require_sparse_bitfield();\n    var INDEX_UPDATE_MASK = [63, 207, 243, 252];\n    var INDEX_ITERATE_MASK = [0, 192, 240, 252];\n    var DATA_ITERATE_MASK = [128, 192, 224, 240, 248, 252, 254, 255];\n    var DATA_UPDATE_MASK = [127, 191, 223, 239, 247, 251, 253, 254];\n    var MAP_PARENT_RIGHT = new Array(256);\n    var MAP_PARENT_LEFT = new Array(256);\n    var NEXT_DATA_0_BIT = new Array(256);\n    var NEXT_INDEX_0_BIT = new Array(256);\n    var TOTAL_1_BITS = new Array(256);\n    for (i = 0; i < 256; i++) {\n      a = (i & 15 << 4) >> 4;\n      b = i & 15;\n      nibble = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4];\n      MAP_PARENT_RIGHT[i] = (a === 15 ? 3 : a === 0 ? 0 : 1) << 2 | (b === 15 ? 3 : b === 0 ? 0 : 1);\n      MAP_PARENT_LEFT[i] = MAP_PARENT_RIGHT[i] << 4;\n      NEXT_DATA_0_BIT[i] = i === 255 ? -1 : 8 - Math.ceil(Math.log(256 - i) / Math.log(2));\n      NEXT_INDEX_0_BIT[i] = i === 255 ? -1 : Math.floor(NEXT_DATA_0_BIT[i] / 2);\n      TOTAL_1_BITS[i] = nibble[i >> 4] + nibble[i & 15];\n    }\n    var a;\n    var b;\n    var nibble;\n    var i;\n    module.exports = Bitfield;\n    function Bitfield(pageSize, pages) {\n      if (!(this instanceof Bitfield))\n        return new Bitfield(pageSize, pages);\n      if (!pageSize)\n        pageSize = 2048 + 1024 + 512;\n      var deduplicate = Buffer2.allocUnsafe(pageSize);\n      deduplicate.fill(255);\n      this.indexSize = pageSize - 2048 - 1024;\n      this.pages = pager(pageSize, { deduplicate });\n      if (pages) {\n        for (var i2 = 0; i2 < pages.length; i2++) {\n          this.pages.set(i2, pages[i2]);\n        }\n      }\n      this.data = bitfield({\n        pageSize: 1024,\n        pageOffset: 0,\n        pages: this.pages,\n        trackUpdates: true\n      });\n      this.tree = bitfield({\n        pageSize: 2048,\n        pageOffset: 1024,\n        pages: this.pages,\n        trackUpdates: true\n      });\n      this.index = bitfield({\n        pageSize: this.indexSize,\n        pageOffset: 1024 + 2048,\n        pages: this.pages,\n        trackUpdates: true\n      });\n      this.length = this.data.length;\n      this._iterator = flat.iterator(0);\n    }\n    Bitfield.prototype.set = function(i2, value) {\n      var o = i2 & 7;\n      i2 = (i2 - o) / 8;\n      var v = value ? this.data.getByte(i2) | 128 >> o : this.data.getByte(i2) & DATA_UPDATE_MASK[o];\n      if (!this.data.setByte(i2, v))\n        return false;\n      this.length = this.data.length;\n      this._setIndex(i2, v);\n      return true;\n    };\n    Bitfield.prototype.get = function(i2) {\n      return this.data.get(i2);\n    };\n    Bitfield.prototype.total = function(start, end) {\n      if (!start || start < 0)\n        start = 0;\n      if (!end)\n        end = this.data.length;\n      if (end < start)\n        return 0;\n      if (end > this.data.length) {\n        this._expand(end);\n      }\n      var o = start & 7;\n      var e = end & 7;\n      var pos = (start - o) / 8;\n      var last = (end - e) / 8;\n      var leftMask = 255 - (o ? DATA_ITERATE_MASK[o - 1] : 0);\n      var rightMask = e ? DATA_ITERATE_MASK[e - 1] : 0;\n      var byte = this.data.getByte(pos);\n      if (pos === last) {\n        return TOTAL_1_BITS[byte & leftMask & rightMask];\n      }\n      var total = TOTAL_1_BITS[byte & leftMask];\n      for (var i2 = pos + 1; i2 < last; i2++) {\n        total += TOTAL_1_BITS[this.data.getByte(i2)];\n      }\n      total += TOTAL_1_BITS[this.data.getByte(last) & rightMask];\n      return total;\n    };\n    Bitfield.prototype.compress = function(start, length) {\n      if (!start && !length)\n        return rle.encode(this.data.toBuffer());\n      if (start + length > this.length)\n        length = Math.max(1, this.length - start);\n      var buf = Buffer2.alloc(Math.ceil(length / 8));\n      var p = start / this.data.pageSize / 8;\n      var end = p + length / this.data.pageSize / 8;\n      var offset = p * this.data.pageSize;\n      for (; p < end; p++) {\n        var page = this.data.pages.get(p, true);\n        if (!page || !page.buffer)\n          continue;\n        page.buffer.copy(buf, p * this.data.pageSize - offset, this.data.pageOffset, this.data.pageOffset + this.data.pageSize);\n      }\n      return rle.encode(buf);\n    };\n    Bitfield.prototype._setIndex = function(i2, value) {\n      var o = i2 & 3;\n      i2 = (i2 - o) / 4;\n      var bitfield2 = this.index;\n      var ite = this._iterator;\n      var start = 2 * i2;\n      var byte = bitfield2.getByte(start) & INDEX_UPDATE_MASK[o] | getIndexValue(value) >> 2 * o;\n      var len = bitfield2.length;\n      var maxLength = this.pages.length * this.indexSize;\n      ite.seek(start);\n      while (ite.index < maxLength && bitfield2.setByte(ite.index, byte)) {\n        if (ite.isLeft()) {\n          byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield2.getByte(ite.sibling())];\n        } else {\n          byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield2.getByte(ite.sibling())];\n        }\n        ite.parent();\n      }\n      if (len !== bitfield2.length)\n        this._expand(len);\n      return ite.index !== start;\n    };\n    Bitfield.prototype._expand = function(len) {\n      var roots = flat.fullRoots(2 * len);\n      var bitfield2 = this.index;\n      var ite = this._iterator;\n      var byte = 0;\n      for (var i2 = 0; i2 < roots.length; i2++) {\n        ite.seek(roots[i2]);\n        byte = bitfield2.getByte(ite.index);\n        do {\n          if (ite.isLeft()) {\n            byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield2.getByte(ite.sibling())];\n          } else {\n            byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield2.getByte(ite.sibling())];\n          }\n        } while (setByteNoAlloc(bitfield2, ite.parent(), byte));\n      }\n    };\n    function setByteNoAlloc(bitfield2, i2, b2) {\n      if (8 * i2 >= bitfield2.length)\n        return false;\n      return bitfield2.setByte(i2, b2);\n    }\n    Bitfield.prototype.iterator = function(start, end) {\n      var ite = new Iterator(this);\n      ite.range(start || 0, end || this.length);\n      ite.seek(0);\n      return ite;\n    };\n    function Iterator(bitfield2) {\n      this.start = 0;\n      this.end = 0;\n      this._indexEnd = 0;\n      this._pos = 0;\n      this._byte = 0;\n      this._bitfield = bitfield2;\n    }\n    Iterator.prototype.range = function(start, end) {\n      this.start = start;\n      this.end = end;\n      this._indexEnd = 2 * Math.ceil(end / 32);\n      if (this.end > this._bitfield.length) {\n        this._bitfield._expand(this.end);\n      }\n      return this;\n    };\n    Iterator.prototype.seek = function(offset) {\n      offset += this.start;\n      if (offset < this.start)\n        offset = this.start;\n      if (offset >= this.end) {\n        this._pos = -1;\n        return this;\n      }\n      var o = offset & 7;\n      this._pos = (offset - o) / 8;\n      this._byte = this._bitfield.data.getByte(this._pos) | (o ? DATA_ITERATE_MASK[o - 1] : 0);\n      return this;\n    };\n    Iterator.prototype.random = function() {\n      var i2 = this.seek(Math.floor(Math.random() * (this.end - this.start))).next();\n      return i2 === -1 ? this.seek(0).next() : i2;\n    };\n    Iterator.prototype.next = function() {\n      if (this._pos === -1)\n        return -1;\n      var dataBitfield = this._bitfield.data;\n      var free = NEXT_DATA_0_BIT[this._byte];\n      while (free === -1) {\n        this._byte = dataBitfield.getByte(++this._pos);\n        free = NEXT_DATA_0_BIT[this._byte];\n        if (free === -1) {\n          this._pos = this._skipAhead(this._pos);\n          if (this._pos === -1)\n            return -1;\n          this._byte = dataBitfield.getByte(this._pos);\n          free = NEXT_DATA_0_BIT[this._byte];\n        }\n      }\n      this._byte |= DATA_ITERATE_MASK[free];\n      var n = 8 * this._pos + free;\n      return n < this.end ? n : -1;\n    };\n    Iterator.prototype.peek = function() {\n      if (this._pos === -1)\n        return -1;\n      var free = NEXT_DATA_0_BIT[this._byte];\n      var n = 8 * this._pos + free;\n      return n < this.end ? n : -1;\n    };\n    Iterator.prototype._skipAhead = function(start) {\n      var indexBitfield = this._bitfield.index;\n      var treeEnd = this._indexEnd;\n      var ite = this._bitfield._iterator;\n      var o = start & 3;\n      ite.seek(2 * ((start - o) / 4));\n      var treeByte = indexBitfield.getByte(ite.index) | INDEX_ITERATE_MASK[o];\n      while (NEXT_INDEX_0_BIT[treeByte] === -1) {\n        if (ite.isLeft()) {\n          ite.next();\n        } else {\n          ite.next();\n          ite.parent();\n        }\n        if (rightSpan(ite) >= treeEnd) {\n          while (rightSpan(ite) >= treeEnd && isParent(ite))\n            ite.leftChild();\n          if (rightSpan(ite) >= treeEnd)\n            return -1;\n        }\n        treeByte = indexBitfield.getByte(ite.index);\n      }\n      while (ite.factor > 2) {\n        if (NEXT_INDEX_0_BIT[treeByte] < 2)\n          ite.leftChild();\n        else\n          ite.rightChild();\n        treeByte = indexBitfield.getByte(ite.index);\n      }\n      var free = NEXT_INDEX_0_BIT[treeByte];\n      if (free === -1)\n        free = 4;\n      var next = ite.index * 2 + free;\n      return next <= start ? start + 1 : next;\n    };\n    function rightSpan(ite) {\n      return ite.index + ite.factor / 2 - 1;\n    }\n    function isParent(ite) {\n      return ite.index & 1;\n    }\n    function getIndexValue(n) {\n      switch (n) {\n        case 255:\n          return 192;\n        case 0:\n          return 0;\n        default:\n          return 64;\n      }\n    }\n  }\n});\n\n// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/tree-index.js\nvar require_tree_index = __commonJS({\n  \"node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/tree-index.js\"(exports, module) {\n    init_inject_globals();\n    var flat = require_flat_tree();\n    var bitfield = require_sparse_bitfield();\n    module.exports = TreeIndex;\n    function TreeIndex(bits) {\n      if (!(this instanceof TreeIndex))\n        return new TreeIndex(bits);\n      this.bitfield = bits || bitfield();\n    }\n    TreeIndex.prototype.proof = function(index, opts) {\n      if (!opts)\n        opts = {};\n      var nodes = [];\n      var remoteTree = opts.tree || new TreeIndex();\n      var digest = opts.digest || 0;\n      if (!this.get(index))\n        return null;\n      if (opts.hash)\n        nodes.push(index);\n      if (digest === 1)\n        return { nodes, verifiedBy: 0 };\n      var roots = null;\n      var sibling = index;\n      var next = index;\n      var hasRoot = digest & 1;\n      digest = rightShift(digest);\n      while (digest) {\n        if (digest === 1 && hasRoot) {\n          if (this.get(next))\n            remoteTree.set(next);\n          if (flat.sibling(next) < next)\n            next = flat.sibling(next);\n          roots = flat.fullRoots(flat.rightSpan(next) + 2);\n          for (var i = 0; i < roots.length; i++) {\n            if (this.get(roots[i]))\n              remoteTree.set(roots[i]);\n          }\n          break;\n        }\n        sibling = flat.sibling(next);\n        if (digest & 1) {\n          if (this.get(sibling))\n            remoteTree.set(sibling);\n        }\n        next = flat.parent(next);\n        digest = rightShift(digest);\n      }\n      next = index;\n      while (!remoteTree.get(next)) {\n        sibling = flat.sibling(next);\n        if (!this.get(sibling)) {\n          var verifiedBy = this.verifiedBy(next);\n          addFullRoots(verifiedBy, nodes, next, remoteTree);\n          return { nodes, verifiedBy };\n        } else {\n          if (!remoteTree.get(sibling))\n            nodes.push(sibling);\n        }\n        next = flat.parent(next);\n      }\n      return { nodes, verifiedBy: 0 };\n    };\n    TreeIndex.prototype.digest = function(index) {\n      if (this.get(index))\n        return 1;\n      var digest = 0;\n      var next = flat.sibling(index);\n      var max = Math.max(next + 2, this.bitfield.length);\n      var bit = 2;\n      var depth = flat.depth(index);\n      var parent = flat.parent(next, depth++);\n      while (flat.rightSpan(next) < max || flat.leftSpan(parent) > 0) {\n        if (this.get(next)) {\n          digest += bit;\n        }\n        if (this.get(parent)) {\n          digest += 2 * bit;\n          if (!(digest & 1))\n            digest += 1;\n          if (digest + 1 === 4 * bit)\n            return 1;\n          return digest;\n        }\n        next = flat.sibling(parent);\n        parent = flat.parent(next, depth++);\n        bit *= 2;\n      }\n      return digest;\n    };\n    TreeIndex.prototype.blocks = function() {\n      var top = 0;\n      var next = 0;\n      var max = this.bitfield.length;\n      while (flat.rightSpan(next) < max) {\n        next = flat.parent(next);\n        if (this.get(next))\n          top = next;\n      }\n      return (this.get(top) ? this.verifiedBy(top) : 0) / 2;\n    };\n    TreeIndex.prototype.roots = function() {\n      return flat.fullRoots(2 * this.blocks());\n    };\n    TreeIndex.prototype.verifiedBy = function(index, nodes) {\n      var hasIndex = this.get(index);\n      if (!hasIndex)\n        return 0;\n      var depth = flat.depth(index);\n      var top = index;\n      var parent = flat.parent(top, depth++);\n      while (this.get(parent) && this.get(flat.sibling(top))) {\n        top = parent;\n        parent = flat.parent(top, depth++);\n      }\n      depth--;\n      while (depth) {\n        top = flat.leftChild(flat.index(depth, flat.offset(top, depth) + 1), depth);\n        depth--;\n        while (!this.get(top) && depth)\n          top = flat.leftChild(top, depth--);\n        if (nodes && this.get(top))\n          nodes.push(top);\n      }\n      return this.get(top) ? top + 2 : top;\n    };\n    TreeIndex.prototype.get = function(index) {\n      return this.bitfield.get(index);\n    };\n    TreeIndex.prototype.truncate = function(len) {\n      const currentLen = 2 * this.blocks();\n      const roots = flat.fullRoots(len);\n      for (let i = len; i < currentLen; i++) {\n        this.bitfield.set(i, false);\n      }\n      for (const root of roots) {\n        let p = flat.parent(root);\n        while (p < len) {\n          this.bitfield.set(p, false);\n          p = flat.parent(p);\n        }\n      }\n    };\n    TreeIndex.prototype.set = function(index) {\n      if (!this.bitfield.set(index, true))\n        return false;\n      while (this.bitfield.get(flat.sibling(index))) {\n        index = flat.parent(index);\n        if (!this.bitfield.set(index, true))\n          break;\n      }\n      return true;\n    };\n    function rightShift(n) {\n      return (n - (n & 1)) / 2;\n    }\n    function addFullRoots(verifiedBy, nodes, root, remoteTree) {\n      var roots = flat.fullRoots(verifiedBy);\n      for (var i = 0; i < roots.length; i++) {\n        if (roots[i] !== root && !remoteTree.get(roots[i]))\n          nodes.push(roots[i]);\n      }\n    }\n  }\n});\n\n// node_modules/.pnpm/buffer-fill@1.0.0/node_modules/buffer-fill/index.js\nvar require_buffer_fill = __commonJS({\n  \"node_modules/.pnpm/buffer-fill@1.0.0/node_modules/buffer-fill/index.js\"(exports, module) {\n    init_inject_globals();\n    var hasFullSupport = function() {\n      try {\n        if (!Buffer2.isEncoding(\"latin1\")) {\n          return false;\n        }\n        var buf = Buffer2.alloc ? Buffer2.alloc(4) : new Buffer2(4);\n        buf.fill(\"ab\", \"ucs2\");\n        return buf.toString(\"hex\") === \"61006200\";\n      } catch (_) {\n        return false;\n      }\n    }();\n    function isSingleByte(val2) {\n      return val2.length === 1 && val2.charCodeAt(0) < 256;\n    }\n    function fillWithNumber(buffer, val2, start, end) {\n      if (start < 0 || end > buffer.length) {\n        throw new RangeError(\"Out of range index\");\n      }\n      start = start >>> 0;\n      end = end === void 0 ? buffer.length : end >>> 0;\n      if (end > start) {\n        buffer.fill(val2, start, end);\n      }\n      return buffer;\n    }\n    function fillWithBuffer(buffer, val2, start, end) {\n      if (start < 0 || end > buffer.length) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return buffer;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? buffer.length : end >>> 0;\n      var pos = start;\n      var len = val2.length;\n      while (pos <= end - len) {\n        val2.copy(buffer, pos);\n        pos += len;\n      }\n      if (pos !== end) {\n        val2.copy(buffer, pos, 0, end - pos);\n      }\n      return buffer;\n    }\n    function fill(buffer, val2, start, end, encoding) {\n      if (hasFullSupport) {\n        return buffer.fill(val2, start, end, encoding);\n      }\n      if (typeof val2 === \"number\") {\n        return fillWithNumber(buffer, val2, start, end);\n      }\n      if (typeof val2 === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = buffer.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = buffer.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (encoding === \"latin1\") {\n          encoding = \"binary\";\n        }\n        if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val2 === \"\") {\n          return fillWithNumber(buffer, 0, start, end);\n        }\n        if (isSingleByte(val2)) {\n          return fillWithNumber(buffer, val2.charCodeAt(0), start, end);\n        }\n        val2 = new Buffer2(val2, encoding);\n      }\n      if (Buffer2.isBuffer(val2)) {\n        return fillWithBuffer(buffer, val2, start, end);\n      }\n      return fillWithNumber(buffer, 0, start, end);\n    }\n    module.exports = fill;\n  }\n});\n\n// node_modules/.pnpm/buffer-alloc@1.2.0/node_modules/buffer-alloc/index.js\nvar require_buffer_alloc = __commonJS({\n  \"node_modules/.pnpm/buffer-alloc@1.2.0/node_modules/buffer-alloc/index.js\"(exports, module) {\n    init_inject_globals();\n    var bufferFill = require_buffer_fill();\n    var allocUnsafe = require_buffer_alloc_unsafe();\n    module.exports = function alloc(size, fill, encoding) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be a number');\n      }\n      if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n      }\n      if (Buffer2.alloc) {\n        return Buffer2.alloc(size, fill, encoding);\n      }\n      var buffer = allocUnsafe(size);\n      if (size === 0) {\n        return buffer;\n      }\n      if (fill === void 0) {\n        return bufferFill(buffer, 0);\n      }\n      if (typeof encoding !== \"string\") {\n        encoding = void 0;\n      }\n      return bufferFill(buffer, fill, encoding);\n    };\n  }\n});\n\n// node_modules/.pnpm/uint64be@2.0.2/node_modules/uint64be/index.js\nvar require_uint64be = __commonJS({\n  \"node_modules/.pnpm/uint64be@2.0.2/node_modules/uint64be/index.js\"(exports) {\n    init_inject_globals();\n    var bufferAlloc = require_buffer_alloc();\n    var UINT_32_MAX = Math.pow(2, 32);\n    exports.encodingLength = function() {\n      return 8;\n    };\n    exports.encode = function(num, buf, offset) {\n      if (!buf)\n        buf = bufferAlloc(8);\n      if (!offset)\n        offset = 0;\n      var top = Math.floor(num / UINT_32_MAX);\n      var rem = num - top * UINT_32_MAX;\n      buf.writeUInt32BE(top, offset);\n      buf.writeUInt32BE(rem, offset + 4);\n      return buf;\n    };\n    exports.decode = function(buf, offset) {\n      if (!offset)\n        offset = 0;\n      var top = buf.readUInt32BE(offset);\n      var rem = buf.readUInt32BE(offset + 4);\n      return top * UINT_32_MAX + rem;\n    };\n    exports.encode.bytes = 8;\n    exports.decode.bytes = 8;\n  }\n});\n\n// node_modules/.pnpm/hypercore-cache@1.0.2/node_modules/hypercore-cache/index.js\nvar require_hypercore_cache = __commonJS({\n  \"node_modules/.pnpm/hypercore-cache@1.0.2/node_modules/hypercore-cache/index.js\"(exports, module) {\n    init_inject_globals();\n    var DEFAULT_MAX_BYTE_SIZE = 1024 * 1024 * 16;\n    var NamespacedCache = class {\n      constructor(parent, name) {\n        this.name = name;\n        this.parent = parent;\n      }\n      get _info() {\n        return this.parent._info;\n      }\n      set(key, value) {\n        return this.parent._set(this.name, key, value);\n      }\n      del(key) {\n        return this.parent._del(this.name, key);\n      }\n      get(key) {\n        return this.parent._get(this.name, key);\n      }\n    };\n    module.exports = class HypercoreCache {\n      constructor(opts = {}) {\n        this.maxByteSize = opts.maxByteSize || DEFAULT_MAX_BYTE_SIZE;\n        this.onEvict = opts.onEvict;\n        this.estimateSize = opts.estimateSize || defaultSize;\n        this._nextNamespace = 0;\n        this.defaultCache = new NamespacedCache(this, this._nextNamespace++);\n        this._stale = null;\n        this._fresh = /* @__PURE__ */ new Map();\n        this._freshByteSize = 0;\n        this._staleByteSize = 0;\n      }\n      get _info() {\n        return {\n          freshByteSize: this._freshByteSize,\n          staleByteSize: this._staleByteSize,\n          staleEntries: this._stale ? this._stale.size : 0,\n          freshEntries: this._fresh.size,\n          byteSize: this.byteSize\n        };\n      }\n      _prefix(namespace, key) {\n        return namespace + \":\" + key;\n      }\n      _gc() {\n        if (this.onEvict && this._staleByteSize > 0)\n          this.onEvict(this._stale);\n        this._stale = this._fresh;\n        this._fresh = /* @__PURE__ */ new Map();\n        this._staleByteSize = this._freshByteSize;\n        this._freshByteSize = 0;\n      }\n      _get(namespace, key, prefixedKey) {\n        if (!prefixedKey)\n          prefixedKey = this._prefix(namespace, key);\n        return this._fresh.get(prefixedKey) || this._stale && this._stale.get(prefixedKey);\n      }\n      _set(namespace, key, value) {\n        const valueSize = this.estimateSize(value);\n        const prefixedKey = this._prefix(namespace, key);\n        if (this._freshByteSize + valueSize > this.maxByteSize) {\n          this._gc();\n        }\n        this._fresh.set(prefixedKey, value);\n        this._freshByteSize += valueSize;\n      }\n      _del(namespace, key) {\n        const prefixedKey = this._prefix(namespace, key);\n        let val2 = this._stale && this._stale.get(prefixedKey);\n        if (val2) {\n          this._stale.delete(prefixedKey);\n          this._staleByteSize -= this.estimateSize(val2);\n        }\n        val2 = this._fresh.get(prefixedKey);\n        if (val2) {\n          this._fresh.delete(prefixedKey);\n          this._freshByteSize -= this.estimateSize(val2);\n        }\n      }\n      get byteSize() {\n        return this._freshByteSize + this._staleByteSize;\n      }\n      namespace() {\n        const cache = new NamespacedCache(this, this._nextNamespace++);\n        return cache;\n      }\n      set(key, value) {\n        return this.defaultCache.set(key, value);\n      }\n      del(key) {\n        return this.defaultCache.del(key);\n      }\n      get(key) {\n        return this.defaultCache.get(key);\n      }\n    };\n    function defaultSize() {\n      return 1024;\n    }\n  }\n});\n\n// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/cache.js\nvar require_cache = __commonJS({\n  \"node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/cache.js\"(exports, module) {\n    init_inject_globals();\n    var HypercoreCache = require_hypercore_cache();\n    var DEFAULT_TREE_CACHE_SIZE = 65536 * 40;\n    function createCache(opts) {\n      if (opts.cache === false)\n        return {};\n      const cacheOpts = opts.cache || {};\n      if (cacheOpts.tree === void 0 || typeof cacheOpts.tree === \"number\") {\n        const cacheSize = cacheOpts.tree || opts.storageCacheSize;\n        cacheOpts.tree = new HypercoreCache({\n          maxByteSize: cacheSize !== void 0 ? cacheSize : DEFAULT_TREE_CACHE_SIZE,\n          estimateSize: () => 40\n        });\n      }\n      if (cacheOpts.data === void 0)\n        return cacheOpts;\n      if (typeof cacheOpts.data === \"number\") {\n        cacheOpts.data = new HypercoreCache({\n          maxByteSize: cacheOpts.data,\n          estimateSize: (buf) => buf.length\n        });\n      }\n      return cacheOpts;\n    }\n    module.exports = createCache;\n  }\n});\n\n// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/storage.js\nvar require_storage = __commonJS({\n  \"node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/storage.js\"(exports, module) {\n    init_inject_globals();\n    var uint64be = require_uint64be();\n    var flat = require_flat_tree();\n    var createCache = require_cache();\n    module.exports = Storage;\n    var noarr = [];\n    function Storage(create, opts) {\n      if (!(this instanceof Storage))\n        return new Storage(create, opts);\n      const cache = createCache(opts);\n      this.treeCache = cache.tree || null;\n      this.dataCache = cache.data || null;\n      this.key = null;\n      this.secretKey = null;\n      this.tree = null;\n      this.data = null;\n      this.bitfield = null;\n      this.signatures = null;\n      this.create = create;\n    }\n    Storage.prototype.putData = function(index, data, nodes, cb) {\n      if (!cb)\n        cb = noop;\n      var self = this;\n      if (!data.length)\n        return cb(null);\n      this.dataOffset(index, nodes, function(err, offset, size) {\n        if (err)\n          return cb(err);\n        if (size !== data.length)\n          return cb(new Error(\"Unexpected data size\"));\n        self.data.write(offset, data, cb);\n      });\n    };\n    Storage.prototype.getData = function(index, cb) {\n      var self = this;\n      var cached = this.dataCache && this.dataCache.get(index);\n      if (cached)\n        return process.nextTick(cb, null, cached);\n      this.dataOffset(index, noarr, function(err, offset, size) {\n        if (err)\n          return cb(err);\n        self.data.read(offset, size, (err2, data) => {\n          if (err2)\n            return cb(err2);\n          if (self.dataCache)\n            self.dataCache.set(index, data);\n          return cb(null, data);\n        });\n      });\n    };\n    Storage.prototype.nextSignature = function(index, cb) {\n      var self = this;\n      this._getSignature(index, function(err, signature) {\n        if (err)\n          return cb(err);\n        if (isBlank(signature))\n          return self.nextSignature(index + 1, cb);\n        cb(null, { index, signature });\n      });\n    };\n    Storage.prototype.getSignature = function(index, cb) {\n      this._getSignature(index, function(err, signature) {\n        if (err)\n          return cb(err);\n        if (isBlank(signature))\n          return cb(new Error(\"No signature found\"));\n        cb(null, signature);\n      });\n    };\n    Storage.prototype._getSignature = function(index, cb) {\n      this.signatures.read(32 + 64 * index, 64, cb);\n    };\n    Storage.prototype.putSignature = function(index, signature, cb) {\n      this.signatures.write(32 + 64 * index, signature, cb);\n    };\n    Storage.prototype.deleteSignatures = function(start, end, cb) {\n      this.signatures.del(32 + 64 * start, (end - start) * 64, cb);\n    };\n    Storage.prototype.dataOffset = function(index, cachedNodes, cb) {\n      var roots = flat.fullRoots(2 * index);\n      var self = this;\n      var offset = 0;\n      var pending = roots.length;\n      var error = null;\n      var blk = 2 * index;\n      if (!pending) {\n        pending = 1;\n        onnode(null, null);\n        return;\n      }\n      for (var i = 0; i < roots.length; i++) {\n        var node = findNode(cachedNodes, roots[i]);\n        if (node)\n          onnode(null, node);\n        else\n          this.getNode(roots[i], onnode);\n      }\n      function onlast(err, node2) {\n        if (err)\n          return cb(err);\n        cb(null, offset, node2.size);\n      }\n      function onnode(err, node2) {\n        if (err)\n          error = err;\n        if (node2)\n          offset += node2.size;\n        if (--pending)\n          return;\n        if (error)\n          return cb(error);\n        var last = findNode(cachedNodes, blk);\n        if (last)\n          onlast(null, last);\n        else\n          self.getNode(blk, onlast);\n      }\n    };\n    Storage.prototype.getDataBatch = function(start, n, cb) {\n      var result = new Array(n);\n      var sizes = new Array(n);\n      var self = this;\n      this.dataOffset(start, noarr, function(err, offset, size) {\n        if (err)\n          return cb(err);\n        start++;\n        n--;\n        if (n <= 0)\n          return ontree(null, null);\n        self.tree.read(32 + 80 * start, 80 * n - 40, ontree);\n        function ontree(err2, buf) {\n          if (err2)\n            return cb(err2);\n          var total = sizes[0] = size;\n          if (buf) {\n            for (var i = 1; i < sizes.length; i++) {\n              sizes[i] = uint64be.decode(buf, 32 + (i - 1) * 80);\n              total += sizes[i];\n            }\n          }\n          self.data.read(offset, total, ondata);\n        }\n        function ondata(err2, buf) {\n          if (err2)\n            return cb(err2);\n          var total = 0;\n          for (var i = 0; i < result.length; i++) {\n            result[i] = buf.slice(total, total += sizes[i]);\n          }\n          cb(null, result);\n        }\n      });\n    };\n    Storage.prototype.getNode = function(index, cb) {\n      if (this.treeCache) {\n        var cached = this.treeCache.get(index);\n        if (cached)\n          return cb(null, cached);\n      }\n      var self = this;\n      this.tree.read(32 + 40 * index, 40, function(err, buf) {\n        if (err)\n          return cb(err);\n        var hash = buf.slice(0, 32);\n        var size = uint64be.decode(buf, 32);\n        if (!size && isBlank(hash))\n          return cb(new Error(\"No node found\"));\n        var val2 = new Node(index, self.treeCache ? copyMaybe(hash, 40) : hash, size, null);\n        if (self.treeCache)\n          self.treeCache.set(index, val2);\n        cb(null, val2);\n      });\n    };\n    Storage.prototype.putNodeBatch = function(index, nodes, cb) {\n      if (!cb)\n        cb = noop;\n      var buf = Buffer2.alloc(nodes.length * 40);\n      for (var i = 0; i < nodes.length; i++) {\n        var offset = i * 40;\n        var node = nodes[i];\n        if (!node)\n          continue;\n        node.hash.copy(buf, offset);\n        uint64be.encode(node.size, buf, 32 + offset);\n      }\n      this.tree.write(32 + 40 * index, buf, cb);\n    };\n    Storage.prototype.putNode = function(index, node, cb) {\n      if (!cb)\n        cb = noop;\n      var buf = Buffer2.allocUnsafe(40);\n      node.hash.copy(buf, 0);\n      uint64be.encode(node.size, buf, 32);\n      this.tree.write(32 + 40 * index, buf, cb);\n    };\n    Storage.prototype.putBitfield = function(offset, data, cb) {\n      this.bitfield.write(32 + offset, data, cb);\n    };\n    Storage.prototype.close = function(cb) {\n      if (!cb)\n        cb = noop;\n      var missing = 6;\n      var error = null;\n      close(this.bitfield, done);\n      close(this.tree, done);\n      close(this.data, done);\n      close(this.key, done);\n      close(this.secretKey, done);\n      close(this.signatures, done);\n      function done(err) {\n        if (err)\n          error = err;\n        if (--missing)\n          return;\n        cb(error);\n      }\n    };\n    Storage.prototype.destroy = function(cb) {\n      if (!cb)\n        cb = noop;\n      var missing = 6;\n      var error = null;\n      destroy(this.bitfield, done);\n      destroy(this.tree, done);\n      destroy(this.data, done);\n      destroy(this.key, done);\n      destroy(this.secretKey, done);\n      destroy(this.signatures, done);\n      function done(err) {\n        if (err)\n          error = err;\n        if (--missing)\n          return;\n        cb(error);\n      }\n    };\n    Storage.prototype.openKey = function(opts, cb) {\n      if (typeof opts === \"function\")\n        return this.openKey({}, opts);\n      if (!this.key)\n        this.key = this.create(\"key\", opts);\n      this.key.read(0, 32, cb);\n    };\n    Storage.prototype.open = function(opts, cb) {\n      if (typeof opts === \"function\")\n        return this.open({}, opts);\n      var self = this;\n      var error = null;\n      var missing = 5;\n      if (!this.key)\n        this.key = this.create(\"key\", opts);\n      if (!this.secretKey)\n        this.secretKey = this.create(\"secret_key\", opts);\n      if (!this.tree)\n        this.tree = this.create(\"tree\", opts);\n      if (!this.data)\n        this.data = this.create(\"data\", opts);\n      if (!this.bitfield)\n        this.bitfield = this.create(\"bitfield\", opts);\n      if (!this.signatures)\n        this.signatures = this.create(\"signatures\", opts);\n      var result = {\n        bitfield: [],\n        bitfieldPageSize: 3584,\n        // we upgraded the page size to fix a bug\n        secretKey: null,\n        key: null\n      };\n      this.bitfield.read(0, 32, function(err, h) {\n        if (err && err.code === \"ELOCKED\")\n          return cb(err);\n        if (h)\n          result.bitfieldPageSize = h.readUInt16BE(5);\n        self.bitfield.write(0, header(0, result.bitfieldPageSize, null), function(err2) {\n          if (err2)\n            return cb(err2);\n          readAll(self.bitfield, 32, result.bitfieldPageSize, function(err3, pages) {\n            if (pages)\n              result.bitfield = pages;\n            done(err3);\n          });\n        });\n      });\n      this.signatures.write(0, header(1, 64, \"Ed25519\"), done);\n      this.tree.write(0, header(2, 40, \"BLAKE2b\"), done);\n      this.secretKey.read(0, 64, function(_, data) {\n        if (data)\n          result.secretKey = data;\n        done(null);\n      });\n      this.key.read(0, 32, function(_, data) {\n        if (data)\n          result.key = data;\n        done(null);\n      });\n      function done(err) {\n        if (err)\n          error = err;\n        if (--missing)\n          return;\n        if (error)\n          cb(error);\n        else\n          cb(null, result);\n      }\n    };\n    Storage.Node = Node;\n    function noop() {\n    }\n    function copyMaybe(buf, maxSize) {\n      if (buf.buffer.byteLength <= maxSize)\n        return buf;\n      const cpy = Buffer2.alloc(buf.byteLength);\n      buf.copy(cpy);\n      return cpy;\n    }\n    function header(type, size, name) {\n      var buf = Buffer2.alloc(32);\n      buf[0] = 5;\n      buf[1] = 2;\n      buf[2] = 87;\n      buf[3] = type;\n      buf[4] = 0;\n      buf.writeUInt16BE(size, 5);\n      if (name) {\n        buf[7] = name.length;\n        buf.write(name, 8);\n      }\n      return buf;\n    }\n    function Node(index, hash, size) {\n      this.index = index;\n      this.hash = hash;\n      this.size = size;\n    }\n    function findNode(nodes, index) {\n      for (var i = 0; i < nodes.length; i++) {\n        if (nodes[i].index === index)\n          return nodes[i];\n      }\n      return null;\n    }\n    function isBlank(buf) {\n      for (var i = 0; i < buf.length; i++) {\n        if (buf[i])\n          return false;\n      }\n      return true;\n    }\n    function close(st, cb) {\n      if (st.close)\n        st.close(cb);\n      else\n        cb();\n    }\n    function destroy(st, cb) {\n      if (st.destroy)\n        st.destroy(cb);\n      else\n        cb();\n    }\n    function statAndReadAll(st, offset, pageSize, cb) {\n      st.stat(function(err, stat) {\n        if (err)\n          return cb(null, []);\n        var result = [];\n        loop(null, null);\n        function loop(err2, batch) {\n          if (err2)\n            return cb(err2);\n          if (batch) {\n            offset += batch.length;\n            for (var i = 0; i < batch.length; i += pageSize) {\n              result.push(batch.slice(i, i + pageSize));\n            }\n          }\n          var next = Math.min(stat.size - offset, 32 * pageSize);\n          if (!next)\n            return cb(null, result);\n          st.read(offset, next, loop);\n        }\n      });\n    }\n    function readAll(st, offset, pageSize, cb) {\n      if (st.statable === true)\n        return statAndReadAll(st, offset, pageSize, cb);\n      var bufs = [];\n      st.read(offset, pageSize, loop);\n      function loop(err, buf) {\n        if (err)\n          return cb(null, bufs);\n        bufs.push(buf);\n        st.read(offset + bufs.length * pageSize, pageSize, loop);\n      }\n    }\n  }\n});\n\n// node_modules/.pnpm/uint64be@3.0.0/node_modules/uint64be/index.js\nvar require_uint64be2 = __commonJS({\n  \"node_modules/.pnpm/uint64be@3.0.0/node_modules/uint64be/index.js\"(exports) {\n    init_inject_globals();\n    var UINT_32_MAX = Math.pow(2, 32);\n    exports.encodingLength = function() {\n      return 8;\n    };\n    exports.encode = function(num, buf, offset) {\n      if (!buf)\n        buf = Buffer2.allocUnsafe(8);\n      if (!offset)\n        offset = 0;\n      const top = Math.floor(num / UINT_32_MAX);\n      const rem = num - top * UINT_32_MAX;\n      buf.writeUInt32BE(top, offset);\n      buf.writeUInt32BE(rem, offset + 4);\n      return buf;\n    };\n    exports.decode = function(buf, offset) {\n      if (!offset)\n        offset = 0;\n      const top = buf.readUInt32BE(offset);\n      const rem = buf.readUInt32BE(offset + 4);\n      return top * UINT_32_MAX + rem;\n    };\n    exports.encode.bytes = 8;\n    exports.decode.bytes = 8;\n  }\n});\n\n// node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js\nvar require_hypercore_crypto = __commonJS({\n  \"node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js\"(exports) {\n    init_inject_globals();\n    var sodium = import$sodium_universal;\n    var uint64be = require_uint64be2();\n    var LEAF_TYPE = Buffer2.from([0]);\n    var PARENT_TYPE = Buffer2.from([1]);\n    var ROOT_TYPE = Buffer2.from([2]);\n    var CAP_TYPE = Buffer2.from([3]);\n    var HYPERCORE = Buffer2.from(\"hypercore\");\n    var HYPERCORE_CAP = Buffer2.from(\"hypercore capability\");\n    exports.writerCapability = function(key, secretKey, split) {\n      if (!split)\n        return null;\n      const out = Buffer2.allocUnsafe(32);\n      sodium.crypto_generichash_batch(out, [\n        CAP_TYPE,\n        HYPERCORE_CAP,\n        split.tx.slice(0, 32),\n        key\n      ], split.rx.slice(0, 32));\n      return exports.sign(out, secretKey);\n    };\n    exports.verifyRemoteWriterCapability = function(key, cap, split) {\n      if (!split)\n        return null;\n      const out = Buffer2.allocUnsafe(32);\n      sodium.crypto_generichash_batch(out, [\n        CAP_TYPE,\n        HYPERCORE_CAP,\n        split.rx.slice(0, 32),\n        key\n      ], split.tx.slice(0, 32));\n      return exports.verify(out, cap, key);\n    };\n    exports.capability = function(key, split) {\n      if (!split)\n        return null;\n      const out = Buffer2.allocUnsafe(32);\n      sodium.crypto_generichash_batch(out, [\n        HYPERCORE_CAP,\n        split.tx.slice(0, 32),\n        key\n      ], split.rx.slice(0, 32));\n      return out;\n    };\n    exports.remoteCapability = function(key, split) {\n      if (!split)\n        return null;\n      const out = Buffer2.allocUnsafe(32);\n      sodium.crypto_generichash_batch(out, [\n        HYPERCORE_CAP,\n        split.rx.slice(0, 32),\n        key\n      ], split.tx.slice(0, 32));\n      return out;\n    };\n    exports.keyPair = function(seed) {\n      const publicKey = Buffer2.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES);\n      const secretKey = Buffer2.allocUnsafe(sodium.crypto_sign_SECRETKEYBYTES);\n      if (seed)\n        sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed);\n      else\n        sodium.crypto_sign_keypair(publicKey, secretKey);\n      return {\n        publicKey,\n        secretKey\n      };\n    };\n    exports.validateKeyPair = function(keyPair) {\n      const pk = Buffer2.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES);\n      sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey);\n      return pk.equals(keyPair.publicKey);\n    };\n    exports.sign = function(message, secretKey) {\n      const signature = Buffer2.allocUnsafe(sodium.crypto_sign_BYTES);\n      sodium.crypto_sign_detached(signature, message, secretKey);\n      return signature;\n    };\n    exports.verify = function(message, signature, publicKey) {\n      return sodium.crypto_sign_verify_detached(signature, message, publicKey);\n    };\n    exports.data = function(data) {\n      const out = Buffer2.allocUnsafe(32);\n      sodium.crypto_generichash_batch(out, [\n        LEAF_TYPE,\n        encodeUInt64(data.length),\n        data\n      ]);\n      return out;\n    };\n    exports.leaf = function(leaf) {\n      return exports.data(leaf.data);\n    };\n    exports.parent = function(a, b) {\n      if (a.index > b.index) {\n        const tmp = a;\n        a = b;\n        b = tmp;\n      }\n      const out = Buffer2.allocUnsafe(32);\n      sodium.crypto_generichash_batch(out, [\n        PARENT_TYPE,\n        encodeUInt64(a.size + b.size),\n        a.hash,\n        b.hash\n      ]);\n      return out;\n    };\n    exports.tree = function(roots, out) {\n      const buffers = new Array(3 * roots.length + 1);\n      var j = 0;\n      buffers[j++] = ROOT_TYPE;\n      for (var i = 0; i < roots.length; i++) {\n        const r = roots[i];\n        buffers[j++] = r.hash;\n        buffers[j++] = encodeUInt64(r.index);\n        buffers[j++] = encodeUInt64(r.size);\n      }\n      if (!out)\n        out = Buffer2.allocUnsafe(32);\n      sodium.crypto_generichash_batch(out, buffers);\n      return out;\n    };\n    exports.signable = function(roots, length) {\n      const out = Buffer2.allocUnsafe(40);\n      if (Buffer2.isBuffer(roots))\n        roots.copy(out);\n      else\n        exports.tree(roots, out.slice(0, 32));\n      uint64be.encode(length, out.slice(32));\n      return out;\n    };\n    exports.randomBytes = function(n) {\n      const buf = Buffer2.allocUnsafe(n);\n      sodium.randombytes_buf(buf);\n      return buf;\n    };\n    exports.discoveryKey = function(publicKey) {\n      const digest = Buffer2.allocUnsafe(32);\n      sodium.crypto_generichash(digest, HYPERCORE, publicKey);\n      return digest;\n    };\n    if (sodium.sodium_free) {\n      exports.free = function(secureBuf) {\n        if (secureBuf.secure)\n          sodium.sodium_free(secureBuf);\n      };\n    } else {\n      exports.free = function() {\n      };\n    }\n    function encodeUInt64(n) {\n      return uint64be.encode(n, Buffer2.allocUnsafe(8));\n    }\n  }\n});\n\n// node_modules/.pnpm/inspect-custom-symbol@1.1.1/node_modules/inspect-custom-symbol/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/.pnpm/inspect-custom-symbol@1.1.1/node_modules/inspect-custom-symbol/browser.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = Symbol.for(\"nodejs.util.inspect.custom\");\n  }\n});\n\n// node_modules/.pnpm/pretty-hash@1.0.1/node_modules/pretty-hash/index.js\nvar require_pretty_hash = __commonJS({\n  \"node_modules/.pnpm/pretty-hash@1.0.1/node_modules/pretty-hash/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = function prettyHash(buf) {\n      if (Buffer2.isBuffer(buf))\n        buf = buf.toString(\"hex\");\n      if (typeof buf === \"string\" && buf.length > 8) {\n        return buf.slice(0, 6) + \"..\" + buf.slice(-2);\n      }\n      return buf;\n    };\n  }\n});\n\n// node_modules/.pnpm/nanoguard@1.3.0/node_modules/nanoguard/index.js\nvar require_nanoguard = __commonJS({\n  \"node_modules/.pnpm/nanoguard@1.3.0/node_modules/nanoguard/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = class Nanoguard {\n      constructor() {\n        this._tick = 0;\n        this._fns = [];\n        this._dep = null;\n      }\n      get waiting() {\n        return this._tick > 0;\n      }\n      depend(dep) {\n        if (this._dep !== null)\n          throw new Error(\"Can only depend on one other guard currently\");\n        this._dep = dep;\n      }\n      wait() {\n        this._tick++;\n      }\n      continue(cb, err, val2) {\n        if (this._tick === 1)\n          process.nextTick(continueNT, this);\n        else\n          this._tick--;\n        if (cb)\n          cb(err, val2);\n      }\n      waitAndContinue() {\n        let once = false;\n        this.wait();\n        return () => {\n          if (once)\n            return false;\n          once = true;\n          this.continue();\n          return true;\n        };\n      }\n      continueSync(cb, err, val2) {\n        if (--this._tick)\n          return;\n        while (this._fns !== null && this._fns.length)\n          this._ready(this._fns.pop());\n        if (cb)\n          cb(err, val2);\n      }\n      destroy() {\n        const fns = this._fns;\n        if (fns)\n          return;\n        this._fns = null;\n        while (fns.length)\n          fns.pop()();\n      }\n      ready(fn) {\n        if (this._fns === null || this._tick === 0)\n          this._ready(fn);\n        else\n          this._fns.push(fn);\n      }\n      _ready(fn) {\n        if (this._dep === null)\n          fn();\n        else\n          this._dep.ready(fn);\n      }\n    };\n    function continueNT(guard) {\n      guard.continueSync();\n    }\n  }\n});\n\n// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/safe-buffer-equals.js\nvar require_safe_buffer_equals = __commonJS({\n  \"node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/safe-buffer-equals.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = function safeBufferEquals(a, b) {\n      if (!a)\n        return !b;\n      if (!b)\n        return !a;\n      return Buffer2.compare(a, b) === 0;\n    };\n  }\n});\n\n// node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js\nvar require_nanoassert = __commonJS({\n  \"node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = assert;\n    var AssertionError = class extends Error {\n    };\n    AssertionError.prototype.name = \"AssertionError\";\n    function assert(t, m) {\n      if (!t) {\n        var err = new AssertionError(m);\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(err, assert);\n        throw err;\n      }\n    }\n  }\n});\n\n// node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js\nvar require_clone = __commonJS({\n  \"node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js\"(exports, module) {\n    init_inject_globals();\n    var clone = function() {\n      \"use strict\";\n      function _instanceof(obj, type) {\n        return type != null && obj instanceof type;\n      }\n      var nativeMap;\n      try {\n        nativeMap = Map;\n      } catch (_) {\n        nativeMap = function() {\n        };\n      }\n      var nativeSet;\n      try {\n        nativeSet = Set;\n      } catch (_) {\n        nativeSet = function() {\n        };\n      }\n      var nativePromise;\n      try {\n        nativePromise = Promise;\n      } catch (_) {\n        nativePromise = function() {\n        };\n      }\n      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {\n        if (typeof circular === \"object\") {\n          depth = circular.depth;\n          prototype = circular.prototype;\n          includeNonEnumerable = circular.includeNonEnumerable;\n          circular = circular.circular;\n        }\n        var allParents = [];\n        var allChildren = [];\n        var useBuffer = typeof Buffer2 != \"undefined\";\n        if (typeof circular == \"undefined\")\n          circular = true;\n        if (typeof depth == \"undefined\")\n          depth = Infinity;\n        function _clone(parent2, depth2) {\n          if (parent2 === null)\n            return null;\n          if (depth2 === 0)\n            return parent2;\n          var child;\n          var proto;\n          if (typeof parent2 != \"object\") {\n            return parent2;\n          }\n          if (_instanceof(parent2, nativeMap)) {\n            child = new nativeMap();\n          } else if (_instanceof(parent2, nativeSet)) {\n            child = new nativeSet();\n          } else if (_instanceof(parent2, nativePromise)) {\n            child = new nativePromise(function(resolve, reject) {\n              parent2.then(function(value) {\n                resolve(_clone(value, depth2 - 1));\n              }, function(err) {\n                reject(_clone(err, depth2 - 1));\n              });\n            });\n          } else if (clone2.__isArray(parent2)) {\n            child = [];\n          } else if (clone2.__isRegExp(parent2)) {\n            child = new RegExp(parent2.source, __getRegExpFlags(parent2));\n            if (parent2.lastIndex)\n              child.lastIndex = parent2.lastIndex;\n          } else if (clone2.__isDate(parent2)) {\n            child = new Date(parent2.getTime());\n          } else if (useBuffer && Buffer2.isBuffer(parent2)) {\n            if (Buffer2.allocUnsafe) {\n              child = Buffer2.allocUnsafe(parent2.length);\n            } else {\n              child = new Buffer2(parent2.length);\n            }\n            parent2.copy(child);\n            return child;\n          } else if (_instanceof(parent2, Error)) {\n            child = Object.create(parent2);\n          } else {\n            if (typeof prototype == \"undefined\") {\n              proto = Object.getPrototypeOf(parent2);\n              child = Object.create(proto);\n            } else {\n              child = Object.create(prototype);\n              proto = prototype;\n            }\n          }\n          if (circular) {\n            var index = allParents.indexOf(parent2);\n            if (index != -1) {\n              return allChildren[index];\n            }\n            allParents.push(parent2);\n            allChildren.push(child);\n          }\n          if (_instanceof(parent2, nativeMap)) {\n            parent2.forEach(function(value, key) {\n              var keyChild = _clone(key, depth2 - 1);\n              var valueChild = _clone(value, depth2 - 1);\n              child.set(keyChild, valueChild);\n            });\n          }\n          if (_instanceof(parent2, nativeSet)) {\n            parent2.forEach(function(value) {\n              var entryChild = _clone(value, depth2 - 1);\n              child.add(entryChild);\n            });\n          }\n          for (var i in parent2) {\n            var attrs;\n            if (proto) {\n              attrs = Object.getOwnPropertyDescriptor(proto, i);\n            }\n            if (attrs && attrs.set == null) {\n              continue;\n            }\n            child[i] = _clone(parent2[i], depth2 - 1);\n          }\n          if (Object.getOwnPropertySymbols) {\n            var symbols = Object.getOwnPropertySymbols(parent2);\n            for (var i = 0; i < symbols.length; i++) {\n              var symbol = symbols[i];\n              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);\n              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n                continue;\n              }\n              child[symbol] = _clone(parent2[symbol], depth2 - 1);\n              if (!descriptor.enumerable) {\n                Object.defineProperty(child, symbol, {\n                  enumerable: false\n                });\n              }\n            }\n          }\n          if (includeNonEnumerable) {\n            var allPropertyNames = Object.getOwnPropertyNames(parent2);\n            for (var i = 0; i < allPropertyNames.length; i++) {\n              var propertyName = allPropertyNames[i];\n              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);\n              if (descriptor && descriptor.enumerable) {\n                continue;\n              }\n              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);\n              Object.defineProperty(child, propertyName, {\n                enumerable: false\n              });\n            }\n          }\n          return child;\n        }\n        return _clone(parent, depth);\n      }\n      clone2.clonePrototype = function clonePrototype(parent) {\n        if (parent === null)\n          return null;\n        var c = function() {\n        };\n        c.prototype = parent;\n        return new c();\n      };\n      function __objToStr(o) {\n        return Object.prototype.toString.call(o);\n      }\n      clone2.__objToStr = __objToStr;\n      function __isDate(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Date]\";\n      }\n      clone2.__isDate = __isDate;\n      function __isArray(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Array]\";\n      }\n      clone2.__isArray = __isArray;\n      function __isRegExp(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object RegExp]\";\n      }\n      clone2.__isRegExp = __isRegExp;\n      function __getRegExpFlags(re) {\n        var flags = \"\";\n        if (re.global)\n          flags += \"g\";\n        if (re.ignoreCase)\n          flags += \"i\";\n        if (re.multiline)\n          flags += \"m\";\n        return flags;\n      }\n      clone2.__getRegExpFlags = __getRegExpFlags;\n      return clone2;\n    }();\n    if (typeof module === \"object\" && module.exports) {\n      module.exports = clone;\n    }\n  }\n});\n\n// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher.js\nvar require_cipher = __commonJS({\n  \"node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher.js\"(exports, module) {\n    init_inject_globals();\n    var { sodium_malloc, sodium_memzero } = import$sodium_universal_memory;\n    var {\n      crypto_aead_chacha20poly1305_ietf_KEYBYTES,\n      crypto_aead_chacha20poly1305_ietf_NPUBBYTES,\n      crypto_aead_chacha20poly1305_ietf_ABYTES,\n      crypto_aead_chacha20poly1305_ietf_encrypt,\n      crypto_aead_chacha20poly1305_ietf_decrypt\n    } = import$sodium_universal_crypto_aead;\n    var assert = require_nanoassert();\n    var KEYLEN = 32;\n    var NONCELEN = 8;\n    var MACLEN = 16;\n    assert(crypto_aead_chacha20poly1305_ietf_KEYBYTES === KEYLEN);\n    assert(crypto_aead_chacha20poly1305_ietf_NPUBBYTES === 4 + NONCELEN);\n    assert(crypto_aead_chacha20poly1305_ietf_ABYTES === MACLEN);\n    module.exports = {\n      KEYLEN,\n      NONCELEN,\n      MACLEN,\n      encrypt,\n      decrypt,\n      rekey\n    };\n    var ElongatedNonce = sodium_malloc(crypto_aead_chacha20poly1305_ietf_NPUBBYTES);\n    function encrypt(out, k, n, ad, plaintext) {\n      assert(out.byteLength >= plaintext.byteLength + MACLEN, \"output buffer must be at least plaintext plus MACLEN bytes long\");\n      assert(k.byteLength === KEYLEN);\n      assert(n.byteLength === NONCELEN);\n      assert(ad == null ? true : ad.byteLength != null);\n      sodium_memzero(ElongatedNonce);\n      ElongatedNonce.set(n, 4);\n      encrypt.bytesWritten = crypto_aead_chacha20poly1305_ietf_encrypt(out.subarray(0, plaintext.byteLength + MACLEN), plaintext, ad, null, ElongatedNonce, k);\n      encrypt.bytesRead = encrypt.bytesWritten - MACLEN;\n      sodium_memzero(ElongatedNonce);\n    }\n    encrypt.bytesWritten = 0;\n    encrypt.bytesRead = 0;\n    function decrypt(out, k, n, ad, ciphertext) {\n      assert(out.byteLength >= ciphertext.byteLength - MACLEN);\n      assert(k.byteLength === KEYLEN);\n      assert(n.byteLength === NONCELEN);\n      assert(ad == null ? true : ad.byteLength != null);\n      sodium_memzero(ElongatedNonce);\n      ElongatedNonce.set(n, 4);\n      decrypt.bytesWritten = crypto_aead_chacha20poly1305_ietf_decrypt(out.subarray(0, ciphertext.byteLength - MACLEN), null, ciphertext, ad, ElongatedNonce, k);\n      decrypt.bytesRead = decrypt.bytesWritten + MACLEN;\n      sodium_memzero(ElongatedNonce);\n    }\n    decrypt.bytesWritten = 0;\n    decrypt.bytesRead = 0;\n    var maxnonce = new Uint8Array(8).fill(255);\n    var zerolen = new Uint8Array(0);\n    var zeros = new Uint8Array(32);\n    var IntermediateKey = sodium_malloc(KEYLEN + MACLEN);\n    sodium_memzero(IntermediateKey);\n    function rekey(out, k) {\n      assert(out.byteLength === KEYLEN);\n      assert(k.byteLength === KEYLEN);\n      sodium_memzero(IntermediateKey);\n      IntermediateKey.set(k);\n      encrypt(IntermediateKey, k, maxnonce, zerolen, zeros);\n      rekey.bytesWritten = encrypt.bytesWritten;\n      rekey.bytesRead = encrypt.bytesRead;\n      out.set(IntermediateKey.subarray(0, KEYLEN));\n      sodium_memzero(IntermediateKey);\n    }\n    rekey.bytesWritten = 0;\n    rekey.bytesRead = 0;\n  }\n});\n\n// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher-state.js\nvar require_cipher_state = __commonJS({\n  \"node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher-state.js\"(exports, module) {\n    init_inject_globals();\n    var { sodium_memzero } = import$sodium_universal_memory;\n    var { sodium_increment, sodium_memcmp, sodium_is_zero } = import$sodium_universal_helpers;\n    var assert = require_nanoassert();\n    var cipher = require_cipher();\n    var STATELEN = cipher.KEYLEN + cipher.NONCELEN;\n    var NONCELEN = cipher.NONCELEN;\n    var MACLEN = cipher.MACLEN;\n    module.exports = {\n      STATELEN,\n      NONCELEN,\n      MACLEN,\n      initializeKey,\n      hasKey,\n      setNonce,\n      encryptWithAd,\n      decryptWithAd,\n      rekey\n    };\n    var KEY_BEGIN = 0;\n    var KEY_END = cipher.KEYLEN;\n    var NONCE_BEGIN = KEY_END;\n    var NONCE_END = NONCE_BEGIN + cipher.NONCELEN;\n    function initializeKey(state, key) {\n      assert(state.byteLength === STATELEN);\n      assert(key == null ? true : key.byteLength === cipher.KEYLEN);\n      if (key == null) {\n        sodium_memzero(state.subarray(KEY_BEGIN, KEY_END));\n        return;\n      }\n      state.set(key);\n      sodium_memzero(state.subarray(NONCE_BEGIN, NONCE_END));\n    }\n    function hasKey(state) {\n      assert(state.byteLength === STATELEN);\n      var k = state.subarray(KEY_BEGIN, KEY_END);\n      return sodium_is_zero(k) === false;\n    }\n    function setNonce(state, nonce) {\n      assert(state.byteLength === STATELEN);\n      assert(nonce.byteLength === NONCELEN);\n      state.set(nonce, NONCE_BEGIN);\n    }\n    var maxnonce = new Uint8Array(8).fill(255);\n    function encryptWithAd(state, out, ad, plaintext) {\n      assert(state.byteLength === STATELEN);\n      assert(out.byteLength != null);\n      assert(plaintext.byteLength != null);\n      var n = state.subarray(NONCE_BEGIN, NONCE_END);\n      if (sodium_memcmp(n, maxnonce))\n        throw new Error(\"Nonce overflow\");\n      if (hasKey(state) === false) {\n        out.set(plaintext);\n        encryptWithAd.bytesRead = plaintext.byteLength;\n        encryptWithAd.bytesWritten = encryptWithAd.bytesRead;\n        return;\n      }\n      var k = state.subarray(KEY_BEGIN, KEY_END);\n      cipher.encrypt(\n        out,\n        k,\n        n,\n        ad,\n        plaintext\n      );\n      encryptWithAd.bytesRead = cipher.encrypt.bytesRead;\n      encryptWithAd.bytesWritten = cipher.encrypt.bytesWritten;\n      sodium_increment(n);\n    }\n    encryptWithAd.bytesRead = 0;\n    encryptWithAd.bytesWritten = 0;\n    function decryptWithAd(state, out, ad, ciphertext) {\n      assert(state.byteLength === STATELEN);\n      assert(out.byteLength != null);\n      assert(ciphertext.byteLength != null);\n      var n = state.subarray(NONCE_BEGIN, NONCE_END);\n      if (sodium_memcmp(n, maxnonce))\n        throw new Error(\"Nonce overflow\");\n      if (hasKey(state) === false) {\n        out.set(ciphertext);\n        decryptWithAd.bytesRead = ciphertext.byteLength;\n        decryptWithAd.bytesWritten = decryptWithAd.bytesRead;\n        return;\n      }\n      var k = state.subarray(KEY_BEGIN, KEY_END);\n      cipher.decrypt(\n        out,\n        k,\n        n,\n        ad,\n        ciphertext\n      );\n      decryptWithAd.bytesRead = cipher.decrypt.bytesRead;\n      decryptWithAd.bytesWritten = cipher.decrypt.bytesWritten;\n      sodium_increment(n);\n    }\n    decryptWithAd.bytesRead = 0;\n    decryptWithAd.bytesWritten = 0;\n    function rekey(state) {\n      assert(state.byteLength === STATELEN);\n      var k = state.subarray(KEY_BEGIN, KEY_END);\n      cipher.rekey(k, k);\n      rekey.bytesRead = cipher.rekey.bytesRead;\n      rekey.bytesWritten = cipher.rekey.bytesWritten;\n    }\n    rekey.bytesRead = 0;\n    rekey.bytesWritten = 0;\n  }\n});\n\n// node_modules/.pnpm/nanoassert@1.1.0/node_modules/nanoassert/index.js\nvar require_nanoassert2 = __commonJS({\n  \"node_modules/.pnpm/nanoassert@1.1.0/node_modules/nanoassert/index.js\"(exports, module) {\n    init_inject_globals();\n    assert.notEqual = notEqual;\n    assert.notOk = notOk;\n    assert.equal = equal;\n    assert.ok = assert;\n    module.exports = assert;\n    function equal(a, b, m) {\n      assert(a == b, m);\n    }\n    function notEqual(a, b, m) {\n      assert(a != b, m);\n    }\n    function notOk(t, m) {\n      assert(!t, m);\n    }\n    function assert(t, m) {\n      if (!t)\n        throw new Error(m || \"AssertionError\");\n    }\n  }\n});\n\n// node_modules/.pnpm/hmac-blake2b@2.0.0/node_modules/hmac-blake2b/index.js\nvar require_hmac_blake2b = __commonJS({\n  \"node_modules/.pnpm/hmac-blake2b@2.0.0/node_modules/hmac-blake2b/index.js\"(exports, module) {\n    init_inject_globals();\n    var { sodium_malloc, sodium_memzero } = import$sodium_universal_memory;\n    var { crypto_generichash, crypto_generichash_batch } = import$sodium_universal_crypto_generichash;\n    var assert = require_nanoassert2();\n    var HASHLEN = 64;\n    var BLOCKLEN = 128;\n    var scratch = sodium_malloc(BLOCKLEN * 3);\n    var HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1);\n    var OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2);\n    var InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3);\n    module.exports = function hmac(out, data, key) {\n      assert(out.byteLength === HASHLEN);\n      assert(key.byteLength != null);\n      assert(Array.isArray(data) ? data.every((d) => d.byteLength != null) : data.byteLength != null);\n      if (key.byteLength > BLOCKLEN) {\n        crypto_generichash(HMACKey.subarray(0, HASHLEN), key);\n        sodium_memzero(HMACKey.subarray(HASHLEN));\n      } else {\n        HMACKey.set(key);\n        sodium_memzero(HMACKey.subarray(key.byteLength));\n      }\n      for (var i = 0; i < HMACKey.byteLength; i++) {\n        OuterKeyPad[i] = 92 ^ HMACKey[i];\n        InnerKeyPad[i] = 54 ^ HMACKey[i];\n      }\n      sodium_memzero(HMACKey);\n      crypto_generichash_batch(out, [InnerKeyPad].concat(data));\n      sodium_memzero(InnerKeyPad);\n      crypto_generichash_batch(out, [OuterKeyPad].concat(out));\n      sodium_memzero(OuterKeyPad);\n    };\n    module.exports.BYTES = HASHLEN;\n    module.exports.KEYBYTES = BLOCKLEN;\n  }\n});\n\n// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/dh.js\nvar require_dh = __commonJS({\n  \"node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/dh.js\"(exports, module) {\n    init_inject_globals();\n    var { crypto_kx_SEEDBYTES, crypto_kx_keypair, crypto_kx_seed_keypair } = import$sodium_universal_crypto_kx;\n    var { crypto_scalarmult_BYTES, crypto_scalarmult_SCALARBYTES, crypto_scalarmult } = import$sodium_universal_crypto_scalarmult;\n    var assert = require_nanoassert();\n    var DHLEN = crypto_scalarmult_BYTES;\n    var PKLEN = crypto_scalarmult_BYTES;\n    var SKLEN = crypto_scalarmult_SCALARBYTES;\n    var SEEDLEN = crypto_kx_SEEDBYTES;\n    module.exports = {\n      DHLEN,\n      PKLEN,\n      SKLEN,\n      SEEDLEN,\n      generateKeypair,\n      generateSeedKeypair,\n      dh\n    };\n    function generateKeypair(pk, sk) {\n      assert(pk.byteLength === PKLEN);\n      assert(sk.byteLength === SKLEN);\n      crypto_kx_keypair(pk, sk);\n    }\n    function generateSeedKeypair(pk, sk, seed) {\n      assert(pk.byteLength === PKLEN);\n      assert(sk.byteLength === SKLEN);\n      assert(seed.byteLength === SKLEN);\n      crypto_kx_seed_keypair(pk, sk, seed);\n    }\n    function dh(output, lsk, pk) {\n      assert(output.byteLength === DHLEN);\n      assert(lsk.byteLength === SKLEN);\n      assert(pk.byteLength === PKLEN);\n      crypto_scalarmult(\n        output,\n        lsk,\n        pk\n      );\n    }\n  }\n});\n\n// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/hash.js\nvar require_hash = __commonJS({\n  \"node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/hash.js\"(exports, module) {\n    init_inject_globals();\n    var { sodium_malloc, sodium_memzero } = import$sodium_universal_memory;\n    var { crypto_generichash_batch } = import$sodium_universal_crypto_generichash;\n    var assert = require_nanoassert();\n    var hmacBlake2b = require_hmac_blake2b();\n    var dh = require_dh();\n    var HASHLEN = 64;\n    var BLOCKLEN = 128;\n    assert(hmacBlake2b.KEYBYTES === BLOCKLEN, \"mismatching hmac BLOCKLEN\");\n    assert(hmacBlake2b.BYTES === HASHLEN, \"mismatching hmac HASHLEN\");\n    module.exports = {\n      HASHLEN,\n      BLOCKLEN,\n      hash,\n      hkdf\n    };\n    function hash(out, data) {\n      assert(out.byteLength === HASHLEN);\n      assert(Array.isArray(data));\n      crypto_generichash_batch(out, data);\n    }\n    function hmac(out, key, data) {\n      return hmacBlake2b(out, data, key);\n    }\n    var TempKey = sodium_malloc(HASHLEN);\n    var Byte0x01 = new Uint8Array([1]);\n    var Byte0x02 = new Uint8Array([2]);\n    var Byte0x03 = new Uint8Array([3]);\n    function hkdf(out1, out2, out3, chainingKey, inputKeyMaterial) {\n      assert(out1.byteLength === HASHLEN);\n      assert(out2.byteLength === HASHLEN);\n      assert(out3 == null ? true : out3.byteLength === HASHLEN);\n      assert(chainingKey.byteLength === HASHLEN);\n      assert([0, 32, dh.DHLEN, dh.PKLEN].includes(inputKeyMaterial.byteLength));\n      sodium_memzero(TempKey);\n      hmac(TempKey, chainingKey, [inputKeyMaterial]);\n      hmac(out1, TempKey, [Byte0x01]);\n      hmac(out2, TempKey, [out1, Byte0x02]);\n      if (out3 != null) {\n        hmac(out3, TempKey, [out2, Byte0x03]);\n      }\n      sodium_memzero(TempKey);\n    }\n  }\n});\n\n// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/symmetric-state.js\nvar require_symmetric_state = __commonJS({\n  \"node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/symmetric-state.js\"(exports, module) {\n    init_inject_globals();\n    var { sodium_malloc, sodium_memzero } = import$sodium_universal_memory;\n    var assert = require_nanoassert();\n    var cipherState = require_cipher_state();\n    var hash = require_hash();\n    var STATELEN = hash.HASHLEN + hash.HASHLEN + cipherState.STATELEN;\n    var HASHLEN = hash.HASHLEN;\n    module.exports = {\n      STATELEN,\n      initializeSymmetric,\n      mixKey,\n      mixHash,\n      mixKeyAndHash,\n      getHandshakeHash,\n      encryptAndHash,\n      decryptAndHash,\n      split,\n      _hasKey\n    };\n    var CHAINING_KEY_BEGIN = 0;\n    var CHAINING_KEY_END = hash.HASHLEN;\n    var HASH_BEGIN = CHAINING_KEY_END;\n    var HASH_END = HASH_BEGIN + hash.HASHLEN;\n    var CIPHER_BEGIN = HASH_END;\n    var CIPHER_END = CIPHER_BEGIN + cipherState.STATELEN;\n    function initializeSymmetric(state, protocolName) {\n      assert(state.byteLength === STATELEN);\n      assert(protocolName.byteLength != null);\n      sodium_memzero(state);\n      if (protocolName.byteLength <= HASHLEN)\n        state.set(protocolName, HASH_BEGIN);\n      else\n        hash.hash(state.subarray(HASH_BEGIN, HASH_END), [protocolName]);\n      state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END).set(state.subarray(HASH_BEGIN, HASH_END));\n      cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), null);\n    }\n    var TempKey = sodium_malloc(HASHLEN);\n    function mixKey(state, inputKeyMaterial) {\n      assert(state.byteLength === STATELEN);\n      assert(inputKeyMaterial.byteLength != null);\n      hash.hkdf(\n        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),\n        TempKey,\n        null,\n        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),\n        inputKeyMaterial\n      );\n      cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), TempKey.subarray(0, 32));\n      sodium_memzero(TempKey);\n    }\n    function mixHash(state, data) {\n      assert(state.byteLength === STATELEN);\n      var h = state.subarray(HASH_BEGIN, HASH_END);\n      hash.hash(h, [h, data]);\n    }\n    var TempHash = sodium_malloc(HASHLEN);\n    function mixKeyAndHash(state, inputKeyMaterial) {\n      assert(state.byteLength === STATELEN);\n      assert(inputKeyMaterial.byteLength != null);\n      hash.hkdf(\n        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),\n        TempHash,\n        TempKey,\n        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),\n        inputKeyMaterial\n      );\n      mixHash(state, TempHash);\n      sodium_memzero(TempHash);\n      cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), TempKey.subarray(0, 32));\n      sodium_memzero(TempKey);\n    }\n    function getHandshakeHash(state, out) {\n      assert(state.byteLength === STATELEN);\n      assert(out.byteLength === HASHLEN);\n      out.set(state.subarray(HASH_BEGIN, HASH_END));\n    }\n    function encryptAndHash(state, ciphertext, plaintext) {\n      assert(state.byteLength === STATELEN);\n      assert(ciphertext.byteLength != null);\n      assert(plaintext.byteLength != null);\n      var cstate = state.subarray(CIPHER_BEGIN, CIPHER_END);\n      var h = state.subarray(HASH_BEGIN, HASH_END);\n      cipherState.encryptWithAd(cstate, ciphertext, h, plaintext);\n      encryptAndHash.bytesRead = cipherState.encryptWithAd.bytesRead;\n      encryptAndHash.bytesWritten = cipherState.encryptWithAd.bytesWritten;\n      mixHash(state, ciphertext.subarray(0, encryptAndHash.bytesWritten));\n    }\n    encryptAndHash.bytesRead = 0;\n    encryptAndHash.bytesWritten = 0;\n    function decryptAndHash(state, plaintext, ciphertext) {\n      assert(state.byteLength === STATELEN);\n      assert(plaintext.byteLength != null);\n      assert(ciphertext.byteLength != null);\n      var cstate = state.subarray(CIPHER_BEGIN, CIPHER_END);\n      var h = state.subarray(HASH_BEGIN, HASH_END);\n      cipherState.decryptWithAd(cstate, plaintext, h, ciphertext);\n      decryptAndHash.bytesRead = cipherState.decryptWithAd.bytesRead;\n      decryptAndHash.bytesWritten = cipherState.decryptWithAd.bytesWritten;\n      mixHash(state, ciphertext.subarray(0, decryptAndHash.bytesRead));\n    }\n    decryptAndHash.bytesRead = 0;\n    decryptAndHash.bytesWritten = 0;\n    var TempKey1 = sodium_malloc(HASHLEN);\n    var TempKey2 = sodium_malloc(HASHLEN);\n    var zerolen = new Uint8Array(0);\n    function split(state, cipherstate1, cipherstate2) {\n      assert(state.byteLength === STATELEN);\n      assert(cipherstate1.byteLength === cipherState.STATELEN);\n      assert(cipherstate2.byteLength === cipherState.STATELEN);\n      hash.hkdf(\n        TempKey1,\n        TempKey2,\n        null,\n        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),\n        zerolen\n      );\n      cipherState.initializeKey(cipherstate1, TempKey1.subarray(0, 32));\n      cipherState.initializeKey(cipherstate2, TempKey2.subarray(0, 32));\n      sodium_memzero(TempKey1);\n      sodium_memzero(TempKey2);\n    }\n    function _hasKey(state) {\n      return cipherState.hasKey(state.subarray(CIPHER_BEGIN, CIPHER_END));\n    }\n  }\n});\n\n// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/handshake-state.js\nvar require_handshake_state = __commonJS({\n  \"node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/handshake-state.js\"(exports, module) {\n    init_inject_globals();\n    var { sodium_malloc, sodium_memzero, sodium_free } = import$sodium_universal_memory;\n    var assert = require_nanoassert();\n    var clone = require_clone();\n    var symmetricState = require_symmetric_state();\n    var cipherState = require_cipher_state();\n    var dh = require_dh();\n    var PKLEN = dh.PKLEN;\n    var SKLEN = dh.SKLEN;\n    module.exports = Object.freeze({\n      initialize,\n      writeMessage,\n      readMessage,\n      destroy,\n      keygen,\n      seedKeygen,\n      SKLEN,\n      PKLEN\n    });\n    function HandshakeState() {\n      this.symmetricState = sodium_malloc(symmetricState.STATELEN);\n      this.initiator = null;\n      this.spk = null;\n      this.ssk = null;\n      this.epk = null;\n      this.esk = null;\n      this.rs = null;\n      this.re = null;\n      this.messagePatterns = null;\n    }\n    var INITIATOR = Symbol(\"initiator\");\n    var RESPONDER = Symbol(\"responder\");\n    var TOK_S = Symbol(\"s\");\n    var TOK_E = Symbol(\"e\");\n    var TOK_ES = Symbol(\"es\");\n    var TOK_SE = Symbol(\"se\");\n    var TOK_EE = Symbol(\"ee\");\n    var TOK_SS = Symbol(\"es\");\n    var PATTERNS = Object.freeze({\n      N: {\n        premessages: [\n          [RESPONDER, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_ES]\n        ]\n      },\n      K: {\n        premessages: [\n          [INITIATOR, TOK_S],\n          [RESPONDER, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_ES, TOK_SS]\n        ]\n      },\n      X: {\n        premessages: [\n          [RESPONDER, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_ES, TOK_S, TOK_SS]\n        ]\n      },\n      NN: {\n        premessages: [],\n        messagePatterns: [\n          [INITIATOR, TOK_E],\n          [RESPONDER, TOK_E, TOK_EE]\n        ]\n      },\n      KN: {\n        premessages: [\n          [INITIATOR, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E],\n          [RESPONDER, TOK_E, TOK_EE, TOK_SE]\n        ]\n      },\n      NK: {\n        premessages: [\n          [RESPONDER, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_ES],\n          [RESPONDER, TOK_E, TOK_EE]\n        ]\n      },\n      KK: {\n        premessages: [\n          [INITIATOR, TOK_S],\n          [RESPONDER, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_ES, TOK_SS],\n          [RESPONDER, TOK_E, TOK_EE, TOK_SE]\n        ]\n      },\n      NX: {\n        premessages: [],\n        messagePatterns: [\n          [INITIATOR, TOK_E],\n          [RESPONDER, TOK_E, TOK_EE, TOK_S, TOK_ES]\n        ]\n      },\n      KX: {\n        premessages: [\n          [INITIATOR, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E],\n          [RESPONDER, TOK_E, TOK_EE, TOK_SE, TOK_S, TOK_ES]\n        ]\n      },\n      XN: {\n        premessages: [],\n        messagePatterns: [\n          [INITIATOR, TOK_E],\n          [RESPONDER, TOK_E, TOK_EE],\n          [INITIATOR, TOK_S, TOK_SE]\n        ]\n      },\n      IN: {\n        premessages: [],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_S],\n          [RESPONDER, TOK_E, TOK_EE, TOK_SE]\n        ]\n      },\n      XK: {\n        premessages: [\n          [RESPONDER, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_ES],\n          [RESPONDER, TOK_E, TOK_EE],\n          [INITIATOR, TOK_S, TOK_SE]\n        ]\n      },\n      IK: {\n        premessages: [\n          [RESPONDER, TOK_S]\n        ],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_ES, TOK_S, TOK_SS],\n          [RESPONDER, TOK_E, TOK_EE, TOK_SE]\n        ]\n      },\n      XX: {\n        premessages: [],\n        messagePatterns: [\n          [INITIATOR, TOK_E],\n          [RESPONDER, TOK_E, TOK_EE, TOK_S, TOK_ES],\n          [INITIATOR, TOK_S, TOK_SE]\n        ]\n      },\n      IX: {\n        premessages: [],\n        messagePatterns: [\n          [INITIATOR, TOK_E, TOK_S],\n          [RESPONDER, TOK_E, TOK_EE, TOK_SE, TOK_S, TOK_ES]\n        ]\n      }\n    });\n    function sodiumBufferCopy(src) {\n      var buf = sodium_malloc(src.byteLength);\n      buf.set(src);\n      return buf;\n    }\n    function initialize(handshakePattern, initiator, prologue, s, e, rs, re) {\n      assert(Object.keys(PATTERNS).includes(handshakePattern), \"Unsupported handshake pattern\");\n      assert(typeof initiator === \"boolean\", \"Initiator must be a boolean\");\n      assert(prologue.byteLength != null, \"prolouge must be a Buffer\");\n      assert(e == null ? true : e.publicKey.byteLength === dh.PKLEN, `e.publicKey must be ${dh.PKLEN} bytes`);\n      assert(e == null ? true : e.secretKey.byteLength === dh.SKLEN, `e.secretKey must be ${dh.SKLEN} bytes`);\n      assert(rs == null ? true : rs.byteLength === dh.PKLEN, `rs must be ${dh.PKLEN} bytes`);\n      assert(re == null ? true : re.byteLength === dh.PKLEN, `re must be ${dh.PKLEN} bytes`);\n      var state = new HandshakeState();\n      var protocolName = Uint8Array.from(`Noise_${handshakePattern}_25519_ChaChaPoly_BLAKE2b`, toCharCode);\n      symmetricState.initializeSymmetric(state.symmetricState, protocolName);\n      symmetricState.mixHash(state.symmetricState, prologue);\n      state.role = initiator === true ? INITIATOR : RESPONDER;\n      if (s != null) {\n        assert(s.publicKey.byteLength === dh.PKLEN, `s.publicKey must be ${dh.PKLEN} bytes`);\n        assert(s.secretKey.byteLength === dh.SKLEN, `s.secretKey must be ${dh.SKLEN} bytes`);\n        state.spk = sodiumBufferCopy(s.publicKey);\n        state.ssk = sodiumBufferCopy(s.secretKey);\n      }\n      if (e != null) {\n        assert(e.publicKey.byteLength === dh.PKLEN);\n        assert(e.secretKey.byteLength === dh.SKLEN);\n        state.epk = sodiumBufferCopy(e.publicKey);\n        state.esk = sodiumBufferCopy(e.secretKey);\n      }\n      if (rs != null) {\n        assert(rs.byteLength === dh.PKLEN);\n        state.rs = sodiumBufferCopy(rs);\n      }\n      if (re != null) {\n        assert(re.byteLength === dh.PKLEN);\n        state.re = sodiumBufferCopy(re);\n      }\n      var pat = PATTERNS[handshakePattern];\n      for (var pattern of clone(pat.premessages)) {\n        var patternRole = pattern.shift();\n        for (var token of pattern) {\n          switch (token) {\n            case TOK_E:\n              assert(state.role === patternRole ? state.epk.byteLength != null : state.re.byteLength != null);\n              symmetricState.mixHash(state.symmetricState, state.role === patternRole ? state.epk : state.re);\n              break;\n            case TOK_S:\n              assert(state.role === patternRole ? state.spk.byteLength != null : state.rs.byteLength != null);\n              symmetricState.mixHash(state.symmetricState, state.role === patternRole ? state.spk : state.rs);\n              break;\n            default:\n              throw new Error(\"Invalid premessage pattern\");\n          }\n        }\n      }\n      state.messagePatterns = clone(pat.messagePatterns);\n      assert(\n        state.messagePatterns.filter((p) => p[0] === INITIATOR).some((p) => p.includes(TOK_S)) ? state.spk !== null && state.ssk !== null : true,\n        // Default if none is found\n        \"This handshake pattern requires a static keypair\"\n      );\n      return state;\n    }\n    var DhResult = sodium_malloc(dh.DHLEN);\n    function writeMessage(state, payload, messageBuffer) {\n      assert(state instanceof HandshakeState);\n      assert(payload.byteLength != null);\n      assert(messageBuffer.byteLength != null);\n      var mpat = state.messagePatterns.shift();\n      var moffset = 0;\n      assert(mpat != null);\n      assert(state.role === mpat.shift());\n      for (var token of mpat) {\n        switch (token) {\n          case TOK_E:\n            assert(state.epk == null);\n            assert(state.esk == null);\n            state.epk = sodium_malloc(dh.PKLEN);\n            state.esk = sodium_malloc(dh.SKLEN);\n            dh.generateKeypair(state.epk, state.esk);\n            messageBuffer.set(state.epk, moffset);\n            moffset += state.epk.byteLength;\n            symmetricState.mixHash(state.symmetricState, state.epk);\n            break;\n          case TOK_S:\n            assert(state.spk.byteLength === dh.PKLEN);\n            symmetricState.encryptAndHash(state.symmetricState, messageBuffer.subarray(moffset), state.spk);\n            moffset += symmetricState.encryptAndHash.bytesWritten;\n            break;\n          case TOK_EE:\n            dh.dh(DhResult, state.esk, state.re);\n            symmetricState.mixKey(state.symmetricState, DhResult);\n            sodium_memzero(DhResult);\n            break;\n          case TOK_ES:\n            if (state.role === INITIATOR)\n              dh.dh(DhResult, state.esk, state.rs);\n            else\n              dh.dh(DhResult, state.ssk, state.re);\n            symmetricState.mixKey(state.symmetricState, DhResult);\n            sodium_memzero(DhResult);\n            break;\n          case TOK_SE:\n            if (state.role === INITIATOR)\n              dh.dh(DhResult, state.ssk, state.re);\n            else\n              dh.dh(DhResult, state.esk, state.rs);\n            symmetricState.mixKey(state.symmetricState, DhResult);\n            sodium_memzero(DhResult);\n            break;\n          case TOK_SS:\n            dh.dh(DhResult, state.ssk, state.rs);\n            symmetricState.mixKey(state.symmetricState, DhResult);\n            sodium_memzero(DhResult);\n            break;\n          default:\n            throw new Error(\"Invalid message pattern\");\n        }\n      }\n      symmetricState.encryptAndHash(state.symmetricState, messageBuffer.subarray(moffset), payload);\n      moffset += symmetricState.encryptAndHash.bytesWritten;\n      writeMessage.bytes = moffset;\n      if (state.messagePatterns.length === 0) {\n        var tx = sodium_malloc(cipherState.STATELEN);\n        var rx = sodium_malloc(cipherState.STATELEN);\n        symmetricState.split(state.symmetricState, tx, rx);\n        return { tx, rx };\n      }\n    }\n    writeMessage.bytes = 0;\n    function readMessage(state, message, payloadBuffer) {\n      assert(state instanceof HandshakeState);\n      assert(message.byteLength != null);\n      assert(payloadBuffer.byteLength != null);\n      var mpat = state.messagePatterns.shift();\n      var moffset = 0;\n      assert(mpat != null);\n      assert(mpat.shift() !== state.role);\n      for (var token of mpat) {\n        switch (token) {\n          case TOK_E:\n            assert(state.re == null);\n            assert(message.byteLength - moffset >= dh.PKLEN);\n            state.re = sodium_malloc(dh.PKLEN);\n            state.re.set(message.subarray(moffset, moffset + dh.PKLEN));\n            moffset += dh.PKLEN;\n            symmetricState.mixHash(state.symmetricState, state.re);\n            break;\n          case TOK_S:\n            assert(state.rs == null);\n            state.rs = sodium_malloc(dh.PKLEN);\n            var bytes = 0;\n            if (symmetricState._hasKey(state.symmetricState)) {\n              bytes = dh.PKLEN + 16;\n            } else {\n              bytes = dh.PKLEN;\n            }\n            assert(message.byteLength - moffset >= bytes);\n            symmetricState.decryptAndHash(\n              state.symmetricState,\n              state.rs,\n              message.subarray(moffset, moffset + bytes)\n              // <- called temp in noise spec\n            );\n            moffset += symmetricState.decryptAndHash.bytesRead;\n            break;\n          case TOK_EE:\n            dh.dh(DhResult, state.esk, state.re);\n            symmetricState.mixKey(state.symmetricState, DhResult);\n            sodium_memzero(DhResult);\n            break;\n          case TOK_ES:\n            if (state.role === INITIATOR)\n              dh.dh(DhResult, state.esk, state.rs);\n            else\n              dh.dh(DhResult, state.ssk, state.re);\n            symmetricState.mixKey(state.symmetricState, DhResult);\n            sodium_memzero(DhResult);\n            break;\n          case TOK_SE:\n            if (state.role === INITIATOR)\n              dh.dh(DhResult, state.ssk, state.re);\n            else\n              dh.dh(DhResult, state.esk, state.rs);\n            symmetricState.mixKey(state.symmetricState, DhResult);\n            sodium_memzero(DhResult);\n            break;\n          case TOK_SS:\n            dh.dh(DhResult, state.ssk, state.rs);\n            symmetricState.mixKey(state.symmetricState, DhResult);\n            sodium_memzero(DhResult);\n            break;\n          default:\n            throw new Error(\"Invalid message pattern\");\n        }\n      }\n      symmetricState.decryptAndHash(state.symmetricState, payloadBuffer, message.subarray(moffset));\n      readMessage.bytes = symmetricState.decryptAndHash.bytesWritten;\n      if (state.messagePatterns.length === 0) {\n        var tx = sodium_malloc(cipherState.STATELEN);\n        var rx = sodium_malloc(cipherState.STATELEN);\n        symmetricState.split(state.symmetricState, rx, tx);\n        return { tx, rx };\n      }\n    }\n    readMessage.bytes = 0;\n    function destroy(state) {\n      if (state.symmetricState != null) {\n        sodium_free(state.symmetricState);\n        state.symmetricState = null;\n      }\n      state.role = null;\n      if (state.spk != null) {\n        sodium_free(state.spk);\n        state.spk = null;\n      }\n      if (state.ssk != null) {\n        sodium_free(state.ssk);\n        state.ssk = null;\n      }\n      if (state.epk != null) {\n        sodium_free(state.epk);\n        state.epk = null;\n      }\n      if (state.esk != null) {\n        sodium_free(state.esk);\n        state.esk = null;\n      }\n      if (state.rs != null) {\n        sodium_free(state.rs);\n        state.rs = null;\n      }\n      if (state.re != null) {\n        sodium_free(state.re);\n        state.re = null;\n      }\n      state.messagePatterns = null;\n    }\n    function keygen(obj, sk) {\n      if (!obj) {\n        obj = { publicKey: sodium_malloc(PKLEN), secretKey: sodium_malloc(SKLEN) };\n        return keygen(obj);\n      }\n      if (obj.publicKey) {\n        dh.generateKeypair(obj.publicKey, obj.secretKey);\n        return obj;\n      }\n      if (obj.byteLength != null)\n        dh.generateKeypair(null, obj);\n    }\n    function seedKeygen(seed) {\n      var obj = { publicKey: sodium_malloc(PKLEN), secretKey: sodium_malloc(SKLEN) };\n      dh.generateSeedKeypair(obj.publicKey, obj.secretKey, seed);\n      return obj;\n    }\n    function toCharCode(s) {\n      return s.charCodeAt(0);\n    }\n  }\n});\n\n// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/index.js\nvar require_noise_protocol = __commonJS({\n  \"node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = require_handshake_state();\n  }\n});\n\n// node_modules/.pnpm/simple-handshake@3.0.0/node_modules/simple-handshake/index.js\nvar require_simple_handshake = __commonJS({\n  \"node_modules/.pnpm/simple-handshake@3.0.0/node_modules/simple-handshake/index.js\"(exports, module) {\n    init_inject_globals();\n    var noise = require_noise_protocol();\n    var NoiseSymmetricState = require_symmetric_state();\n    var NoiseHash = require_hash();\n    var assert = require_nanoassert();\n    var EMPTY = Buffer2.alloc(0);\n    function SimpleHandshake(isInitiator, opts) {\n      if (!(this instanceof SimpleHandshake))\n        return new SimpleHandshake(isInitiator, opts);\n      opts = opts || {};\n      var pattern = opts.pattern || \"NN\";\n      var prolouge = opts.prolouge || EMPTY;\n      this.handshakeHash = null;\n      this.onstatickey = opts.onstatickey || function(_, cb) {\n        cb();\n      };\n      this.onephemeralkey = opts.onephemeralkey || function(_, cb) {\n        cb();\n      };\n      this.onhandshake = opts.onhandshake || function(_, cb) {\n        cb();\n      };\n      this.state = noise.initialize(\n        pattern,\n        isInitiator,\n        prolouge,\n        opts.staticKeyPair,\n        opts.ephemeralKeyPair,\n        opts.remoteStaticKey,\n        opts.remoteEphemeralKey\n      );\n      this.waiting = isInitiator === false;\n      this.finished = false;\n      this.split = null;\n      this._tx = Buffer2.alloc(65535);\n      this._rx = Buffer2.alloc(65535);\n    }\n    SimpleHandshake.prototype.recv = function recv(data, cb) {\n      var self = this;\n      assert(self.finished === false, \"Should not call recv if finished\");\n      assert(data != null, \"must have data\");\n      assert(data.byteLength <= self._rx.byteLength, \"too much data received\");\n      assert(self.waiting === true, \"Wrong state, not ready to receive data\");\n      assert(self.split == null, \"split should be null\");\n      var hasREBefore = self.state.re != null;\n      var hasRSBefore = self.state.rs != null;\n      try {\n        self.split = noise.readMessage(self.state, data, self._rx);\n      } catch (ex) {\n        return self._finish(ex, null, cb);\n      }\n      self.waiting = false;\n      var hasREAfter = self.state.re != null;\n      var hasRSAfter = self.state.rs != null;\n      if (hasREBefore === false && hasREAfter === true) {\n        return self.onephemeralkey(self.state.re, checkStatic);\n      }\n      return checkStatic();\n      function checkStatic(err) {\n        if (err)\n          return ondone(err);\n        if (hasRSBefore === false && hasRSAfter === true) {\n          return self.onstatickey(self.state.rs, ondone);\n        }\n        return ondone();\n      }\n      function ondone(err) {\n        if (err)\n          return self._finish(err, null, cb);\n        var msg = self._rx.subarray(0, noise.readMessage.bytes);\n        if (self.split)\n          return self._finish(null, msg, cb);\n        cb(null, msg);\n      }\n    };\n    SimpleHandshake.prototype.send = function send(data, cb) {\n      assert(this.finished === false, \"Should not call send if finished\");\n      assert(this.waiting === false, \"Wrong state, not ready to send data\");\n      assert(this.split == null, \"split should be null\");\n      data = data || EMPTY;\n      try {\n        this.split = noise.writeMessage(this.state, data, this._tx);\n      } catch (ex) {\n        return this._finish(ex, null, cb);\n      }\n      this.waiting = true;\n      var buf = this._tx.subarray(0, noise.writeMessage.bytes);\n      if (this.split != null)\n        return this._finish(null, buf, cb);\n      return cb(null, buf);\n    };\n    SimpleHandshake.prototype.destroy = function() {\n      this._finish(null, null, function() {\n      });\n    };\n    SimpleHandshake.prototype._finish = function _finish(err, msg, cb) {\n      assert(this.finished === false, \"Already finished\");\n      const self = this;\n      self.finished = true;\n      self.waiting = false;\n      if (self.split) {\n        self.handshakeHash = Buffer2.alloc(NoiseHash.HASHLEN);\n        NoiseSymmetricState.getHandshakeHash(self.state.symmetricState, self.handshakeHash);\n      }\n      if (err)\n        return ondone(err);\n      self.onhandshake(self.state, ondone);\n      function ondone(err2) {\n        noise.destroy(self.state);\n        cb(err2, msg, self.split);\n        self._rx.fill(0);\n        self._tx.fill(0);\n      }\n    };\n    SimpleHandshake.keygen = noise.keygen;\n    SimpleHandshake.seedKeygen = noise.seedKeygen;\n    module.exports = SimpleHandshake;\n  }\n});\n\n// node_modules/.pnpm/varint@5.0.2/node_modules/varint/encode.js\nvar require_encode2 = __commonJS({\n  \"node_modules/.pnpm/varint@5.0.2/node_modules/varint/encode.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = encode;\n    var MSB = 128;\n    var REST = 127;\n    var MSBALL = ~REST;\n    var INT = Math.pow(2, 31);\n    function encode(num, out, offset) {\n      out = out || [];\n      offset = offset || 0;\n      var oldOffset = offset;\n      while (num >= INT) {\n        out[offset++] = num & 255 | MSB;\n        num /= 128;\n      }\n      while (num & MSBALL) {\n        out[offset++] = num & 255 | MSB;\n        num >>>= 7;\n      }\n      out[offset] = num | 0;\n      encode.bytes = offset - oldOffset + 1;\n      return out;\n    }\n  }\n});\n\n// node_modules/.pnpm/varint@5.0.2/node_modules/varint/decode.js\nvar require_decode2 = __commonJS({\n  \"node_modules/.pnpm/varint@5.0.2/node_modules/varint/decode.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = read;\n    var MSB = 128;\n    var REST = 127;\n    function read(buf, offset) {\n      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n      do {\n        if (counter >= l) {\n          read.bytes = 0;\n          throw new RangeError(\"Could not decode varint\");\n        }\n        b = buf[counter++];\n        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);\n        shift += 7;\n      } while (b >= MSB);\n      read.bytes = counter - offset;\n      return res;\n    }\n  }\n});\n\n// node_modules/.pnpm/varint@5.0.2/node_modules/varint/length.js\nvar require_length2 = __commonJS({\n  \"node_modules/.pnpm/varint@5.0.2/node_modules/varint/length.js\"(exports, module) {\n    init_inject_globals();\n    var N1 = Math.pow(2, 7);\n    var N2 = Math.pow(2, 14);\n    var N3 = Math.pow(2, 21);\n    var N4 = Math.pow(2, 28);\n    var N5 = Math.pow(2, 35);\n    var N6 = Math.pow(2, 42);\n    var N7 = Math.pow(2, 49);\n    var N8 = Math.pow(2, 56);\n    var N9 = Math.pow(2, 63);\n    module.exports = function(value) {\n      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n    };\n  }\n});\n\n// node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js\nvar require_varint2 = __commonJS({\n  \"node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = {\n      encode: require_encode2(),\n      decode: require_decode2(),\n      encodingLength: require_length2()\n    };\n  }\n});\n\n// node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/handshake.js\nvar require_handshake = __commonJS({\n  \"node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/handshake.js\"(exports, module) {\n    init_inject_globals();\n    var SH = require_simple_handshake();\n    var DH = require_dh();\n    var crypto = require_hypercore_crypto();\n    var varint = require_varint2();\n    module.exports = class ProtocolHandshake {\n      constructor(initiator, payload, opts, done) {\n        this.options = opts;\n        this.ondone = done;\n        this.buffer = null;\n        this.length = 0;\n        this.remotePayload = null;\n        this.payload = payload;\n        this.keyPair = opts.keyPair || ProtocolHandshake.keyPair();\n        this.remotePublicKey = null;\n        this.onrecv = onrecv.bind(this);\n        this.onsend = onsend.bind(this);\n        this.destroyed = false;\n        this.noise = SH(initiator, {\n          pattern: \"XX\",\n          onhandshake,\n          staticKeyPair: this.keyPair,\n          onstatickey: onstatickey.bind(this)\n        });\n        const self = this;\n        if (this.noise.waiting === false)\n          process.nextTick(start, this);\n        function onhandshake(state, cb) {\n          process.nextTick(finish, self);\n          cb(null);\n        }\n      }\n      recv(data) {\n        if (this.destroyed)\n          return;\n        if (this.buffer)\n          this.buffer = Buffer2.concat([this.buffer, data]);\n        else\n          this.buffer = data;\n        while (!this.destroyed && !this.noise.finished) {\n          if (!this.buffer || this.buffer.length < 3)\n            return;\n          if (this.length) {\n            if (this.buffer.length < this.length)\n              return;\n            const message = this.buffer.slice(0, this.length);\n            this.buffer = this.length < this.buffer.length ? this.buffer.slice(this.length) : null;\n            this.length = 0;\n            this.noise.recv(message, this.onrecv);\n          } else {\n            this.length = varint.decode(this.buffer, 0);\n            this.buffer = this.buffer.slice(varint.decode.bytes);\n          }\n        }\n      }\n      destroy(err) {\n        if (this.destroyed)\n          return;\n        this.destroyed = true;\n        if (!this.noise.finished)\n          this.noise.destroy();\n        this.ondone(err);\n      }\n      static keyPair(seed) {\n        const obj = {\n          // suboptimal but to reduce secure memory overhead on linux with default settings\n          // better fix is to batch mallocs in noise-protocol\n          publicKey: Buffer2.alloc(DH.PKLEN),\n          secretKey: Buffer2.alloc(DH.SKLEN)\n        };\n        if (seed)\n          DH.generateSeedKeypair(obj.publicKey, obj.secretKey, seed);\n        else\n          DH.generateKeypair(obj.publicKey, obj.secretKey);\n        return obj;\n      }\n    };\n    function finish(self) {\n      if (self.destroyed)\n        return;\n      self.destroyed = true;\n      const split = { rx: Buffer2.from(self.noise.split.rx), tx: Buffer2.from(self.noise.split.tx) };\n      crypto.free(self.noise.split.rx);\n      crypto.free(self.noise.split.tx);\n      self.ondone(null, self.remotePayload, split, self.buffer, self.remotePublicKey, self.noise.handshakeHash);\n    }\n    function start(self) {\n      if (self.destroyed)\n        return;\n      self.noise.send(self.payload, self.onsend);\n    }\n    function onsend(err, data) {\n      if (err)\n        return this.destroy(err);\n      const buf = Buffer2.allocUnsafe(varint.encodingLength(data.length) + data.length);\n      varint.encode(data.length, buf, 0);\n      data.copy(buf, varint.encode.bytes);\n      this.options.send(buf);\n    }\n    function onrecv(err, data) {\n      if (err)\n        return this.destroy(err);\n      if (data && data.length)\n        this.remotePayload = Buffer2.from(data);\n      if (this.destroyed || this.noise.finished)\n        return;\n      if (this.noise.waiting === false) {\n        this.noise.send(this.payload, this.onsend);\n      }\n    }\n    function onstatickey(remoteKey, done) {\n      this.remotePublicKey = Buffer2.from(remoteKey);\n      if (this.options.onauthenticate)\n        this.options.onauthenticate(this.remotePublicKey, done);\n      else\n        done(null);\n    }\n  }\n});\n\n// node_modules/.pnpm/varint@5.0.0/node_modules/varint/encode.js\nvar require_encode3 = __commonJS({\n  \"node_modules/.pnpm/varint@5.0.0/node_modules/varint/encode.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = encode;\n    var MSB = 128;\n    var REST = 127;\n    var MSBALL = ~REST;\n    var INT = Math.pow(2, 31);\n    function encode(num, out, offset) {\n      out = out || [];\n      offset = offset || 0;\n      var oldOffset = offset;\n      while (num >= INT) {\n        out[offset++] = num & 255 | MSB;\n        num /= 128;\n      }\n      while (num & MSBALL) {\n        out[offset++] = num & 255 | MSB;\n        num >>>= 7;\n      }\n      out[offset] = num | 0;\n      encode.bytes = offset - oldOffset + 1;\n      return out;\n    }\n  }\n});\n\n// node_modules/.pnpm/varint@5.0.0/node_modules/varint/decode.js\nvar require_decode3 = __commonJS({\n  \"node_modules/.pnpm/varint@5.0.0/node_modules/varint/decode.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = read;\n    var MSB = 128;\n    var REST = 127;\n    function read(buf, offset) {\n      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n      do {\n        if (counter >= l) {\n          read.bytes = 0;\n          throw new RangeError(\"Could not decode varint\");\n        }\n        b = buf[counter++];\n        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);\n        shift += 7;\n      } while (b >= MSB);\n      read.bytes = counter - offset;\n      return res;\n    }\n  }\n});\n\n// node_modules/.pnpm/varint@5.0.0/node_modules/varint/length.js\nvar require_length3 = __commonJS({\n  \"node_modules/.pnpm/varint@5.0.0/node_modules/varint/length.js\"(exports, module) {\n    init_inject_globals();\n    var N1 = Math.pow(2, 7);\n    var N2 = Math.pow(2, 14);\n    var N3 = Math.pow(2, 21);\n    var N4 = Math.pow(2, 28);\n    var N5 = Math.pow(2, 35);\n    var N6 = Math.pow(2, 42);\n    var N7 = Math.pow(2, 49);\n    var N8 = Math.pow(2, 56);\n    var N9 = Math.pow(2, 63);\n    module.exports = function(value) {\n      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n    };\n  }\n});\n\n// node_modules/.pnpm/varint@5.0.0/node_modules/varint/index.js\nvar require_varint3 = __commonJS({\n  \"node_modules/.pnpm/varint@5.0.0/node_modules/varint/index.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = {\n      encode: require_encode3(),\n      decode: require_decode3(),\n      encodingLength: require_length3()\n    };\n  }\n});\n\n// node_modules/.pnpm/signed-varint@2.0.1/node_modules/signed-varint/index.js\nvar require_signed_varint = __commonJS({\n  \"node_modules/.pnpm/signed-varint@2.0.1/node_modules/signed-varint/index.js\"(exports) {\n    init_inject_globals();\n    var varint = require_varint2();\n    exports.encode = function encode(v, b, o) {\n      v = v >= 0 ? v * 2 : v * -2 - 1;\n      var r = varint.encode(v, b, o);\n      encode.bytes = varint.encode.bytes;\n      return r;\n    };\n    exports.decode = function decode(b, o) {\n      var v = varint.decode(b, o);\n      decode.bytes = varint.decode.bytes;\n      return v & 1 ? (v + 1) / -2 : v / 2;\n    };\n    exports.encodingLength = function(v) {\n      return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1);\n    };\n  }\n});\n\n// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/ascii.js\nvar require_ascii = __commonJS({\n  \"node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/ascii.js\"(exports, module) {\n    init_inject_globals();\n    function byteLength(string) {\n      return string.length;\n    }\n    function toString(buffer) {\n      const len = buffer.byteLength;\n      let result = \"\";\n      for (let i = 0; i < len; i++) {\n        result += String.fromCharCode(buffer[i]);\n      }\n      return result;\n    }\n    function write(buffer, string, offset = 0, length = byteLength(string)) {\n      const len = Math.min(length, buffer.byteLength - offset);\n      for (let i = 0; i < len; i++) {\n        buffer[offset + i] = string.charCodeAt(i);\n      }\n      return len;\n    }\n    module.exports = {\n      byteLength,\n      toString,\n      write\n    };\n  }\n});\n\n// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/base64.js\nvar require_base64 = __commonJS({\n  \"node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/base64.js\"(exports, module) {\n    init_inject_globals();\n    var alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var codes = new Uint8Array(256);\n    for (let i = 0; i < alphabet.length; i++) {\n      codes[alphabet.charCodeAt(i)] = i;\n    }\n    codes[\n      /* - */\n      45\n    ] = 62;\n    codes[\n      /* _ */\n      95\n    ] = 63;\n    function byteLength(string) {\n      let len = string.length;\n      if (string.charCodeAt(len - 1) === 61)\n        len--;\n      if (len > 1 && string.charCodeAt(len - 1) === 61)\n        len--;\n      return len * 3 >>> 2;\n    }\n    function toString(buffer) {\n      const len = buffer.byteLength;\n      let result = \"\";\n      for (let i = 0; i < len; i += 3) {\n        result += alphabet[buffer[i] >> 2] + alphabet[(buffer[i] & 3) << 4 | buffer[i + 1] >> 4] + alphabet[(buffer[i + 1] & 15) << 2 | buffer[i + 2] >> 6] + alphabet[buffer[i + 2] & 63];\n      }\n      if (len % 3 === 2) {\n        result = result.substring(0, result.length - 1) + \"=\";\n      } else if (len % 3 === 1) {\n        result = result.substring(0, result.length - 2) + \"==\";\n      }\n      return result;\n    }\n    function write(buffer, string, offset = 0, length = byteLength(string)) {\n      const len = Math.min(length, buffer.byteLength - offset);\n      for (let i = 0, j = 0; i < len; i += 4) {\n        const a = codes[string.charCodeAt(i)];\n        const b = codes[string.charCodeAt(i + 1)];\n        const c = codes[string.charCodeAt(i + 2)];\n        const d = codes[string.charCodeAt(i + 3)];\n        buffer[j++] = a << 2 | b >> 4;\n        buffer[j++] = (b & 15) << 4 | c >> 2;\n        buffer[j++] = (c & 3) << 6 | d & 63;\n      }\n      return len;\n    }\n    module.exports = {\n      byteLength,\n      toString,\n      write\n    };\n  }\n});\n\n// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/hex.js\nvar require_hex = __commonJS({\n  \"node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/hex.js\"(exports, module) {\n    init_inject_globals();\n    function byteLength(string) {\n      return string.length >>> 1;\n    }\n    function toString(buffer) {\n      const len = buffer.byteLength;\n      buffer = new DataView(buffer.buffer, buffer.byteOffset, len);\n      let result = \"\";\n      let i = 0;\n      for (let n = len - len % 4; i < n; i += 4) {\n        result += buffer.getUint32(i).toString(16).padStart(8, \"0\");\n      }\n      for (; i < len; i++) {\n        result += buffer.getUint8(i).toString(16).padStart(2, \"0\");\n      }\n      return result;\n    }\n    function write(buffer, string, offset = 0, length = byteLength(string)) {\n      const len = Math.min(length, buffer.byteLength - offset);\n      for (let i = 0; i < len; i++) {\n        const a = hexValue(string.charCodeAt(i * 2));\n        const b = hexValue(string.charCodeAt(i * 2 + 1));\n        if (a === void 0 || b === void 0) {\n          return buffer.subarray(0, i);\n        }\n        buffer[offset + i] = a << 4 | b;\n      }\n      return len;\n    }\n    module.exports = {\n      byteLength,\n      toString,\n      write\n    };\n    function hexValue(char) {\n      if (char >= 48 && char <= 57)\n        return char - 48;\n      if (char >= 65 && char <= 70)\n        return char - 65 + 10;\n      if (char >= 97 && char <= 102)\n        return char - 97 + 10;\n    }\n  }\n});\n\n// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/utf8.js\nvar require_utf8 = __commonJS({\n  \"node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/utf8.js\"(exports, module) {\n    init_inject_globals();\n    function byteLength(string) {\n      let length = 0;\n      for (let i = 0, n = string.length; i < n; i++) {\n        const code = string.charCodeAt(i);\n        if (code >= 55296 && code <= 56319 && i + 1 < n) {\n          const code2 = string.charCodeAt(i + 1);\n          if (code2 >= 56320 && code2 <= 57343) {\n            length += 4;\n            i++;\n            continue;\n          }\n        }\n        if (code <= 127)\n          length += 1;\n        else if (code <= 2047)\n          length += 2;\n        else\n          length += 3;\n      }\n      return length;\n    }\n    var toString;\n    if (typeof TextDecoder !== \"undefined\") {\n      const decoder = new TextDecoder();\n      toString = function toString2(buffer) {\n        return decoder.decode(buffer);\n      };\n    } else {\n      toString = function toString2(buffer) {\n        const len = buffer.byteLength;\n        let output = \"\";\n        let i = 0;\n        while (i < len) {\n          let byte = buffer[i];\n          if (byte <= 127) {\n            output += String.fromCharCode(byte);\n            i++;\n            continue;\n          }\n          let bytesNeeded = 0;\n          let codePoint = 0;\n          if (byte <= 223) {\n            bytesNeeded = 1;\n            codePoint = byte & 31;\n          } else if (byte <= 239) {\n            bytesNeeded = 2;\n            codePoint = byte & 15;\n          } else if (byte <= 244) {\n            bytesNeeded = 3;\n            codePoint = byte & 7;\n          }\n          if (len - i - bytesNeeded > 0) {\n            let k = 0;\n            while (k < bytesNeeded) {\n              byte = buffer[i + k + 1];\n              codePoint = codePoint << 6 | byte & 63;\n              k += 1;\n            }\n          } else {\n            codePoint = 65533;\n            bytesNeeded = len - i;\n          }\n          output += String.fromCodePoint(codePoint);\n          i += bytesNeeded + 1;\n        }\n        return output;\n      };\n    }\n    var write;\n    if (typeof TextEncoder !== \"undefined\") {\n      const encoder = new TextEncoder();\n      write = function write2(buffer, string, offset = 0, length = byteLength(string)) {\n        const len = Math.min(length, buffer.byteLength - offset);\n        encoder.encodeInto(string, buffer.subarray(offset, offset + len));\n        return len;\n      };\n    } else {\n      write = function write2(buffer, string, offset = 0, length = byteLength(string)) {\n        const len = Math.min(length, buffer.byteLength - offset);\n        buffer = buffer.subarray(offset, offset + len);\n        let i = 0;\n        let j = 0;\n        while (i < string.length) {\n          const code = string.codePointAt(i);\n          if (code <= 127) {\n            buffer[j++] = code;\n            i++;\n            continue;\n          }\n          let count = 0;\n          let bits = 0;\n          if (code <= 2047) {\n            count = 6;\n            bits = 192;\n          } else if (code <= 65535) {\n            count = 12;\n            bits = 224;\n          } else if (code <= 2097151) {\n            count = 18;\n            bits = 240;\n          }\n          buffer[j++] = bits | code >> count;\n          count -= 6;\n          while (count >= 0) {\n            buffer[j++] = 128 | code >> count & 63;\n            count -= 6;\n          }\n          i += code >= 65536 ? 2 : 1;\n        }\n        return len;\n      };\n    }\n    module.exports = {\n      byteLength,\n      toString,\n      write\n    };\n  }\n});\n\n// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/utf16le.js\nvar require_utf16le = __commonJS({\n  \"node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/utf16le.js\"(exports, module) {\n    init_inject_globals();\n    function byteLength(string) {\n      return string.length * 2;\n    }\n    function toString(buffer) {\n      const len = buffer.byteLength;\n      let result = \"\";\n      for (let i = 0; i < len - 1; i += 2) {\n        result += String.fromCharCode(buffer[i] + buffer[i + 1] * 256);\n      }\n      return result;\n    }\n    function write(buffer, string, offset = 0, length = byteLength(string)) {\n      const len = Math.min(length, buffer.byteLength - offset);\n      let units = len;\n      for (let i = 0; i < string.length; ++i) {\n        if ((units -= 2) < 0)\n          break;\n        const c = string.charCodeAt(i);\n        const hi = c >> 8;\n        const lo = c % 256;\n        buffer[offset + i * 2] = lo;\n        buffer[offset + i * 2 + 1] = hi;\n      }\n      return len;\n    }\n    module.exports = {\n      byteLength,\n      toString,\n      write\n    };\n  }\n});\n\n// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/browser.js\nvar require_browser2 = __commonJS({\n  \"node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/browser.js\"(exports, module) {\n    init_inject_globals();\n    var ascii = require_ascii();\n    var base64 = require_base64();\n    var hex = require_hex();\n    var utf8 = require_utf8();\n    var utf16le = require_utf16le();\n    var LE = new Uint8Array(Uint16Array.of(255).buffer)[0] === 255;\n    function codecFor(encoding) {\n      switch (encoding) {\n        case \"ascii\":\n          return ascii;\n        case \"base64\":\n          return base64;\n        case \"hex\":\n          return hex;\n        case \"utf8\":\n        case \"utf-8\":\n        case void 0:\n          return utf8;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return utf16le;\n        default:\n          throw new Error(`Unknown encoding: ${encoding}`);\n      }\n    }\n    function isBuffer(value) {\n      return value instanceof Uint8Array;\n    }\n    function isEncoding(encoding) {\n      try {\n        codecFor(encoding);\n        return true;\n      } catch {\n        return false;\n      }\n    }\n    function alloc(size, fill2, encoding) {\n      const buffer = new Uint8Array(size);\n      if (fill2 !== void 0)\n        fill2(buffer, fill2, 0, buffer.byteLength, encoding);\n      return buffer;\n    }\n    function allocUnsafe(size) {\n      return new Uint8Array(size);\n    }\n    function allocUnsafeSlow(size) {\n      return new Uint8Array(size);\n    }\n    function byteLength(string, encoding) {\n      return codecFor(encoding).byteLength(string);\n    }\n    function compare(a, b) {\n      if (a === b)\n        return 0;\n      const len = Math.min(a.byteLength, b.byteLength);\n      a = new DataView(a.buffer, a.byteOffset, a.byteLength);\n      b = new DataView(b.buffer, b.byteOffset, b.byteLength);\n      let i = 0;\n      for (let n = len - len % 4; i < n; i += 4) {\n        const x = a.getUint32(i, LE);\n        const y = b.getUint32(i, LE);\n        if (x !== y)\n          break;\n      }\n      for (; i < len; i++) {\n        const x = a.getUint8(i);\n        const y = b.getUint8(i);\n        if (x < y)\n          return -1;\n        if (x > y)\n          return 1;\n      }\n      return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0;\n    }\n    function concat(buffers, totalLength) {\n      if (totalLength === void 0) {\n        totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0);\n      }\n      const result = new Uint8Array(totalLength);\n      buffers.reduce(\n        (offset, buffer) => {\n          result.set(buffer, offset);\n          return offset + buffer.byteLength;\n        },\n        0\n      );\n      return result;\n    }\n    function copy(source, target, targetStart = 0, start = 0, end = source.byteLength) {\n      if (end > 0 && end < start)\n        return 0;\n      if (end === start)\n        return 0;\n      if (source.byteLength === 0 || target.byteLength === 0)\n        return 0;\n      if (targetStart < 0)\n        throw new RangeError(\"targetStart is out of range\");\n      if (start < 0 || start >= source.byteLength)\n        throw new RangeError(\"sourceStart is out of range\");\n      if (end < 0)\n        throw new RangeError(\"sourceEnd is out of range\");\n      if (targetStart >= target.byteLength)\n        targetStart = target.byteLength;\n      if (end > source.byteLength)\n        end = source.byteLength;\n      if (target.byteLength - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (source === target) {\n        target.copyWithin(targetStart, start, end);\n      } else {\n        target.set(source.subarray(start, end), targetStart);\n      }\n      return len;\n    }\n    function equals(a, b) {\n      if (a === b)\n        return true;\n      if (a.byteLength !== b.byteLength)\n        return false;\n      const len = a.byteLength;\n      a = new DataView(a.buffer, a.byteOffset, a.byteLength);\n      b = new DataView(b.buffer, b.byteOffset, b.byteLength);\n      let i = 0;\n      for (let n = len - len % 4; i < n; i += 4) {\n        if (a.getUint32(i, LE) !== b.getUint32(i, LE))\n          return false;\n      }\n      for (; i < len; i++) {\n        if (a.getUint8(i) !== b.getUint8(i))\n          return false;\n      }\n      return true;\n    }\n    function fill(buffer, value, offset, end, encoding) {\n      if (typeof value === \"string\") {\n        if (typeof offset === \"string\") {\n          encoding = offset;\n          offset = 0;\n          end = buffer.byteLength;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = buffer.byteLength;\n        }\n      } else if (typeof val === \"number\") {\n        value = value & 255;\n      } else if (typeof val === \"boolean\") {\n        value = +value;\n      }\n      if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (offset === void 0)\n        offset = 0;\n      if (end === void 0)\n        end = buffer.byteLength;\n      if (end <= offset)\n        return buffer;\n      if (!value)\n        value = 0;\n      if (typeof value === \"number\") {\n        for (let i = offset; i < end; ++i) {\n          buffer[i] = value;\n        }\n      } else {\n        value = isBuffer(value) ? value : from(value, encoding);\n        const len = value.byteLength;\n        for (let i = 0; i < end - offset; ++i) {\n          buffer[i + offset] = value[i % len];\n        }\n      }\n      return buffer;\n    }\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\")\n        return fromString(value, encodingOrOffset);\n      if (Array.isArray(value))\n        return fromArray(value);\n      if (ArrayBuffer.isView(value))\n        return fromBuffer(value);\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    function fromString(string, encoding) {\n      const codec = codecFor(encoding);\n      const buffer = new Uint8Array(codec.byteLength(string));\n      codec.write(buffer, string, 0, buffer.byteLength);\n      return buffer;\n    }\n    function fromArray(array) {\n      const buffer = new Uint8Array(array.length);\n      buffer.set(array);\n      return buffer;\n    }\n    function fromBuffer(buffer) {\n      const copy2 = new Uint8Array(buffer.byteLength);\n      copy2.set(buffer);\n      return copy2;\n    }\n    function fromArrayBuffer(arrayBuffer, byteOffset, length) {\n      return new Uint8Array(arrayBuffer, byteOffset, length);\n    }\n    function includes(buffer, value, byteOffset, encoding) {\n      return indexOf(buffer, value, byteOffset, encoding) !== -1;\n    }\n    function bidirectionalIndexOf(buffer, value, byteOffset, encoding, first) {\n      if (buffer.byteLength === 0)\n        return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset === void 0) {\n        byteOffset = first ? 0 : buffer.length - 1;\n      } else if (byteOffset < 0) {\n        byteOffset += buffer.byteLength;\n      }\n      if (byteOffset >= buffer.byteLength) {\n        if (first)\n          return -1;\n        else\n          byteOffset = buffer.byteLength - 1;\n      } else if (byteOffset < 0) {\n        if (first)\n          byteOffset = 0;\n        else\n          return -1;\n      }\n      if (typeof value === \"string\") {\n        value = from(value, encoding);\n      } else if (typeof value === \"number\") {\n        value = value & 255;\n        if (first) {\n          return buffer.indexOf(value, byteOffset);\n        } else {\n          return buffer.lastIndexOf(value, byteOffset);\n        }\n      }\n      if (value.byteLength === 0)\n        return -1;\n      if (first) {\n        let foundIndex = -1;\n        for (let i = byteOffset; i < buffer.byteLength; i++) {\n          if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n            if (foundIndex === -1)\n              foundIndex = i;\n            if (i - foundIndex + 1 === value.byteLength)\n              return foundIndex;\n          } else {\n            if (foundIndex !== -1)\n              i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + value.byteLength > buffer.byteLength) {\n          byteOffset = buffer.byteLength - value.byteLength;\n        }\n        for (let i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j = 0; j < value.byteLength; j++) {\n            if (buffer[i + j] !== value[j]) {\n              found = false;\n              break;\n            }\n          }\n          if (found)\n            return i;\n        }\n      }\n      return -1;\n    }\n    function indexOf(buffer, value, byteOffset, encoding) {\n      return bidirectionalIndexOf(\n        buffer,\n        value,\n        byteOffset,\n        encoding,\n        true\n        /* first */\n      );\n    }\n    function lastIndexOf(buffer, value, byteOffset, encoding) {\n      return bidirectionalIndexOf(\n        buffer,\n        value,\n        byteOffset,\n        encoding,\n        false\n        /* last */\n      );\n    }\n    function swap(buffer, n, m) {\n      const i = buffer[n];\n      buffer[n] = buffer[m];\n      buffer[m] = i;\n    }\n    function swap16(buffer) {\n      const len = buffer.byteLength;\n      if (len % 2 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      for (let i = 0; i < len; i += 2)\n        swap(buffer, i, i + 1);\n      return buffer;\n    }\n    function swap32(buffer) {\n      const len = buffer.byteLength;\n      if (len % 4 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      for (let i = 0; i < len; i += 4) {\n        swap(buffer, i, i + 3);\n        swap(buffer, i + 1, i + 2);\n      }\n      return buffer;\n    }\n    function swap64(buffer) {\n      const len = buffer.byteLength;\n      if (len % 8 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      for (let i = 0; i < len; i += 8) {\n        swap(buffer, i, i + 7);\n        swap(buffer, i + 1, i + 6);\n        swap(buffer, i + 2, i + 5);\n        swap(buffer, i + 3, i + 4);\n      }\n      return buffer;\n    }\n    function toBuffer(buffer) {\n      return buffer;\n    }\n    function toString(buffer, encoding, start = 0, end = buffer.byteLength) {\n      const len = buffer.byteLength;\n      if (start >= len)\n        return \"\";\n      if (end <= start)\n        return \"\";\n      if (start < 0)\n        start = 0;\n      if (end > len)\n        end = len;\n      if (start !== 0 || end < len)\n        buffer = buffer.subarray(start, end);\n      return codecFor(encoding).toString(buffer);\n    }\n    function write(buffer, string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        offset = void 0;\n      } else if (encoding === void 0 && typeof length === \"string\") {\n        encoding = length;\n        length = void 0;\n      }\n      return codecFor(encoding).write(buffer, string, offset, length);\n    }\n    function writeDoubleLE(buffer, value, offset) {\n      if (offset === void 0)\n        offset = 0;\n      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      view.setFloat64(offset, value, true);\n      return offset + 8;\n    }\n    function writeFloatLE(buffer, value, offset) {\n      if (offset === void 0)\n        offset = 0;\n      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      view.setFloat32(offset, value, true);\n      return offset + 4;\n    }\n    function writeUInt32LE(buffer, value, offset) {\n      if (offset === void 0)\n        offset = 0;\n      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      view.setUint32(offset, value, true);\n      return offset + 4;\n    }\n    function writeInt32LE(buffer, value, offset) {\n      if (offset === void 0)\n        offset = 0;\n      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      view.setInt32(offset, value, true);\n      return offset + 4;\n    }\n    function readDoubleLE(buffer, offset) {\n      if (offset === void 0)\n        offset = 0;\n      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      return view.getFloat64(offset, true);\n    }\n    function readFloatLE(buffer, offset) {\n      if (offset === void 0)\n        offset = 0;\n      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      return view.getFloat32(offset, true);\n    }\n    function readUInt32LE(buffer, offset) {\n      if (offset === void 0)\n        offset = 0;\n      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      return view.getUint32(offset, true);\n    }\n    function readInt32LE(buffer, offset) {\n      if (offset === void 0)\n        offset = 0;\n      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      return view.getInt32(offset, true);\n    }\n    module.exports = {\n      isBuffer,\n      isEncoding,\n      alloc,\n      allocUnsafe,\n      allocUnsafeSlow,\n      byteLength,\n      compare,\n      concat,\n      copy,\n      equals,\n      fill,\n      from,\n      includes,\n      indexOf,\n      lastIndexOf,\n      swap16,\n      swap32,\n      swap64,\n      toBuffer,\n      toString,\n      write,\n      writeDoubleLE,\n      writeFloatLE,\n      writeUInt32LE,\n      writeInt32LE,\n      readDoubleLE,\n      readFloatLE,\n      readUInt32LE,\n      readInt32LE\n    };\n  }\n});\n\n// node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js\nvar require_protocol_buffers_encodings = __commonJS({\n  \"node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js\"(exports) {\n    init_inject_globals();\n    var varint = require_varint3();\n    var svarint = require_signed_varint();\n    var b4a = require_browser2();\n    exports.make = encoder;\n    exports.name = function(enc) {\n      var keys = Object.keys(exports);\n      for (var i = 0; i < keys.length; i++) {\n        if (exports[keys[i]] === enc)\n          return keys[i];\n      }\n      return null;\n    };\n    exports.skip = function(type, buffer, offset) {\n      switch (type) {\n        case 0:\n          varint.decode(buffer, offset);\n          return offset + varint.decode.bytes;\n        case 1:\n          return offset + 8;\n        case 2:\n          var len = varint.decode(buffer, offset);\n          return offset + varint.decode.bytes + len;\n        case 3:\n        case 4:\n          throw new Error(\"Groups are not supported\");\n        case 5:\n          return offset + 4;\n      }\n      throw new Error(\"Unknown wire type: \" + type);\n    };\n    exports.bytes = encoder(\n      2,\n      function encode(val2, buffer, offset) {\n        var oldOffset = offset;\n        var len = bufferLength(val2);\n        varint.encode(len, buffer, offset);\n        offset += varint.encode.bytes;\n        if (b4a.isBuffer(val2))\n          b4a.copy(val2, buffer, offset);\n        else\n          b4a.write(buffer, val2, offset, len);\n        offset += len;\n        encode.bytes = offset - oldOffset;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var oldOffset = offset;\n        var len = varint.decode(buffer, offset);\n        offset += varint.decode.bytes;\n        var val2 = buffer.subarray(offset, offset + len);\n        offset += val2.length;\n        decode.bytes = offset - oldOffset;\n        return val2;\n      },\n      function encodingLength(val2) {\n        var len = bufferLength(val2);\n        return varint.encodingLength(len) + len;\n      }\n    );\n    exports.string = encoder(\n      2,\n      function encode(val2, buffer, offset) {\n        var oldOffset = offset;\n        var len = b4a.byteLength(val2);\n        varint.encode(len, buffer, offset, \"utf-8\");\n        offset += varint.encode.bytes;\n        b4a.write(buffer, val2, offset, len);\n        offset += len;\n        encode.bytes = offset - oldOffset;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var oldOffset = offset;\n        var len = varint.decode(buffer, offset);\n        offset += varint.decode.bytes;\n        var val2 = b4a.toString(buffer, \"utf-8\", offset, offset + len);\n        offset += len;\n        decode.bytes = offset - oldOffset;\n        return val2;\n      },\n      function encodingLength(val2) {\n        var len = b4a.byteLength(val2);\n        return varint.encodingLength(len) + len;\n      }\n    );\n    exports.bool = encoder(\n      0,\n      function encode(val2, buffer, offset) {\n        buffer[offset] = val2 ? 1 : 0;\n        encode.bytes = 1;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var bool = buffer[offset] > 0;\n        decode.bytes = 1;\n        return bool;\n      },\n      function encodingLength() {\n        return 1;\n      }\n    );\n    exports.int32 = encoder(\n      0,\n      function encode(val2, buffer, offset) {\n        varint.encode(val2 < 0 ? val2 + 4294967296 : val2, buffer, offset);\n        encode.bytes = varint.encode.bytes;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var val2 = varint.decode(buffer, offset);\n        decode.bytes = varint.decode.bytes;\n        return val2 > 2147483647 ? val2 - 4294967296 : val2;\n      },\n      function encodingLength(val2) {\n        return varint.encodingLength(val2 < 0 ? val2 + 4294967296 : val2);\n      }\n    );\n    exports.int64 = encoder(\n      0,\n      function encode(val2, buffer, offset) {\n        if (val2 < 0) {\n          var last = offset + 9;\n          varint.encode(val2 * -1, buffer, offset);\n          offset += varint.encode.bytes - 1;\n          buffer[offset] = buffer[offset] | 128;\n          while (offset < last - 1) {\n            offset++;\n            buffer[offset] = 255;\n          }\n          buffer[last] = 1;\n          encode.bytes = 10;\n        } else {\n          varint.encode(val2, buffer, offset);\n          encode.bytes = varint.encode.bytes;\n        }\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var val2 = varint.decode(buffer, offset);\n        if (val2 >= Math.pow(2, 63)) {\n          var limit = 9;\n          while (buffer[offset + limit - 1] === 255)\n            limit--;\n          limit = limit || 9;\n          var subset = b4a.allocUnsafe(limit);\n          b4a.copy(buffer, subset, 0, offset, offset + limit);\n          subset[limit - 1] = subset[limit - 1] & 127;\n          val2 = -1 * varint.decode(subset, 0);\n          decode.bytes = 10;\n        } else {\n          decode.bytes = varint.decode.bytes;\n        }\n        return val2;\n      },\n      function encodingLength(val2) {\n        return val2 < 0 ? 10 : varint.encodingLength(val2);\n      }\n    );\n    exports.sint32 = exports.sint64 = encoder(\n      0,\n      svarint.encode,\n      svarint.decode,\n      svarint.encodingLength\n    );\n    exports.uint32 = exports.uint64 = exports.enum = exports.varint = encoder(\n      0,\n      varint.encode,\n      varint.decode,\n      varint.encodingLength\n    );\n    exports.fixed64 = exports.sfixed64 = encoder(\n      1,\n      function encode(val2, buffer, offset) {\n        b4a.copy(val2, buffer, offset);\n        encode.bytes = 8;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var val2 = buffer.subarray(offset, offset + 8);\n        decode.bytes = 8;\n        return val2;\n      },\n      function encodingLength() {\n        return 8;\n      }\n    );\n    exports.double = encoder(\n      1,\n      function encode(val2, buffer, offset) {\n        b4a.writeDoubleLE(buffer, val2, offset);\n        encode.bytes = 8;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var val2 = b4a.readDoubleLE(buffer, offset);\n        decode.bytes = 8;\n        return val2;\n      },\n      function encodingLength() {\n        return 8;\n      }\n    );\n    exports.fixed32 = encoder(\n      5,\n      function encode(val2, buffer, offset) {\n        b4a.writeUInt32LE(buffer, val2, offset);\n        encode.bytes = 4;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var val2 = b4a.readUInt32LE(buffer, offset);\n        decode.bytes = 4;\n        return val2;\n      },\n      function encodingLength() {\n        return 4;\n      }\n    );\n    exports.sfixed32 = encoder(\n      5,\n      function encode(val2, buffer, offset) {\n        b4a.writeInt32LE(buffer, val2, offset);\n        encode.bytes = 4;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var val2 = b4a.readInt32LE(buffer, offset);\n        decode.bytes = 4;\n        return val2;\n      },\n      function encodingLength() {\n        return 4;\n      }\n    );\n    exports.float = encoder(\n      5,\n      function encode(val2, buffer, offset) {\n        b4a.writeFloatLE(buffer, val2, offset);\n        encode.bytes = 4;\n        return buffer;\n      },\n      function decode(buffer, offset) {\n        var val2 = b4a.readFloatLE(buffer, offset);\n        decode.bytes = 4;\n        return val2;\n      },\n      function encodingLength() {\n        return 4;\n      }\n    );\n    function encoder(type, encode, decode, encodingLength) {\n      encode.bytes = decode.bytes = 0;\n      return {\n        type,\n        encode,\n        decode,\n        encodingLength\n      };\n    }\n    function bufferLength(val2) {\n      return b4a.isBuffer(val2) ? val2.length : b4a.byteLength(val2);\n    }\n  }\n});\n\n// node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js\nvar require_messages = __commonJS({\n  \"node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js\"(exports) {\n    init_inject_globals();\n    var encodings = require_protocol_buffers_encodings();\n    var varint = encodings.varint;\n    var skip = encodings.skip;\n    var NoisePayload = exports.NoisePayload = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Open = exports.Open = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Options = exports.Options = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Status = exports.Status = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Have = exports.Have = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Unhave = exports.Unhave = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Want = exports.Want = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Unwant = exports.Unwant = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Request = exports.Request = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Cancel = exports.Cancel = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Data = exports.Data = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    var Close = exports.Close = {\n      buffer: true,\n      encodingLength: null,\n      encode: null,\n      decode: null\n    };\n    defineNoisePayload();\n    defineOpen();\n    defineOptions();\n    defineStatus();\n    defineHave();\n    defineUnhave();\n    defineWant();\n    defineUnwant();\n    defineRequest();\n    defineCancel();\n    defineData();\n    defineClose();\n    function defineNoisePayload() {\n      var enc = [\n        encodings.bytes\n      ];\n      NoisePayload.encodingLength = encodingLength;\n      NoisePayload.encode = encode;\n      NoisePayload.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.nonce))\n          throw new Error(\"nonce is required\");\n        var len = enc[0].encodingLength(obj.nonce);\n        length += 1 + len;\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.nonce))\n          throw new Error(\"nonce is required\");\n        buf[offset++] = 10;\n        enc[0].encode(obj.nonce, buf, offset);\n        offset += enc[0].encode.bytes;\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          nonce: null\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.nonce = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineOpen() {\n      var enc = [\n        encodings.bytes\n      ];\n      Open.encodingLength = encodingLength;\n      Open.encode = encode;\n      Open.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.discoveryKey))\n          throw new Error(\"discoveryKey is required\");\n        var len = enc[0].encodingLength(obj.discoveryKey);\n        length += 1 + len;\n        if (defined(obj.capability)) {\n          var len = enc[0].encodingLength(obj.capability);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.discoveryKey))\n          throw new Error(\"discoveryKey is required\");\n        buf[offset++] = 10;\n        enc[0].encode(obj.discoveryKey, buf, offset);\n        offset += enc[0].encode.bytes;\n        if (defined(obj.capability)) {\n          buf[offset++] = 18;\n          enc[0].encode(obj.capability, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          discoveryKey: null,\n          capability: null\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.discoveryKey = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            case 2:\n              obj.capability = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineOptions() {\n      var enc = [\n        encodings.string,\n        encodings.bool\n      ];\n      Options.encodingLength = encodingLength;\n      Options.encode = encode;\n      Options.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (defined(obj.extensions)) {\n          for (var i = 0; i < obj.extensions.length; i++) {\n            if (!defined(obj.extensions[i]))\n              continue;\n            var len = enc[0].encodingLength(obj.extensions[i]);\n            length += 1 + len;\n          }\n        }\n        if (defined(obj.ack)) {\n          var len = enc[1].encodingLength(obj.ack);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (defined(obj.extensions)) {\n          for (var i = 0; i < obj.extensions.length; i++) {\n            if (!defined(obj.extensions[i]))\n              continue;\n            buf[offset++] = 10;\n            enc[0].encode(obj.extensions[i], buf, offset);\n            offset += enc[0].encode.bytes;\n          }\n        }\n        if (defined(obj.ack)) {\n          buf[offset++] = 16;\n          enc[1].encode(obj.ack, buf, offset);\n          offset += enc[1].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          extensions: [],\n          ack: false\n        };\n        while (true) {\n          if (end <= offset) {\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.extensions.push(enc[0].decode(buf, offset));\n              offset += enc[0].decode.bytes;\n              break;\n            case 2:\n              obj.ack = enc[1].decode(buf, offset);\n              offset += enc[1].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineStatus() {\n      var enc = [\n        encodings.bool\n      ];\n      Status.encodingLength = encodingLength;\n      Status.encode = encode;\n      Status.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (defined(obj.uploading)) {\n          var len = enc[0].encodingLength(obj.uploading);\n          length += 1 + len;\n        }\n        if (defined(obj.downloading)) {\n          var len = enc[0].encodingLength(obj.downloading);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (defined(obj.uploading)) {\n          buf[offset++] = 8;\n          enc[0].encode(obj.uploading, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        if (defined(obj.downloading)) {\n          buf[offset++] = 16;\n          enc[0].encode(obj.downloading, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          uploading: false,\n          downloading: false\n        };\n        while (true) {\n          if (end <= offset) {\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.uploading = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            case 2:\n              obj.downloading = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineHave() {\n      var enc = [\n        encodings.varint,\n        encodings.bytes,\n        encodings.bool\n      ];\n      Have.encodingLength = encodingLength;\n      Have.encode = encode;\n      Have.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.start))\n          throw new Error(\"start is required\");\n        var len = enc[0].encodingLength(obj.start);\n        length += 1 + len;\n        if (defined(obj.length)) {\n          var len = enc[0].encodingLength(obj.length);\n          length += 1 + len;\n        }\n        if (defined(obj.bitfield)) {\n          var len = enc[1].encodingLength(obj.bitfield);\n          length += 1 + len;\n        }\n        if (defined(obj.ack)) {\n          var len = enc[2].encodingLength(obj.ack);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.start))\n          throw new Error(\"start is required\");\n        buf[offset++] = 8;\n        enc[0].encode(obj.start, buf, offset);\n        offset += enc[0].encode.bytes;\n        if (defined(obj.length)) {\n          buf[offset++] = 16;\n          enc[0].encode(obj.length, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        if (defined(obj.bitfield)) {\n          buf[offset++] = 26;\n          enc[1].encode(obj.bitfield, buf, offset);\n          offset += enc[1].encode.bytes;\n        }\n        if (defined(obj.ack)) {\n          buf[offset++] = 32;\n          enc[2].encode(obj.ack, buf, offset);\n          offset += enc[2].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          start: 0,\n          length: 1,\n          bitfield: null,\n          ack: false\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.start = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            case 2:\n              obj.length = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            case 3:\n              obj.bitfield = enc[1].decode(buf, offset);\n              offset += enc[1].decode.bytes;\n              break;\n            case 4:\n              obj.ack = enc[2].decode(buf, offset);\n              offset += enc[2].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineUnhave() {\n      var enc = [\n        encodings.varint\n      ];\n      Unhave.encodingLength = encodingLength;\n      Unhave.encode = encode;\n      Unhave.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.start))\n          throw new Error(\"start is required\");\n        var len = enc[0].encodingLength(obj.start);\n        length += 1 + len;\n        if (defined(obj.length)) {\n          var len = enc[0].encodingLength(obj.length);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.start))\n          throw new Error(\"start is required\");\n        buf[offset++] = 8;\n        enc[0].encode(obj.start, buf, offset);\n        offset += enc[0].encode.bytes;\n        if (defined(obj.length)) {\n          buf[offset++] = 16;\n          enc[0].encode(obj.length, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          start: 0,\n          length: 1\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.start = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            case 2:\n              obj.length = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineWant() {\n      var enc = [\n        encodings.varint\n      ];\n      Want.encodingLength = encodingLength;\n      Want.encode = encode;\n      Want.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.start))\n          throw new Error(\"start is required\");\n        var len = enc[0].encodingLength(obj.start);\n        length += 1 + len;\n        if (defined(obj.length)) {\n          var len = enc[0].encodingLength(obj.length);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.start))\n          throw new Error(\"start is required\");\n        buf[offset++] = 8;\n        enc[0].encode(obj.start, buf, offset);\n        offset += enc[0].encode.bytes;\n        if (defined(obj.length)) {\n          buf[offset++] = 16;\n          enc[0].encode(obj.length, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          start: 0,\n          length: 0\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.start = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            case 2:\n              obj.length = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineUnwant() {\n      var enc = [\n        encodings.varint\n      ];\n      Unwant.encodingLength = encodingLength;\n      Unwant.encode = encode;\n      Unwant.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.start))\n          throw new Error(\"start is required\");\n        var len = enc[0].encodingLength(obj.start);\n        length += 1 + len;\n        if (defined(obj.length)) {\n          var len = enc[0].encodingLength(obj.length);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.start))\n          throw new Error(\"start is required\");\n        buf[offset++] = 8;\n        enc[0].encode(obj.start, buf, offset);\n        offset += enc[0].encode.bytes;\n        if (defined(obj.length)) {\n          buf[offset++] = 16;\n          enc[0].encode(obj.length, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          start: 0,\n          length: 0\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.start = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            case 2:\n              obj.length = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineRequest() {\n      var enc = [\n        encodings.varint,\n        encodings.bool\n      ];\n      Request.encodingLength = encodingLength;\n      Request.encode = encode;\n      Request.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.index))\n          throw new Error(\"index is required\");\n        var len = enc[0].encodingLength(obj.index);\n        length += 1 + len;\n        if (defined(obj.bytes)) {\n          var len = enc[0].encodingLength(obj.bytes);\n          length += 1 + len;\n        }\n        if (defined(obj.hash)) {\n          var len = enc[1].encodingLength(obj.hash);\n          length += 1 + len;\n        }\n        if (defined(obj.nodes)) {\n          var len = enc[0].encodingLength(obj.nodes);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.index))\n          throw new Error(\"index is required\");\n        buf[offset++] = 8;\n        enc[0].encode(obj.index, buf, offset);\n        offset += enc[0].encode.bytes;\n        if (defined(obj.bytes)) {\n          buf[offset++] = 16;\n          enc[0].encode(obj.bytes, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        if (defined(obj.hash)) {\n          buf[offset++] = 24;\n          enc[1].encode(obj.hash, buf, offset);\n          offset += enc[1].encode.bytes;\n        }\n        if (defined(obj.nodes)) {\n          buf[offset++] = 32;\n          enc[0].encode(obj.nodes, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          index: 0,\n          bytes: 0,\n          hash: false,\n          nodes: 0\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.index = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            case 2:\n              obj.bytes = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            case 3:\n              obj.hash = enc[1].decode(buf, offset);\n              offset += enc[1].decode.bytes;\n              break;\n            case 4:\n              obj.nodes = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineCancel() {\n      var enc = [\n        encodings.varint,\n        encodings.bool\n      ];\n      Cancel.encodingLength = encodingLength;\n      Cancel.encode = encode;\n      Cancel.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.index))\n          throw new Error(\"index is required\");\n        var len = enc[0].encodingLength(obj.index);\n        length += 1 + len;\n        if (defined(obj.bytes)) {\n          var len = enc[0].encodingLength(obj.bytes);\n          length += 1 + len;\n        }\n        if (defined(obj.hash)) {\n          var len = enc[1].encodingLength(obj.hash);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.index))\n          throw new Error(\"index is required\");\n        buf[offset++] = 8;\n        enc[0].encode(obj.index, buf, offset);\n        offset += enc[0].encode.bytes;\n        if (defined(obj.bytes)) {\n          buf[offset++] = 16;\n          enc[0].encode(obj.bytes, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        if (defined(obj.hash)) {\n          buf[offset++] = 24;\n          enc[1].encode(obj.hash, buf, offset);\n          offset += enc[1].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          index: 0,\n          bytes: 0,\n          hash: false\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.index = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            case 2:\n              obj.bytes = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            case 3:\n              obj.hash = enc[1].decode(buf, offset);\n              offset += enc[1].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineData() {\n      var Node = Data.Node = {\n        buffer: true,\n        encodingLength: null,\n        encode: null,\n        decode: null\n      };\n      defineNode();\n      function defineNode() {\n        var enc2 = [\n          encodings.varint,\n          encodings.bytes\n        ];\n        Node.encodingLength = encodingLength2;\n        Node.encode = encode2;\n        Node.decode = decode2;\n        function encodingLength2(obj) {\n          var length = 0;\n          if (!defined(obj.index))\n            throw new Error(\"index is required\");\n          var len = enc2[0].encodingLength(obj.index);\n          length += 1 + len;\n          if (!defined(obj.hash))\n            throw new Error(\"hash is required\");\n          var len = enc2[1].encodingLength(obj.hash);\n          length += 1 + len;\n          if (!defined(obj.size))\n            throw new Error(\"size is required\");\n          var len = enc2[0].encodingLength(obj.size);\n          length += 1 + len;\n          return length;\n        }\n        function encode2(obj, buf, offset) {\n          if (!offset)\n            offset = 0;\n          if (!buf)\n            buf = Buffer2.allocUnsafe(encodingLength2(obj));\n          var oldOffset = offset;\n          if (!defined(obj.index))\n            throw new Error(\"index is required\");\n          buf[offset++] = 8;\n          enc2[0].encode(obj.index, buf, offset);\n          offset += enc2[0].encode.bytes;\n          if (!defined(obj.hash))\n            throw new Error(\"hash is required\");\n          buf[offset++] = 18;\n          enc2[1].encode(obj.hash, buf, offset);\n          offset += enc2[1].encode.bytes;\n          if (!defined(obj.size))\n            throw new Error(\"size is required\");\n          buf[offset++] = 24;\n          enc2[0].encode(obj.size, buf, offset);\n          offset += enc2[0].encode.bytes;\n          encode2.bytes = offset - oldOffset;\n          return buf;\n        }\n        function decode2(buf, offset, end) {\n          if (!offset)\n            offset = 0;\n          if (!end)\n            end = buf.length;\n          if (!(end <= buf.length && offset <= buf.length))\n            throw new Error(\"Decoded message is not valid\");\n          var oldOffset = offset;\n          var obj = {\n            index: 0,\n            hash: null,\n            size: 0\n          };\n          var found0 = false;\n          var found1 = false;\n          var found2 = false;\n          while (true) {\n            if (end <= offset) {\n              if (!found0 || !found1 || !found2)\n                throw new Error(\"Decoded message is not valid\");\n              decode2.bytes = offset - oldOffset;\n              return obj;\n            }\n            var prefix = varint.decode(buf, offset);\n            offset += varint.decode.bytes;\n            var tag = prefix >> 3;\n            switch (tag) {\n              case 1:\n                obj.index = enc2[0].decode(buf, offset);\n                offset += enc2[0].decode.bytes;\n                found0 = true;\n                break;\n              case 2:\n                obj.hash = enc2[1].decode(buf, offset);\n                offset += enc2[1].decode.bytes;\n                found1 = true;\n                break;\n              case 3:\n                obj.size = enc2[0].decode(buf, offset);\n                offset += enc2[0].decode.bytes;\n                found2 = true;\n                break;\n              default:\n                offset = skip(prefix & 7, buf, offset);\n            }\n          }\n        }\n      }\n      var enc = [\n        encodings.varint,\n        encodings.bytes,\n        Node\n      ];\n      Data.encodingLength = encodingLength;\n      Data.encode = encode;\n      Data.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (!defined(obj.index))\n          throw new Error(\"index is required\");\n        var len = enc[0].encodingLength(obj.index);\n        length += 1 + len;\n        if (defined(obj.value)) {\n          var len = enc[1].encodingLength(obj.value);\n          length += 1 + len;\n        }\n        if (defined(obj.nodes)) {\n          for (var i = 0; i < obj.nodes.length; i++) {\n            if (!defined(obj.nodes[i]))\n              continue;\n            var len = enc[2].encodingLength(obj.nodes[i]);\n            length += varint.encodingLength(len);\n            length += 1 + len;\n          }\n        }\n        if (defined(obj.signature)) {\n          var len = enc[1].encodingLength(obj.signature);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (!defined(obj.index))\n          throw new Error(\"index is required\");\n        buf[offset++] = 8;\n        enc[0].encode(obj.index, buf, offset);\n        offset += enc[0].encode.bytes;\n        if (defined(obj.value)) {\n          buf[offset++] = 18;\n          enc[1].encode(obj.value, buf, offset);\n          offset += enc[1].encode.bytes;\n        }\n        if (defined(obj.nodes)) {\n          for (var i = 0; i < obj.nodes.length; i++) {\n            if (!defined(obj.nodes[i]))\n              continue;\n            buf[offset++] = 26;\n            varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset);\n            offset += varint.encode.bytes;\n            enc[2].encode(obj.nodes[i], buf, offset);\n            offset += enc[2].encode.bytes;\n          }\n        }\n        if (defined(obj.signature)) {\n          buf[offset++] = 34;\n          enc[1].encode(obj.signature, buf, offset);\n          offset += enc[1].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          index: 0,\n          value: null,\n          nodes: [],\n          signature: null\n        };\n        var found0 = false;\n        while (true) {\n          if (end <= offset) {\n            if (!found0)\n              throw new Error(\"Decoded message is not valid\");\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.index = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              found0 = true;\n              break;\n            case 2:\n              obj.value = enc[1].decode(buf, offset);\n              offset += enc[1].decode.bytes;\n              break;\n            case 3:\n              var len = varint.decode(buf, offset);\n              offset += varint.decode.bytes;\n              obj.nodes.push(enc[2].decode(buf, offset, offset + len));\n              offset += enc[2].decode.bytes;\n              break;\n            case 4:\n              obj.signature = enc[1].decode(buf, offset);\n              offset += enc[1].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defineClose() {\n      var enc = [\n        encodings.bytes\n      ];\n      Close.encodingLength = encodingLength;\n      Close.encode = encode;\n      Close.decode = decode;\n      function encodingLength(obj) {\n        var length = 0;\n        if (defined(obj.discoveryKey)) {\n          var len = enc[0].encodingLength(obj.discoveryKey);\n          length += 1 + len;\n        }\n        return length;\n      }\n      function encode(obj, buf, offset) {\n        if (!offset)\n          offset = 0;\n        if (!buf)\n          buf = Buffer2.allocUnsafe(encodingLength(obj));\n        var oldOffset = offset;\n        if (defined(obj.discoveryKey)) {\n          buf[offset++] = 10;\n          enc[0].encode(obj.discoveryKey, buf, offset);\n          offset += enc[0].encode.bytes;\n        }\n        encode.bytes = offset - oldOffset;\n        return buf;\n      }\n      function decode(buf, offset, end) {\n        if (!offset)\n          offset = 0;\n        if (!end)\n          end = buf.length;\n        if (!(end <= buf.length && offset <= buf.length))\n          throw new Error(\"Decoded message is not valid\");\n        var oldOffset = offset;\n        var obj = {\n          discoveryKey: null\n        };\n        while (true) {\n          if (end <= offset) {\n            decode.bytes = offset - oldOffset;\n            return obj;\n          }\n          var prefix = varint.decode(buf, offset);\n          offset += varint.decode.bytes;\n          var tag = prefix >> 3;\n          switch (tag) {\n            case 1:\n              obj.discoveryKey = enc[0].decode(buf, offset);\n              offset += enc[0].decode.bytes;\n              break;\n            default:\n              offset = skip(prefix & 7, buf, offset);\n          }\n        }\n      }\n    }\n    function defined(val2) {\n      return val2 !== null && val2 !== void 0 && (typeof val2 !== \"number\" || !isNaN(val2));\n    }\n  }\n});\n\n// node_modules/.pnpm/xsalsa20@1.2.0/node_modules/xsalsa20/xsalsa20.js\nvar require_xsalsa20 = __commonJS({\n  \"node_modules/.pnpm/xsalsa20@1.2.0/node_modules/xsalsa20/xsalsa20.js\"(exports, module) {\n    init_inject_globals();\n    var __commonJS2 = (cb, mod) => function __require2() {\n      return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n    };\n    var __toBinary = /* @__PURE__ */ (() => {\n      var table = new Uint8Array(128);\n      for (var i = 0; i < 64; i++)\n        table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;\n      return (base64) => {\n        var n = base64.length, bytes2 = new Uint8Array((n - (base64[n - 1] == \"=\") - (base64[n - 2] == \"=\")) * 3 / 4 | 0);\n        for (var i2 = 0, j = 0; i2 < n; ) {\n          var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];\n          var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];\n          bytes2[j++] = c0 << 2 | c1 >> 4;\n          bytes2[j++] = c1 << 4 | c2 >> 2;\n          bytes2[j++] = c2 << 6 | c3;\n        }\n        return bytes2;\n      };\n    })();\n    var require_xsalsa203 = __commonJS2({\n      \"wasm-binary:./xsalsa20.wat\"(exports2, module2) {\n        module2.exports = __toBinary(\"AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL\");\n      }\n    });\n    var bytes = require_xsalsa203();\n    var compiled = new WebAssembly.Module(bytes);\n    module.exports = (imports) => {\n      const instance = new WebAssembly.Instance(compiled, imports);\n      return instance.exports;\n    };\n  }\n});\n\n// node_modules/.pnpm/xsalsa20@1.2.0/node_modules/xsalsa20/index.js\nvar require_xsalsa202 = __commonJS({\n  \"node_modules/.pnpm/xsalsa20@1.2.0/node_modules/xsalsa20/index.js\"(exports, module) {\n    init_inject_globals();\n    var xsalsa20 = typeof WebAssembly !== \"undefined\" && require_xsalsa20()();\n    var SIGMA = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n    var head = 144;\n    var top = head;\n    var free = [];\n    module.exports = XSalsa20;\n    XSalsa20.NONCEBYTES = 24;\n    XSalsa20.KEYBYTES = 32;\n    XSalsa20.core_hsalsa20 = core_hsalsa20;\n    XSalsa20.SIGMA = SIGMA;\n    function XSalsa20(nonce, key) {\n      if (!(this instanceof XSalsa20))\n        return new XSalsa20(nonce, key);\n      if (!nonce || nonce.length < 24)\n        throw new Error(\"nonce must be at least 24 bytes\");\n      if (!key || key.length < 32)\n        throw new Error(\"key must be at least 32 bytes\");\n      this._xor = xsalsa20 ? new WASM(nonce, key) : new Fallback(nonce, key);\n    }\n    XSalsa20.prototype.update = function(input, output) {\n      if (!input)\n        throw new Error(\"input must be Uint8Array or Buffer\");\n      if (!output)\n        output = new Uint8Array(input.length);\n      if (input.length)\n        this._xor.update(input, output);\n      return output;\n    };\n    XSalsa20.prototype.final = XSalsa20.prototype.finalize = function() {\n      this._xor.finalize();\n      this._xor = null;\n    };\n    function WASM(nonce, key) {\n      if (!free.length) {\n        free.push(head);\n        head += 64;\n      }\n      this._pointer = free.pop();\n      this._nonce = this._pointer + 8;\n      this._key = this._nonce + 24;\n      this._overflow = 0;\n      this._memory = new Uint8Array(xsalsa20.memory.buffer);\n      this._memory.fill(0, this._pointer, this._pointer + 8);\n      this._memory.set(nonce, this._nonce);\n      this._memory.set(key, this._key);\n    }\n    WASM.prototype.realloc = function(size) {\n      xsalsa20.memory.grow(Math.ceil(Math.abs(size - this._memory.length) / 65536));\n      this._memory = new Uint8Array(xsalsa20.memory.buffer);\n    };\n    WASM.prototype.update = function(input, output) {\n      var len = this._overflow + input.length;\n      var start = head + this._overflow;\n      top = head + len;\n      if (top >= this._memory.length)\n        this.realloc(top);\n      this._memory.set(input, start);\n      xsalsa20.xsalsa20_xor(this._pointer, head, head, len, this._nonce, this._key);\n      output.set(this._memory.subarray(start, head + len));\n      this._overflow = len & 63;\n    };\n    WASM.prototype.finalize = function() {\n      this._memory.fill(0, this._pointer, this._key + 32);\n      if (top > head) {\n        this._memory.fill(0, head, top);\n        top = 0;\n      }\n      free.push(this._pointer);\n    };\n    function Fallback(nonce, key) {\n      this._s = new Uint8Array(32);\n      this._z = new Uint8Array(16);\n      this._overflow = 0;\n      core_hsalsa20(this._s, nonce, key, SIGMA);\n      for (var i = 0; i < 8; i++)\n        this._z[i] = nonce[i + 16];\n    }\n    Fallback.prototype.update = function(input, output) {\n      var x = new Uint8Array(64);\n      var u = 0;\n      var i = this._overflow;\n      var b = input.length + this._overflow;\n      var z = this._z;\n      var mpos = -this._overflow;\n      var cpos = -this._overflow;\n      while (b >= 64) {\n        core_salsa20(x, z, this._s, SIGMA);\n        for (; i < 64; i++)\n          output[cpos + i] = input[mpos + i] ^ x[i];\n        u = 1;\n        for (i = 8; i < 16; i++) {\n          u += z[i] & 255 | 0;\n          z[i] = u & 255;\n          u >>>= 8;\n        }\n        b -= 64;\n        cpos += 64;\n        mpos += 64;\n        i = 0;\n      }\n      if (b > 0) {\n        core_salsa20(x, z, this._s, SIGMA);\n        for (; i < b; i++)\n          output[cpos + i] = input[mpos + i] ^ x[i];\n      }\n      this._overflow = b & 63;\n    };\n    Fallback.prototype.finalize = function() {\n      this._s.fill(0);\n      this._z.fill(0);\n    };\n    function core_salsa20(o, p, k, c) {\n      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;\n      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;\n      for (var i = 0; i < 20; i += 2) {\n        u = x0 + x12 | 0;\n        x4 ^= u << 7 | u >>> 25;\n        u = x4 + x0 | 0;\n        x8 ^= u << 9 | u >>> 23;\n        u = x8 + x4 | 0;\n        x12 ^= u << 13 | u >>> 19;\n        u = x12 + x8 | 0;\n        x0 ^= u << 18 | u >>> 14;\n        u = x5 + x1 | 0;\n        x9 ^= u << 7 | u >>> 25;\n        u = x9 + x5 | 0;\n        x13 ^= u << 9 | u >>> 23;\n        u = x13 + x9 | 0;\n        x1 ^= u << 13 | u >>> 19;\n        u = x1 + x13 | 0;\n        x5 ^= u << 18 | u >>> 14;\n        u = x10 + x6 | 0;\n        x14 ^= u << 7 | u >>> 25;\n        u = x14 + x10 | 0;\n        x2 ^= u << 9 | u >>> 23;\n        u = x2 + x14 | 0;\n        x6 ^= u << 13 | u >>> 19;\n        u = x6 + x2 | 0;\n        x10 ^= u << 18 | u >>> 14;\n        u = x15 + x11 | 0;\n        x3 ^= u << 7 | u >>> 25;\n        u = x3 + x15 | 0;\n        x7 ^= u << 9 | u >>> 23;\n        u = x7 + x3 | 0;\n        x11 ^= u << 13 | u >>> 19;\n        u = x11 + x7 | 0;\n        x15 ^= u << 18 | u >>> 14;\n        u = x0 + x3 | 0;\n        x1 ^= u << 7 | u >>> 25;\n        u = x1 + x0 | 0;\n        x2 ^= u << 9 | u >>> 23;\n        u = x2 + x1 | 0;\n        x3 ^= u << 13 | u >>> 19;\n        u = x3 + x2 | 0;\n        x0 ^= u << 18 | u >>> 14;\n        u = x5 + x4 | 0;\n        x6 ^= u << 7 | u >>> 25;\n        u = x6 + x5 | 0;\n        x7 ^= u << 9 | u >>> 23;\n        u = x7 + x6 | 0;\n        x4 ^= u << 13 | u >>> 19;\n        u = x4 + x7 | 0;\n        x5 ^= u << 18 | u >>> 14;\n        u = x10 + x9 | 0;\n        x11 ^= u << 7 | u >>> 25;\n        u = x11 + x10 | 0;\n        x8 ^= u << 9 | u >>> 23;\n        u = x8 + x11 | 0;\n        x9 ^= u << 13 | u >>> 19;\n        u = x9 + x8 | 0;\n        x10 ^= u << 18 | u >>> 14;\n        u = x15 + x14 | 0;\n        x12 ^= u << 7 | u >>> 25;\n        u = x12 + x15 | 0;\n        x13 ^= u << 9 | u >>> 23;\n        u = x13 + x12 | 0;\n        x14 ^= u << 13 | u >>> 19;\n        u = x14 + x13 | 0;\n        x15 ^= u << 18 | u >>> 14;\n      }\n      x0 = x0 + j0 | 0;\n      x1 = x1 + j1 | 0;\n      x2 = x2 + j2 | 0;\n      x3 = x3 + j3 | 0;\n      x4 = x4 + j4 | 0;\n      x5 = x5 + j5 | 0;\n      x6 = x6 + j6 | 0;\n      x7 = x7 + j7 | 0;\n      x8 = x8 + j8 | 0;\n      x9 = x9 + j9 | 0;\n      x10 = x10 + j10 | 0;\n      x11 = x11 + j11 | 0;\n      x12 = x12 + j12 | 0;\n      x13 = x13 + j13 | 0;\n      x14 = x14 + j14 | 0;\n      x15 = x15 + j15 | 0;\n      o[0] = x0 >>> 0 & 255;\n      o[1] = x0 >>> 8 & 255;\n      o[2] = x0 >>> 16 & 255;\n      o[3] = x0 >>> 24 & 255;\n      o[4] = x1 >>> 0 & 255;\n      o[5] = x1 >>> 8 & 255;\n      o[6] = x1 >>> 16 & 255;\n      o[7] = x1 >>> 24 & 255;\n      o[8] = x2 >>> 0 & 255;\n      o[9] = x2 >>> 8 & 255;\n      o[10] = x2 >>> 16 & 255;\n      o[11] = x2 >>> 24 & 255;\n      o[12] = x3 >>> 0 & 255;\n      o[13] = x3 >>> 8 & 255;\n      o[14] = x3 >>> 16 & 255;\n      o[15] = x3 >>> 24 & 255;\n      o[16] = x4 >>> 0 & 255;\n      o[17] = x4 >>> 8 & 255;\n      o[18] = x4 >>> 16 & 255;\n      o[19] = x4 >>> 24 & 255;\n      o[20] = x5 >>> 0 & 255;\n      o[21] = x5 >>> 8 & 255;\n      o[22] = x5 >>> 16 & 255;\n      o[23] = x5 >>> 24 & 255;\n      o[24] = x6 >>> 0 & 255;\n      o[25] = x6 >>> 8 & 255;\n      o[26] = x6 >>> 16 & 255;\n      o[27] = x6 >>> 24 & 255;\n      o[28] = x7 >>> 0 & 255;\n      o[29] = x7 >>> 8 & 255;\n      o[30] = x7 >>> 16 & 255;\n      o[31] = x7 >>> 24 & 255;\n      o[32] = x8 >>> 0 & 255;\n      o[33] = x8 >>> 8 & 255;\n      o[34] = x8 >>> 16 & 255;\n      o[35] = x8 >>> 24 & 255;\n      o[36] = x9 >>> 0 & 255;\n      o[37] = x9 >>> 8 & 255;\n      o[38] = x9 >>> 16 & 255;\n      o[39] = x9 >>> 24 & 255;\n      o[40] = x10 >>> 0 & 255;\n      o[41] = x10 >>> 8 & 255;\n      o[42] = x10 >>> 16 & 255;\n      o[43] = x10 >>> 24 & 255;\n      o[44] = x11 >>> 0 & 255;\n      o[45] = x11 >>> 8 & 255;\n      o[46] = x11 >>> 16 & 255;\n      o[47] = x11 >>> 24 & 255;\n      o[48] = x12 >>> 0 & 255;\n      o[49] = x12 >>> 8 & 255;\n      o[50] = x12 >>> 16 & 255;\n      o[51] = x12 >>> 24 & 255;\n      o[52] = x13 >>> 0 & 255;\n      o[53] = x13 >>> 8 & 255;\n      o[54] = x13 >>> 16 & 255;\n      o[55] = x13 >>> 24 & 255;\n      o[56] = x14 >>> 0 & 255;\n      o[57] = x14 >>> 8 & 255;\n      o[58] = x14 >>> 16 & 255;\n      o[59] = x14 >>> 24 & 255;\n      o[60] = x15 >>> 0 & 255;\n      o[61] = x15 >>> 8 & 255;\n      o[62] = x15 >>> 16 & 255;\n      o[63] = x15 >>> 24 & 255;\n    }\n    function core_hsalsa20(o, p, k, c) {\n      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;\n      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;\n      for (var i = 0; i < 20; i += 2) {\n        u = x0 + x12 | 0;\n        x4 ^= u << 7 | u >>> 25;\n        u = x4 + x0 | 0;\n        x8 ^= u << 9 | u >>> 23;\n        u = x8 + x4 | 0;\n        x12 ^= u << 13 | u >>> 19;\n        u = x12 + x8 | 0;\n        x0 ^= u << 18 | u >>> 14;\n        u = x5 + x1 | 0;\n        x9 ^= u << 7 | u >>> 25;\n        u = x9 + x5 | 0;\n        x13 ^= u << 9 | u >>> 23;\n        u = x13 + x9 | 0;\n        x1 ^= u << 13 | u >>> 19;\n        u = x1 + x13 | 0;\n        x5 ^= u << 18 | u >>> 14;\n        u = x10 + x6 | 0;\n        x14 ^= u << 7 | u >>> 25;\n        u = x14 + x10 | 0;\n        x2 ^= u << 9 | u >>> 23;\n        u = x2 + x14 | 0;\n        x6 ^= u << 13 | u >>> 19;\n        u = x6 + x2 | 0;\n        x10 ^= u << 18 | u >>> 14;\n        u = x15 + x11 | 0;\n        x3 ^= u << 7 | u >>> 25;\n        u = x3 + x15 | 0;\n        x7 ^= u << 9 | u >>> 23;\n        u = x7 + x3 | 0;\n        x11 ^= u << 13 | u >>> 19;\n        u = x11 + x7 | 0;\n        x15 ^= u << 18 | u >>> 14;\n        u = x0 + x3 | 0;\n        x1 ^= u << 7 | u >>> 25;\n        u = x1 + x0 | 0;\n        x2 ^= u << 9 | u >>> 23;\n        u = x2 + x1 | 0;\n        x3 ^= u << 13 | u >>> 19;\n        u = x3 + x2 | 0;\n        x0 ^= u << 18 | u >>> 14;\n        u = x5 + x4 | 0;\n        x6 ^= u << 7 | u >>> 25;\n        u = x6 + x5 | 0;\n        x7 ^= u << 9 | u >>> 23;\n        u = x7 + x6 | 0;\n        x4 ^= u << 13 | u >>> 19;\n        u = x4 + x7 | 0;\n        x5 ^= u << 18 | u >>> 14;\n        u = x10 + x9 | 0;\n        x11 ^= u << 7 | u >>> 25;\n        u = x11 + x10 | 0;\n        x8 ^= u << 9 | u >>> 23;\n        u = x8 + x11 | 0;\n        x9 ^= u << 13 | u >>> 19;\n        u = x9 + x8 | 0;\n        x10 ^= u << 18 | u >>> 14;\n        u = x15 + x14 | 0;\n        x12 ^= u << 7 | u >>> 25;\n        u = x12 + x15 | 0;\n        x13 ^= u << 9 | u >>> 23;\n        u = x13 + x12 | 0;\n        x14 ^= u << 13 | u >>> 19;\n        u = x14 + x13 | 0;\n        x15 ^= u << 18 | u >>> 14;\n      }\n      o[0] = x0 >>> 0 & 255;\n      o[1] = x0 >>> 8 & 255;\n      o[2] = x0 >>> 16 & 255;\n      o[3] = x0 >>> 24 & 255;\n      o[4] = x5 >>> 0 & 255;\n      o[5] = x5 >>> 8 & 255;\n      o[6] = x5 >>> 16 & 255;\n      o[7] = x5 >>> 24 & 255;\n      o[8] = x10 >>> 0 & 255;\n      o[9] = x10 >>> 8 & 255;\n      o[10] = x10 >>> 16 & 255;\n      o[11] = x10 >>> 24 & 255;\n      o[12] = x15 >>> 0 & 255;\n      o[13] = x15 >>> 8 & 255;\n      o[14] = x15 >>> 16 & 255;\n      o[15] = x15 >>> 24 & 255;\n      o[16] = x6 >>> 0 & 255;\n      o[17] = x6 >>> 8 & 255;\n      o[18] = x6 >>> 16 & 255;\n      o[19] = x6 >>> 24 & 255;\n      o[20] = x7 >>> 0 & 255;\n      o[21] = x7 >>> 8 & 255;\n      o[22] = x7 >>> 16 & 255;\n      o[23] = x7 >>> 24 & 255;\n      o[24] = x8 >>> 0 & 255;\n      o[25] = x8 >>> 8 & 255;\n      o[26] = x8 >>> 16 & 255;\n      o[27] = x8 >>> 24 & 255;\n      o[28] = x9 >>> 0 & 255;\n      o[29] = x9 >>> 8 & 255;\n      o[30] = x9 >>> 16 & 255;\n      o[31] = x9 >>> 24 & 255;\n    }\n  }\n});\n\n// node_modules/.pnpm/xsalsa20-universal@1.0.0/node_modules/xsalsa20-universal/browser.js\nvar require_browser3 = __commonJS({\n  \"node_modules/.pnpm/xsalsa20-universal@1.0.0/node_modules/xsalsa20-universal/browser.js\"(exports, module) {\n    init_inject_globals();\n    var xsalsa20 = require_xsalsa202();\n    module.exports = class XORJS {\n      constructor(nonce, key) {\n        this.instance = xsalsa20(nonce, key);\n      }\n      update(out, message) {\n        this.instance.update(message, out);\n      }\n      final() {\n        this.instance.finalize();\n      }\n    };\n  }\n});\n\n// node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/xor.js\nvar require_xor = __commonJS({\n  \"node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/xor.js\"(exports, module) {\n    init_inject_globals();\n    var XSalsa20 = require_browser3();\n    var crypto = require_hypercore_crypto();\n    module.exports = class XOR {\n      constructor(nonces, split) {\n        this.rnonce = nonces.rnonce;\n        this.tnonce = nonces.tnonce;\n        this.rx = new XSalsa20(this.rnonce, split.rx.slice(0, 32));\n        this.tx = new XSalsa20(this.tnonce, split.tx.slice(0, 32));\n      }\n      encrypt(data) {\n        this.tx.update(data, data);\n        return data;\n      }\n      decrypt(data) {\n        this.rx.update(data, data);\n        return data;\n      }\n      destroy() {\n        this.tx.final();\n        this.rx.final();\n      }\n      static nonce() {\n        return crypto.randomBytes(24);\n      }\n    };\n  }\n});\n\n// node_modules/.pnpm/simple-message-channels@1.2.1/node_modules/simple-message-channels/index.js\nvar require_simple_message_channels = __commonJS({\n  \"node_modules/.pnpm/simple-message-channels@1.2.1/node_modules/simple-message-channels/index.js\"(exports, module) {\n    init_inject_globals();\n    var varint = require_varint2();\n    module.exports = class SimpleMessageChannels {\n      constructor({ maxSize = 8 * 1024 * 1024, context = null, onmessage = null, onmissing = null, types = null } = {}) {\n        this._message = null;\n        this._ptr = 0;\n        this._varint = 0;\n        this._factor = 1;\n        this._length = 0;\n        this._header = 0;\n        this._state = 0;\n        this._consumed = 0;\n        this._maxSize = maxSize;\n        this._types = types || [];\n        this.receiving = false;\n        this.destroyed = false;\n        this.error = null;\n        this.context = context;\n        this.onmessage = onmessage;\n        this.onmissing = onmissing;\n      }\n      destroy(err) {\n        if (err)\n          this.error = err;\n        this.destroyed = true;\n      }\n      recv(data) {\n        if (this.receiving === true)\n          throw new Error(\"Cannot recursively receive data\");\n        this.receiving = true;\n        let offset = 0;\n        while (offset < data.length) {\n          if (this._state === 2)\n            offset = this._readMessage(data, offset);\n          else\n            offset = this._readVarint(data, offset);\n        }\n        if (this._state === 2 && this._length === 0) {\n          this._readMessage(data, offset);\n        }\n        this.receiving = false;\n        return !this.destroyed;\n      }\n      _readMessage(data, offset) {\n        const free = data.length - offset;\n        if (free >= this._length) {\n          if (this._message) {\n            data.copy(this._message, this._message.length - this._length, offset);\n          } else {\n            this._message = data.slice(offset, offset + this._length);\n          }\n          return this._nextState(data, offset += this._length) ? offset : data.length;\n        }\n        if (!this._message)\n          this._message = Buffer2.allocUnsafe(this._length);\n        data.copy(this._message, this._message.length - this._length, offset);\n        this._length -= free;\n        return data.length;\n      }\n      _readVarint(data, offset) {\n        for (; offset < data.length; offset++) {\n          this._varint += (data[offset] & 127) * this._factor;\n          this._consumed++;\n          if (data[offset] < 128)\n            return this._nextState(data, ++offset) ? offset : data.length;\n          this._factor *= 128;\n        }\n        if (this._consumed >= 8)\n          this.destroy(new Error(\"Incoming varint is invalid\"));\n        return data.length;\n      }\n      _nextState(data, offset) {\n        switch (this._state) {\n          case 0:\n            this._state = 1;\n            this._factor = 1;\n            this._length = this._varint;\n            this._consumed = this._varint = 0;\n            if (this._length === 0)\n              this._state = 0;\n            return true;\n          case 1:\n            this._state = 2;\n            this._factor = 1;\n            this._header = this._varint;\n            this._length -= this._consumed;\n            this._consumed = this._varint = 0;\n            if (this._length < 0 || this._length > this._maxSize) {\n              this.destroy(new Error(\"Incoming message is larger than max size\"));\n              return false;\n            }\n            if (this.onmissing) {\n              const extra = data.length - offset;\n              if (this._length > extra)\n                this.onmissing(this._length - extra, this.context);\n            }\n            return true;\n          case 2:\n            this._state = 0;\n            this._onmessage(this._header >> 4, this._header & 15, this._message, data, offset);\n            this._message = null;\n            return !this.destroyed;\n          default:\n            return false;\n        }\n      }\n      _onmessage(channel, type, message, data, offset) {\n        if (type >= this._types.length) {\n          if (this.onmessage === null)\n            return;\n          return this.onmessage(channel, type, message, this.context, data, offset);\n        }\n        let m = null;\n        const { onmessage, encoding, context } = this._types[type];\n        try {\n          m = encoding.decode(message);\n        } catch (err) {\n          this.destroy(err);\n          return;\n        }\n        onmessage(channel, m, context, data, offset);\n      }\n      send(channel, type, message) {\n        const header = channel << 4 | type;\n        const length = this._encodingLength(type, message) + varint.encodingLength(header);\n        const payload = Buffer2.allocUnsafe(varint.encodingLength(length) + length);\n        varint.encode(length, payload, 0);\n        const offset = varint.encode.bytes;\n        varint.encode(header, payload, offset);\n        this._encode(type, message, payload, offset + varint.encode.bytes);\n        return payload;\n      }\n      sendBatch(messages) {\n        let length = 0;\n        let offset = 0;\n        for (const { type, message } of messages) {\n          length += 16 + this._encodingLength(type, message);\n        }\n        const payload = Buffer2.allocUnsafe(length);\n        for (const { channel, type, message } of messages) {\n          const header = channel << 4 | type;\n          const length2 = this._encodingLength(type, message) + varint.encodingLength(header);\n          varint.encode(length2, payload, offset);\n          offset += varint.encode.bytes;\n          varint.encode(header, payload, offset);\n          offset += varint.encode.bytes;\n          offset += this._encode(type, message, payload, offset);\n        }\n        return payload.slice(0, offset);\n      }\n      _encodingLength(type, message) {\n        if (type >= this._types.length)\n          return message.length;\n        return this._types[type].encoding.encodingLength(message);\n      }\n      _encode(type, message, buf, offset) {\n        if (type >= this._types.length) {\n          message.copy(buf, offset);\n          return message.length;\n        }\n        const enc = this._types[type].encoding;\n        enc.encode(message, buf, offset);\n        return enc.encode.bytes;\n      }\n    };\n  }\n});\n\n// node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/index.js\nvar require_simple_hypercore_protocol = __commonJS({\n  \"node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/index.js\"(exports, module) {\n    init_inject_globals();\n    var Handshake = require_handshake();\n    var messages = require_messages();\n    var XOR = require_xor();\n    var SMC = require_simple_message_channels();\n    var crypto = require_hypercore_crypto();\n    var varint = require_varint2();\n    module.exports = class SimpleProtocol {\n      constructor(initiator, handlers) {\n        const payload = { nonce: XOR.nonce() };\n        this.handlers = handlers || {};\n        this.remotePayload = null;\n        this.remotePublicKey = null;\n        this.publicKey = null;\n        this.handshakeHash = null;\n        this.destroyed = false;\n        this._initiator = initiator;\n        this._payload = payload;\n        this._pending = [];\n        this._handshake = null;\n        this._split = null;\n        this._encryption = null;\n        this._noise = !(handlers.encrypted === false && handlers.noise === false);\n        this._buffering = null;\n        this._handshaking = false;\n        this._messages = new SMC({\n          onmessage,\n          onmissing,\n          context: this,\n          types: [\n            { context: this, onmessage: onopen, encoding: messages.Open },\n            { context: this, onmessage: onoptions, encoding: messages.Options },\n            { context: this, onmessage: onstatus, encoding: messages.Status },\n            { context: this, onmessage: onhave, encoding: messages.Have },\n            { context: this, onmessage: onunhave, encoding: messages.Unhave },\n            { context: this, onmessage: onwant, encoding: messages.Want },\n            { context: this, onmessage: onunwant, encoding: messages.Unwant },\n            { context: this, onmessage: onrequest, encoding: messages.Request },\n            { context: this, onmessage: oncancel, encoding: messages.Cancel },\n            { context: this, onmessage: ondata, encoding: messages.Data },\n            { context: this, onmessage: onclose, encoding: messages.Close }\n          ]\n        });\n        if (handlers.encrypted !== false || handlers.noise !== false) {\n          this._handshaking = true;\n          if (typeof this.handlers.keyPair !== \"function\") {\n            this._onkeypair(null, this.handlers.keyPair || null);\n          } else {\n            this._buffering = [];\n            this.handlers.keyPair(this._onkeypair.bind(this));\n          }\n        }\n      }\n      _onkeypair(err, keyPair) {\n        if (err)\n          return this.destroy(err);\n        if (this._handshake !== null)\n          return;\n        this.handlers.keyPair = keyPair;\n        const handshake = new Handshake(this._initiator, messages.NoisePayload.encode(this._payload), this.handlers, this._onhandshake.bind(this));\n        this.publicKey = handshake.keyPair.publicKey;\n        this._handshake = handshake;\n        if (this._buffering) {\n          while (this._buffering.length)\n            this._recv(this._buffering.shift());\n        }\n        this._buffering = null;\n      }\n      open(ch, message) {\n        return this._send(ch, 0, message);\n      }\n      options(ch, message) {\n        return this._send(ch, 1, message);\n      }\n      status(ch, message) {\n        return this._send(ch, 2, message);\n      }\n      have(ch, message) {\n        return this._send(ch, 3, message);\n      }\n      unhave(ch, message) {\n        return this._send(ch, 4, message);\n      }\n      want(ch, message) {\n        return this._send(ch, 5, message);\n      }\n      unwant(ch, message) {\n        return this._send(ch, 6, message);\n      }\n      request(ch, message) {\n        return this._send(ch, 7, message);\n      }\n      cancel(ch, message) {\n        return this._send(ch, 8, message);\n      }\n      data(ch, message) {\n        return this._send(ch, 9, message);\n      }\n      close(ch, message) {\n        return this._send(ch, 10, message || {});\n      }\n      extension(ch, id, message) {\n        const buf = Buffer2.allocUnsafe(varint.encodingLength(id) + message.length);\n        varint.encode(id, buf, 0);\n        message.copy(buf, varint.encode.bytes);\n        return this._send(ch, 15, buf);\n      }\n      ping() {\n        if (this._handshaking || this._pending.length)\n          return;\n        let ping = Buffer2.from([0]);\n        if (this._encryption !== null) {\n          ping = this._encryption.encrypt(ping);\n        }\n        return this.handlers.send(ping);\n      }\n      _onhandshake(err, remotePayload, split, overflow, remotePublicKey, handshakeHash) {\n        if (err)\n          return this.destroy(new Error(\"Noise handshake error\"));\n        if (!remotePayload)\n          return this.destroy(new Error(\"Remote did not include a handshake payload\"));\n        this.remotePublicKey = remotePublicKey;\n        this.handshakeHash = handshakeHash;\n        try {\n          remotePayload = messages.NoisePayload.decode(remotePayload);\n        } catch (_) {\n          return this.destroy(new Error(\"Could not parse remote payload\"));\n        }\n        this._handshake = null;\n        this._handshaking = false;\n        this._split = split;\n        this._encryption = this.handlers.encrypted === false ? null : new XOR({ rnonce: remotePayload.nonce, tnonce: this._payload.nonce }, split);\n        this.remotePayload = remotePayload;\n        if (this.handlers.onhandshake)\n          this.handlers.onhandshake();\n        if (this.destroyed)\n          return;\n        if (overflow)\n          this.recv(overflow);\n        while (this._pending.length && !this.destroyed) {\n          this._sendNow(...this._pending.shift());\n        }\n      }\n      _send(channel, type, message) {\n        if (this._handshaking || this._pending.length) {\n          this._pending.push([channel, type, message]);\n          return false;\n        }\n        return this._sendNow(channel, type, message);\n      }\n      _sendNow(channel, type, message) {\n        if (type === 0 && message.key && !message.capability) {\n          message.capability = this.capability(message.key);\n          message.key = null;\n        }\n        let data = this._messages.send(channel, type, message);\n        if (this._encryption !== null) {\n          data = this._encryption.encrypt(data);\n        }\n        return this.handlers.send(data);\n      }\n      capability(key) {\n        return crypto.capability(key, this._split);\n      }\n      remoteCapability(key) {\n        return crypto.remoteCapability(key, this._split);\n      }\n      recv(data) {\n        if (this._buffering !== null)\n          this._buffering.push(data);\n        else\n          this._recv(data);\n      }\n      _recv(data) {\n        if (this.destroyed)\n          return;\n        if (this._handshaking) {\n          this._handshake.recv(data);\n          return;\n        }\n        if (this._encryption !== null) {\n          data = this._encryption.decrypt(data);\n        }\n        if (!this._messages.recv(data)) {\n          this.destroy(this._messages.error);\n        }\n      }\n      destroy(err) {\n        if (this.destroyed)\n          return;\n        this.destroyed = true;\n        if (this._handshake)\n          this._handshake.destroy();\n        if (this._encryption)\n          this._encryption.destroy();\n        if (this.handlers.destroy)\n          this.handlers.destroy(err);\n      }\n      static keyPair(seed) {\n        return Handshake.keyPair(seed);\n      }\n    };\n    function onopen(ch, message, self) {\n      if (self.handlers.onopen)\n        self.handlers.onopen(ch, message);\n    }\n    function onoptions(ch, message, self) {\n      if (self.handlers.onoptions)\n        self.handlers.onoptions(ch, message);\n    }\n    function onstatus(ch, message, self) {\n      if (self.handlers.onstatus)\n        self.handlers.onstatus(ch, message);\n    }\n    function onhave(ch, message, self) {\n      if (self.handlers.onhave)\n        self.handlers.onhave(ch, message);\n    }\n    function onunhave(ch, message, self) {\n      if (self.handlers.onunhave)\n        self.handlers.onunhave(ch, message);\n    }\n    function onwant(ch, message, self) {\n      if (self.handlers.onwant)\n        self.handlers.onwant(ch, message);\n    }\n    function onunwant(ch, message, self) {\n      if (self.handlers.onunwant)\n        self.handlers.onunwant(ch, message);\n    }\n    function onrequest(ch, message, self) {\n      if (self.handlers.onrequest)\n        self.handlers.onrequest(ch, message);\n    }\n    function oncancel(ch, message, self) {\n      if (self.handlers.oncancel)\n        self.handlers.oncancel(ch, message);\n    }\n    function ondata(ch, message, self) {\n      if (self.handlers.ondata)\n        self.handlers.ondata(ch, message);\n    }\n    function onclose(ch, message, self) {\n      if (self.handlers.onclose)\n        self.handlers.onclose(ch, message);\n    }\n    function onmessage(ch, type, message, self) {\n      if (type !== 15)\n        return;\n      const id = varint.decode(message);\n      const m = message.slice(varint.decode.bytes);\n      if (self.handlers.onextension)\n        self.handlers.onextension(ch, id, m);\n    }\n    function onmissing(bytes, self) {\n      if (self.handlers.onmissing)\n        self.handlers.onmissing(bytes);\n    }\n  }\n});\n\n// node_modules/.pnpm/timeout-refresh@1.0.3/node_modules/timeout-refresh/browser.js\nvar require_browser4 = __commonJS({\n  \"node_modules/.pnpm/timeout-refresh@1.0.3/node_modules/timeout-refresh/browser.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = Timeout;\n    function Timeout(ms, fn, ctx) {\n      if (!(this instanceof Timeout))\n        return new Timeout(ms, fn, ctx);\n      this.ms = ms;\n      this.ontimeout = fn;\n      this.context = ctx || null;\n      this.called = false;\n      this._timeout = setTimeout(call, ms, this);\n    }\n    Timeout.prototype.refresh = function() {\n      if (this.called || this.ontimeout === null)\n        return;\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(call, this.ms, this);\n    };\n    Timeout.prototype.destroy = function() {\n      this.ontimeout = null;\n      clearTimeout(this._timeout);\n    };\n    function call(self) {\n      self.called = true;\n      self.ontimeout.call(self.context);\n    }\n  }\n});\n\n// node_modules/.pnpm/abstract-extension@3.1.1/node_modules/abstract-extension/index.js\nvar require_abstract_extension = __commonJS({\n  \"node_modules/.pnpm/abstract-extension@3.1.1/node_modules/abstract-extension/index.js\"(exports, module) {\n    init_inject_globals();\n    var codecs = require_codecs();\n    var AbstractExtension = class {\n      constructor(local, name, handlers = {}) {\n        this.id = 0;\n        this.name = name;\n        this.encoding = codecs(handlers.encoding || \"binary\");\n        this.handlers = handlers;\n        this.local = local;\n      }\n      encode(message) {\n        return this.encoding.encode(message);\n      }\n      remoteSupports() {\n        return !!(this.local && this.local.map && this.local.map[this.id] === this);\n      }\n      onmessage(buf, context) {\n        if (!this.handlers.onmessage)\n          return;\n        let message;\n        try {\n          message = this.encoding.decode(buf);\n        } catch (err) {\n          if (this.handlers.onerror)\n            this.handlers.onerror(err, context);\n          return;\n        }\n        this.handlers.onmessage(message, context);\n      }\n      get destroyed() {\n        return this.local === null;\n      }\n      destroy() {\n        if (this.local === null)\n          return;\n        this.local._remove(this);\n        this.local = null;\n      }\n      static createLocal(handlers = null) {\n        return new Local(handlers, this);\n      }\n    };\n    var Remote = class {\n      constructor(local) {\n        this.local = local;\n        this.names = null;\n        this.map = null;\n        this.changes = 0;\n      }\n      update(names) {\n        this.names = names;\n        this.changes = 0;\n      }\n      onmessage(id, message, context = null) {\n        if (this.changes !== this.local.changes) {\n          this.map = this.names ? match(this.local.messages, this.names) : null;\n          this.changes = this.local.changes;\n        }\n        const m = this.map && this.map[id];\n        if (m)\n          m.onmessage(message, context);\n      }\n    };\n    var Local = class {\n      constructor(handlers = null, M) {\n        this.messages = [];\n        this.handlers = handlers;\n        this.Extension = M;\n        this.changes = 1;\n        this.exclusive = true;\n      }\n      get length() {\n        return this.messages.length;\n      }\n      [Symbol.iterator]() {\n        return this.messages[Symbol.iterator]();\n      }\n      get(name) {\n        for (const m of this.messages) {\n          if (m.name === name)\n            return m;\n        }\n        return null;\n      }\n      add(name, handlers) {\n        let m;\n        if (typeof handlers !== \"function\") {\n          m = new this.Extension(this, name, handlers);\n        } else {\n          m = new this.Extension(this, name, {});\n          m.handlers = handlers(m) || {};\n          m.encoding = codecs(m.handlers.encoding || \"binary\");\n        }\n        this.changes++;\n        this.messages.push(m);\n        this.messages.sort(sortMessages);\n        for (let i = 0; i < this.messages.length; i++) {\n          this.messages[i].id = i;\n        }\n        if (this.exclusive) {\n          if (m.id > 0 && this.messages[m.id - 1].name === m.name || m.id < this.messages.length - 1 && this.messages[m.id + 1].name === m.name) {\n            this._remove(m);\n            throw new Error(\"Cannot add multiple messages with the same name\");\n          }\n        }\n        if (this.handlers && this.handlers.onextensionupdate)\n          this.handlers.onextensionupdate();\n        return m;\n      }\n      remote() {\n        return new Remote(this);\n      }\n      _remove(m) {\n        this.changes++;\n        this.messages.splice(m.id, 1);\n        m.id = -1;\n        if (this.handlers && this.handlers.onextensionupdate)\n          this.handlers.onextensionupdate();\n      }\n      names() {\n        const names = new Array(this.messages.length);\n        for (let i = 0; i < names.length; i++) {\n          names[i] = this.messages[i].name;\n        }\n        return names;\n      }\n    };\n    function sortMessages(a, b) {\n      return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n    }\n    function match(local, remote) {\n      let i = 0;\n      let j = 0;\n      const map = new Array(remote.length);\n      while (i < local.length && j < remote.length) {\n        const l = local[i].name;\n        const r = remote[j];\n        if (l < r)\n          i++;\n        else if (l > r)\n          j++;\n        else\n          map[j++] = local[i];\n      }\n      return map;\n    }\n    module.exports = AbstractExtension;\n  }\n});\n\n// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js\nvar require_ms = __commonJS({\n  \"node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js\"(exports, module) {\n    init_inject_globals();\n    var s = 1e3;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    module.exports = function(val2, options) {\n      options = options || {};\n      var type = typeof val2;\n      if (type === \"string\" && val2.length > 0) {\n        return parse(val2);\n      } else if (type === \"number\" && isFinite(val2)) {\n        return options.long ? fmtLong(val2) : fmtShort(val2);\n      }\n      throw new Error(\n        \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val2)\n      );\n    };\n    function parse(str) {\n      str = String(str);\n      if (str.length > 100) {\n        return;\n      }\n      var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        str\n      );\n      if (!match) {\n        return;\n      }\n      var n = parseFloat(match[1]);\n      var type = (match[2] || \"ms\").toLowerCase();\n      switch (type) {\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n          return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n          return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n          return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n          return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n          return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n          return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n          return n;\n        default:\n          return void 0;\n      }\n    }\n    function fmtShort(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n      }\n      if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n      }\n      if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n      }\n      if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n      }\n      return ms + \"ms\";\n    }\n    function fmtLong(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n      }\n      if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n      }\n      if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n      }\n      if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n      }\n      return ms + \" ms\";\n    }\n    function plural(ms, msAbs, n, name) {\n      var isPlural = msAbs >= n * 1.5;\n      return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n  }\n});\n\n// node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/common.js\nvar require_common = __commonJS({\n  \"node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/common.js\"(exports, module) {\n    init_inject_globals();\n    function setup(env) {\n      createDebug.debug = createDebug;\n      createDebug.default = createDebug;\n      createDebug.coerce = coerce;\n      createDebug.disable = disable;\n      createDebug.enable = enable;\n      createDebug.enabled = enabled;\n      createDebug.humanize = require_ms();\n      createDebug.destroy = destroy;\n      Object.keys(env).forEach((key) => {\n        createDebug[key] = env[key];\n      });\n      createDebug.names = [];\n      createDebug.skips = [];\n      createDebug.formatters = {};\n      function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\n          hash |= 0;\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n      }\n      createDebug.selectColor = selectColor;\n      function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n          if (!debug.enabled) {\n            return;\n          }\n          const self = debug;\n          const curr = Number(/* @__PURE__ */ new Date());\n          const ms = curr - (prevTime || curr);\n          self.diff = ms;\n          self.prev = prevTime;\n          self.curr = curr;\n          prevTime = curr;\n          args[0] = createDebug.coerce(args[0]);\n          if (typeof args[0] !== \"string\") {\n            args.unshift(\"%O\");\n          }\n          let index = 0;\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n            if (match === \"%%\") {\n              return \"%\";\n            }\n            index++;\n            const formatter = createDebug.formatters[format];\n            if (typeof formatter === \"function\") {\n              const val2 = args[index];\n              match = formatter.call(self, val2);\n              args.splice(index, 1);\n              index--;\n            }\n            return match;\n          });\n          createDebug.formatArgs.call(self, args);\n          const logFn = self.log || createDebug.log;\n          logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy;\n        Object.defineProperty(debug, \"enabled\", {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n            if (enableOverride !== null) {\n              return enableOverride;\n            }\n            if (namespacesCache !== createDebug.namespaces) {\n              namespacesCache = createDebug.namespaces;\n              enabledCache = createDebug.enabled(namespace);\n            }\n            return enabledCache;\n          },\n          set: (v) => {\n            enableOverride = v;\n          }\n        });\n        if (typeof createDebug.init === \"function\") {\n          createDebug.init(debug);\n        }\n        return debug;\n      }\n      function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n      }\n      function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for (i = 0; i < len; i++) {\n          if (!split[i]) {\n            continue;\n          }\n          namespaces = split[i].replace(/\\*/g, \".*?\");\n          if (namespaces[0] === \"-\") {\n            createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n          } else {\n            createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n          }\n        }\n      }\n      function disable() {\n        const namespaces = [\n          ...createDebug.names.map(toNamespace),\n          ...createDebug.skips.map(toNamespace).map((namespace) => \"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n      }\n      function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n          return true;\n        }\n        let i;\n        let len;\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\n          if (createDebug.skips[i].test(name)) {\n            return false;\n          }\n        }\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\n          if (createDebug.names[i].test(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n      }\n      function coerce(val2) {\n        if (val2 instanceof Error) {\n          return val2.stack || val2.message;\n        }\n        return val2;\n      }\n      function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n      }\n      createDebug.enable(createDebug.load());\n      return createDebug;\n    }\n    module.exports = setup;\n  }\n});\n\n// node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/browser.js\nvar require_browser5 = __commonJS({\n  \"node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/browser.js\"(exports, module) {\n    init_inject_globals();\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.storage = localstorage();\n    exports.destroy = /* @__PURE__ */ (() => {\n      let warned = false;\n      return () => {\n        if (!warned) {\n          warned = true;\n          console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n      };\n    })();\n    exports.colors = [\n      \"#0000CC\",\n      \"#0000FF\",\n      \"#0033CC\",\n      \"#0033FF\",\n      \"#0066CC\",\n      \"#0066FF\",\n      \"#0099CC\",\n      \"#0099FF\",\n      \"#00CC00\",\n      \"#00CC33\",\n      \"#00CC66\",\n      \"#00CC99\",\n      \"#00CCCC\",\n      \"#00CCFF\",\n      \"#3300CC\",\n      \"#3300FF\",\n      \"#3333CC\",\n      \"#3333FF\",\n      \"#3366CC\",\n      \"#3366FF\",\n      \"#3399CC\",\n      \"#3399FF\",\n      \"#33CC00\",\n      \"#33CC33\",\n      \"#33CC66\",\n      \"#33CC99\",\n      \"#33CCCC\",\n      \"#33CCFF\",\n      \"#6600CC\",\n      \"#6600FF\",\n      \"#6633CC\",\n      \"#6633FF\",\n      \"#66CC00\",\n      \"#66CC33\",\n      \"#9900CC\",\n      \"#9900FF\",\n      \"#9933CC\",\n      \"#9933FF\",\n      \"#99CC00\",\n      \"#99CC33\",\n      \"#CC0000\",\n      \"#CC0033\",\n      \"#CC0066\",\n      \"#CC0099\",\n      \"#CC00CC\",\n      \"#CC00FF\",\n      \"#CC3300\",\n      \"#CC3333\",\n      \"#CC3366\",\n      \"#CC3399\",\n      \"#CC33CC\",\n      \"#CC33FF\",\n      \"#CC6600\",\n      \"#CC6633\",\n      \"#CC9900\",\n      \"#CC9933\",\n      \"#CCCC00\",\n      \"#CCCC33\",\n      \"#FF0000\",\n      \"#FF0033\",\n      \"#FF0066\",\n      \"#FF0099\",\n      \"#FF00CC\",\n      \"#FF00FF\",\n      \"#FF3300\",\n      \"#FF3333\",\n      \"#FF3366\",\n      \"#FF3399\",\n      \"#FF33CC\",\n      \"#FF33FF\",\n      \"#FF6600\",\n      \"#FF6633\",\n      \"#FF9900\",\n      \"#FF9933\",\n      \"#FFCC00\",\n      \"#FFCC33\"\n    ];\n    function useColors() {\n      if (typeof window !== \"undefined\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs)) {\n        return true;\n      }\n      if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n      }\n      return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n      typeof window !== \"undefined\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n      typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n      typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n    function formatArgs(args) {\n      args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n      if (!this.useColors) {\n        return;\n      }\n      const c = \"color: \" + this.color;\n      args.splice(1, 0, c, \"color: inherit\");\n      let index = 0;\n      let lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        if (match === \"%%\") {\n          return;\n        }\n        index++;\n        if (match === \"%c\") {\n          lastC = index;\n        }\n      });\n      args.splice(lastC, 0, c);\n    }\n    exports.log = console.debug || console.log || (() => {\n    });\n    function save(namespaces) {\n      try {\n        if (namespaces) {\n          exports.storage.setItem(\"debug\", namespaces);\n        } else {\n          exports.storage.removeItem(\"debug\");\n        }\n      } catch (error) {\n      }\n    }\n    function load() {\n      let r;\n      try {\n        r = exports.storage.getItem(\"debug\");\n      } catch (error) {\n      }\n      if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n      }\n      return r;\n    }\n    function localstorage() {\n      try {\n        return localStorage;\n      } catch (error) {\n      }\n    }\n    module.exports = require_common()(exports);\n    var { formatters } = module.exports;\n    formatters.j = function(v) {\n      try {\n        return JSON.stringify(v);\n      } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n      }\n    };\n  }\n});\n\n// node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js\nvar require_hypercore_protocol = __commonJS({\n  \"node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js\"(exports, module) {\n    init_inject_globals();\n    var SHP = require_simple_hypercore_protocol();\n    var crypto = require_hypercore_crypto();\n    var timeout = require_browser4();\n    var inspect = require_browser();\n    var Nanoguard = require_nanoguard();\n    var pretty = require_pretty_hash();\n    var Message = require_abstract_extension();\n    var { Duplex } = import$streamx;\n    var debug = require_browser5()(\"hypercore-protocol\");\n    var StreamExtension = class extends Message {\n      send(message) {\n        const stream = this.local.handlers;\n        if (stream._changes !== this.local.changes) {\n          stream._changes = this.local.changes;\n          stream.state.options(0, { extensions: this.local.names() });\n        }\n        return stream.state.extension(0, this.id, this.encode(message));\n      }\n    };\n    var Channelizer = class {\n      constructor(stream, { encrypted, noise, keyPair }) {\n        this.stream = stream;\n        this.created = /* @__PURE__ */ new Map();\n        this.local = [null];\n        this.remote = [null];\n        this.noise = !(noise === false && encrypted === false);\n        this.encrypted = encrypted !== false;\n        this.keyPair = keyPair;\n      }\n      allocLocal() {\n        const id = this.local.indexOf(null);\n        if (id > 0)\n          return id;\n        this.local.push(null);\n        return this.local.length - 1;\n      }\n      attachLocal(ch) {\n        const id = this.allocLocal();\n        this.local[id] = ch;\n        ch.localId = id;\n      }\n      attachRemote(ch, id) {\n        if (this.remote.length === id)\n          this.remote.push(null);\n        this.remote[id] = ch;\n        ch.remoteId = id;\n      }\n      detachChannel(ch) {\n        if (ch.localId > -1 && this.local[ch.localId] === ch) {\n          this.local[ch.localId] = null;\n          ch.localId = -1;\n          if (ch.handlers && ch.handlers.onclose)\n            ch.handlers.onclose();\n        }\n        if (ch.remoteId > -1 && this.remote[ch.remoteId] === ch) {\n          this.remote[ch.remoteId] = null;\n        }\n        const hex = ch.discoveryKey.toString(\"hex\");\n        if (this.created.get(hex) === ch)\n          this.created.delete(hex);\n      }\n      getChannel(dk) {\n        return this.created.get(dk.toString(\"hex\"));\n      }\n      createChannel(dk) {\n        const hex = dk.toString(\"hex\");\n        const old = this.created.get(hex);\n        if (old)\n          return old;\n        const fresh = new Channel(this.stream.state, this.stream, dk);\n        this.created.set(hex, fresh);\n        return fresh;\n      }\n      onauthenticate(key, done) {\n        if (this.stream.handlers && this.stream.handlers.onauthenticate)\n          this.stream.handlers.onauthenticate(key, done);\n        else\n          done(null);\n      }\n      onhandshake() {\n        debug(\"recv handshake\");\n        if (this.stream.handlers && this.stream.handlers.onhandshake)\n          this.stream.handlers.onhandshake();\n        this.stream.emit(\"handshake\");\n      }\n      onopen(channelId, message) {\n        debug(\"recv open\", channelId, message);\n        const ch = this.createChannel(message.discoveryKey);\n        ch.remoteCapability = message.capability;\n        this.attachRemote(ch, channelId);\n        if (ch.localId === -1) {\n          if (this.stream.handlers.ondiscoverykey)\n            this.stream.handlers.ondiscoverykey(ch.discoveryKey);\n          this.stream.emit(\"discovery-key\", ch.discoveryKey);\n        } else {\n          if (this.noise && !ch.remoteVerified) {\n            this.stream.destroy(new Error(\"Invalid remote channel capability\"));\n            return;\n          }\n          this.stream.emit(\"duplex-channel\", ch);\n        }\n        if (ch.handlers && ch.handlers.onopen)\n          ch.handlers.onopen();\n        if (this.stream.handlers.onremoteopen)\n          this.stream.handlers.onremoteopen(ch.discoveryKey);\n        this.stream.emit(\"remote-open\", ch.discoveryKey);\n      }\n      onoptions(channelId, message) {\n        debug(\"recv options\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.onoptions)\n          ch.handlers.onoptions(message);\n        else if (channelId === 0 && !ch)\n          this.stream._updateExtensions(message.extensions);\n      }\n      onstatus(channelId, message) {\n        debug(\"recv status\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.onstatus)\n          ch.handlers.onstatus(message);\n      }\n      onhave(channelId, message) {\n        debug(\"recv have\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.onhave)\n          ch.handlers.onhave(message);\n      }\n      onunhave(channelId, message) {\n        debug(\"recv unhave\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.onunhave)\n          ch.handlers.onunhave(message);\n      }\n      onwant(channelId, message) {\n        debug(\"recv want\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.onwant)\n          ch.handlers.onwant(message);\n      }\n      onunwant(channelId, message) {\n        debug(\"recv unwant\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.onunwant)\n          ch.handlers.onunwant(message);\n      }\n      onrequest(channelId, message) {\n        debug(\"recv request\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.onrequest)\n          ch.handlers.onrequest(message);\n      }\n      oncancel(channelId, message) {\n        debug(\"recv cancel\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.oncancel)\n          ch.handlers.oncancel(message);\n      }\n      ondata(channelId, message) {\n        debug(\"recv data\", channelId, message);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.ondata)\n          ch.handlers.ondata(message);\n      }\n      onextension(channelId, id, buf) {\n        debug(\"recv extension\", channelId, id);\n        const ch = this.remote[channelId];\n        if (ch && ch.handlers && ch.handlers.onextension)\n          ch.handlers.onextension(id, buf);\n        else if (channelId === 0 && !ch)\n          this.stream.remoteExtensions.onmessage(id, buf);\n      }\n      onclose(channelId, message) {\n        debug(\"recv close\", channelId, message);\n        let ch = channelId < this.remote.length ? this.remote[channelId] : null;\n        if (ch) {\n          this.remote[channelId] = null;\n        } else if (message.discoveryKey) {\n          ch = this.getChannel(message.discoveryKey);\n        }\n        if (!ch)\n          return;\n        if (ch.localId > -1 && this.local[ch.localId] === ch) {\n          this.local[ch.localId] = null;\n          ch.state.close(ch.localId, {});\n          ch.localId = -1;\n          if (ch.handlers && ch.handlers.onclose)\n            ch.handlers.onclose();\n        }\n        if (this.stream.handlers && this.stream.handlers.onchannelclose) {\n          this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key);\n        }\n        const hex = ch.discoveryKey.toString(\"hex\");\n        if (this.created.get(hex) === ch)\n          this.created.delete(hex);\n        this.stream._prefinalize();\n      }\n      onmissing(bytes) {\n        if (this.stream._utp === null)\n          return;\n        this.stream._utp.setContentSize(bytes);\n      }\n      // called by the state machine\n      send(data) {\n        if (this.stream.keepAlive !== null)\n          this.stream.keepAlive.refresh();\n        this.stream.bytesSent += data.length;\n        return this.stream.push(data);\n      }\n      // called by the state machine\n      destroy(err) {\n        this.stream.destroy(err);\n        this.local = [];\n        this.remote = [];\n        for (const ch of this.created.values()) {\n          const closed = ch.localId === -1;\n          ch.localId = ch.remoteId = -1;\n          if (!closed && ch.handlers && ch.handlers.onclose)\n            ch.handlers.onclose();\n          if (this.stream.handlers && this.stream.handlers.onchannelclose) {\n            this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key);\n          }\n        }\n        this.created.clear();\n      }\n    };\n    var Channel = class {\n      constructor(state, stream, dk) {\n        this.key = null;\n        this.discoveryKey = dk;\n        this.localId = -1;\n        this.remoteId = -1;\n        this.remoteCapability = null;\n        this.handlers = null;\n        this.state = state;\n        this.stream = stream;\n      }\n      get opened() {\n        return this.localId > -1;\n      }\n      get closed() {\n        return this.localId === -1;\n      }\n      get remoteOpened() {\n        return this.remoteId > -1;\n      }\n      get remoteVerified() {\n        return this.localId > -1 && this.remoteId > -1 && !!this.remoteCapability && this.remoteCapability.equals(this.state.remoteCapability(this.key));\n      }\n      options(message) {\n        debug(\"send options\", message);\n        return this.state.options(this.localId, message);\n      }\n      status(message) {\n        debug(\"send status\", message);\n        return this.state.status(this.localId, message);\n      }\n      have(message) {\n        debug(\"send have\", message);\n        return this.state.have(this.localId, message);\n      }\n      unhave(message) {\n        debug(\"send unhave\", message);\n        return this.state.unhave(this.localId, message);\n      }\n      want(message) {\n        debug(\"send want\", message);\n        return this.state.want(this.localId, message);\n      }\n      unwant(message) {\n        debug(\"send unwant\", message);\n        return this.state.unwant(this.localId, message);\n      }\n      request(message) {\n        debug(\"send request\", message);\n        return this.state.request(this.localId, message);\n      }\n      cancel(message) {\n        debug(\"send cancel\", message);\n        return this.state.cancel(this.localId, message);\n      }\n      data(message) {\n        debug(\"send data\", message);\n        return this.state.data(this.localId, message);\n      }\n      extension(id, buf) {\n        debug(\"send extension\", id);\n        return this.state.extension(this.localId, id, buf);\n      }\n      close() {\n        debug(\"send close\");\n        if (this.closed)\n          return;\n        const localId = this.localId;\n        this.stream.channelizer.detachChannel(this);\n        this.state.close(localId, {});\n        this.stream._prefinalize();\n      }\n      destroy(err) {\n        this.stream.destroy(err);\n      }\n    };\n    module.exports = class ProtocolStream extends Duplex {\n      constructor(initiator, handlers = {}) {\n        super();\n        if (typeof initiator !== \"boolean\")\n          throw new Error(\"Must specify initiator boolean in replication stream\");\n        this.initiator = initiator;\n        this.handlers = handlers;\n        this.channelizer = new Channelizer(this, {\n          encrypted: handlers.encrypted,\n          noise: handlers.noise,\n          keyPair: handlers.keyPair\n        });\n        this.state = new SHP(initiator, this.channelizer);\n        this.live = !!handlers.live;\n        this.timeout = null;\n        this.keepAlive = null;\n        this.prefinalize = new Nanoguard();\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.extensions = StreamExtension.createLocal(this);\n        this.remoteExtensions = this.extensions.remote();\n        this._utp = null;\n        this._changes = 0;\n        this.once(\"finish\", this.push.bind(this, null));\n        this.on(\"pipe\", this._onpipe);\n        if (handlers.timeout !== false && handlers.timeout !== 0) {\n          const timeout2 = handlers.timeout || 2e4;\n          this.setTimeout(timeout2, () => this.destroy(new Error(\"ETIMEDOUT\")));\n          this.setKeepAlive(Math.ceil(timeout2 / 2));\n        }\n      }\n      registerExtension(name, handlers) {\n        return this.extensions.add(name, handlers);\n      }\n      [inspect](depth, opts) {\n        let indent = \"\";\n        if (typeof opts.indentationLvl === \"number\") {\n          while (indent.length < opts.indentationLvl)\n            indent += \" \";\n        }\n        return \"HypercoreProtocolStream(\\n\" + indent + \"  publicKey: \" + opts.stylize(this.publicKey && pretty(this.publicKey), \"string\") + \"\\n\" + indent + \"  remotePublicKey: \" + opts.stylize(this.remotePublicKey && pretty(this.remotePublicKey), \"string\") + \"\\n\" + indent + \"  remoteAddress: \" + opts.stylize(this.remoteAddress, \"string\") + \"\\n\" + indent + \"  remoteType: \" + opts.stylize(this.remoteType, \"string\") + \"\\n\" + indent + \"  live: \" + opts.stylize(this.live, \"boolean\") + \"\\n\" + indent + \"  initiator: \" + opts.stylize(this.initiator, \"boolean\") + \"\\n\" + indent + \"  channelCount: \" + opts.stylize(this.channelCount, \"number\") + \"\\n\" + indent + \"  destroyed: \" + opts.stylize(this.destroyed, \"boolean\") + \"\\n\" + indent + \"  prefinalized: \" + opts.stylize(!this.prefinalize.waiting, \"boolean\") + \"\\n\" + indent + \"  bytesSent: \" + opts.stylize(this.bytesSent, \"number\") + \"\\n\" + indent + \"  bytesReceived: \" + opts.stylize(this.bytesReceived, \"number\") + \"\\n\" + indent + \")\";\n      }\n      static isProtocolStream(s) {\n        return !!(s && typeof s.initiator === \"boolean\" && typeof s.pipe === \"function\" && s.state);\n      }\n      static keyPair(seed) {\n        return SHP.keyPair(seed);\n      }\n      get remoteAddress() {\n        const to = this._readableState.pipeTo;\n        if (!to)\n          return null;\n        if (ProtocolStream.isProtocolStream(to))\n          return null;\n        return to.remoteAddress;\n      }\n      get remoteType() {\n        const to = this._readableState.pipeTo;\n        if (!to)\n          return null;\n        if (to._utp)\n          return \"utp\";\n        if (to.remoteAddress)\n          return \"tcp\";\n        return \"unknown\";\n      }\n      get publicKey() {\n        return this.state.publicKey;\n      }\n      get remotePublicKey() {\n        return this.state.remotePublicKey;\n      }\n      _onpipe(dest) {\n        if (typeof dest.setContentSize === \"function\")\n          this._utp = dest;\n      }\n      _write(data, cb) {\n        if (this.timeout !== null)\n          this.timeout.refresh();\n        this.bytesReceived += data.length;\n        this.state.recv(data);\n        cb(null);\n      }\n      _destroy(cb) {\n        this._predestroy();\n        this.channelizer.destroy();\n        this.state.destroy();\n        cb(null);\n      }\n      _predestroy() {\n        if (this.timeout !== null) {\n          this.timeout.destroy();\n          this.timeout = null;\n        }\n        if (this.keepAlive !== null) {\n          this.keepAlive.destroy();\n          this.keepAlive = null;\n        }\n        this.prefinalize.destroy();\n      }\n      _prefinalize() {\n        this.emit(\"prefinalize\");\n        this.prefinalize.ready(() => {\n          if (this.destroyed)\n            return;\n          if (this.channelCount)\n            return;\n          if (this.live)\n            return;\n          this.finalize();\n        });\n      }\n      _updateExtensions(names) {\n        this.remoteExtensions.update(names);\n        if (this.handlers.onextensions)\n          this.handlers.onextensions(names);\n        this.emit(\"extensions\", names);\n      }\n      remoteOpened(key) {\n        const ch = this.channelizer.getChannel(crypto.discoveryKey(key));\n        return !!(ch && ch.remoteId > -1);\n      }\n      remoteVerified(key) {\n        const ch = this.channelizer.getChannel(crypto.discoveryKey(key));\n        return !!ch && !!ch.remoteCapability && ch.remoteCapability.equals(this.state.remoteCapability(key));\n      }\n      opened(key) {\n        const ch = this.channelizer.getChannel(crypto.discoveryKey(key));\n        return !!(ch && ch.localId > -1);\n      }\n      ping() {\n        return this.state.ping();\n      }\n      setKeepAlive(ms) {\n        if (this.keepAlive)\n          this.keepAlive.destroy();\n        if (!ms) {\n          this.keepAlive = null;\n          return;\n        }\n        this.keepAlive = timeout(ms, ping, this);\n        function ping() {\n          this.ping();\n          this.keepAlive = timeout(ms, ping, this);\n        }\n      }\n      setTimeout(ms, ontimeout) {\n        if (this.timeout)\n          this.timeout.destroy();\n        if (!ms) {\n          this.timeout = null;\n          return;\n        }\n        this.timeout = timeout(ms, this.emit.bind(this, \"timeout\"));\n        if (ontimeout)\n          this.once(\"timeout\", ontimeout);\n      }\n      get channelCount() {\n        return this.channelizer.created.size;\n      }\n      get channels() {\n        return this.channelizer.created.values();\n      }\n      open(key, handlers) {\n        const discoveryKey = crypto.discoveryKey(key);\n        const ch = this.channelizer.createChannel(discoveryKey);\n        if (ch.key === null) {\n          ch.key = key;\n          this.channelizer.attachLocal(ch);\n          this.state.open(ch.localId, { key, discoveryKey });\n        }\n        if (handlers)\n          ch.handlers = handlers;\n        if (ch.remoteId > -1)\n          this.emit(\"duplex-channel\", ch);\n        return ch;\n      }\n      close(discoveryKey) {\n        const ch = this.channelizer.getChannel(discoveryKey);\n        if (ch && ch.localId > -1) {\n          ch.close();\n          return;\n        }\n        this.state.close(this.channelizer.allocLocal(), { discoveryKey });\n      }\n      finalize() {\n        this.push(null);\n      }\n    };\n  }\n});\n\n// node_modules/.pnpm/count-trailing-zeros@1.0.1/node_modules/count-trailing-zeros/ctz.js\nvar require_ctz = __commonJS({\n  \"node_modules/.pnpm/count-trailing-zeros@1.0.1/node_modules/count-trailing-zeros/ctz.js\"(exports, module) {\n    init_inject_globals();\n    module.exports = function(v) {\n      var c = 32;\n      v &= -v;\n      if (v)\n        c--;\n      if (v & 65535)\n        c -= 16;\n      if (v & 16711935)\n        c -= 8;\n      if (v & 252645135)\n        c -= 4;\n      if (v & 858993459)\n        c -= 2;\n      if (v & 1431655765)\n        c -= 1;\n      return c;\n    };\n  }\n});\n\n// node_modules/.pnpm/fast-bitfield@1.2.2/node_modules/fast-bitfield/index.js\nvar require_fast_bitfield = __commonJS({\n  \"node_modules/.pnpm/fast-bitfield@1.2.2/node_modules/fast-bitfield/index.js\"(exports, module) {\n    \"use strict\";\n    init_inject_globals();\n    var ctz = require_ctz();\n    module.exports = () => new Bitfield();\n    var Page = class {\n      constructor(level) {\n        const buf = new Uint8Array(level ? 8456 : 4360);\n        const b = buf.byteOffset;\n        this.buffer = buf;\n        this.bits = level ? null : new Uint32Array(buf.buffer, b, 1024);\n        this.children = level ? new Array(32768) : null;\n        this.level = level;\n        this.allOne = level ? [\n          new Uint32Array(buf.buffer, b, 1024),\n          new Uint32Array(buf.buffer, b + 4096, 32),\n          new Uint32Array(buf.buffer, b + 4224, 1)\n        ] : [\n          this.bits,\n          new Uint32Array(buf.buffer, b + 4096, 32),\n          new Uint32Array(buf.buffer, b + 4224, 1)\n        ];\n        this.oneOne = level ? [\n          new Uint32Array(buf.buffer, b + 4228, 1024),\n          new Uint32Array(buf.buffer, b + 8324, 32),\n          new Uint32Array(buf.buffer, b + 8452, 1)\n        ] : [\n          this.bits,\n          new Uint32Array(buf.buffer, b + 4228, 32),\n          new Uint32Array(buf.buffer, b + 4356, 1)\n        ];\n      }\n    };\n    var ZEROS = [new Page(0), new Page(1), new Page(2), new Page(3)];\n    var MASK = new Uint32Array(32);\n    var MASK_INCL = new Uint32Array(32);\n    for (i = 0; i < 32; i++) {\n      MASK[i] = Math.pow(2, 31 - i) - 1;\n      MASK_INCL[i] = Math.pow(2, 32 - i) - 1;\n    }\n    var i;\n    var LITTLE_ENDIAN = new Uint8Array(MASK.buffer, MASK.byteOffset, 1)[0] === 255;\n    var Bitfield = class {\n      constructor() {\n        this.length = 32768;\n        this.littleEndian = LITTLE_ENDIAN;\n        this._path = new Uint16Array(5);\n        this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4);\n        this._parents = new Array(4).fill(null);\n        this._page = new Page(0);\n        this._allocs = 1;\n      }\n      last() {\n        var page = this._page;\n        var b = 0;\n        while (true) {\n          for (var i2 = 2; i2 >= 0; i2--) {\n            const c = ctz(page.oneOne[i2][b]);\n            if (c === 32)\n              return -1;\n            b = (b << 5) + (31 - c);\n          }\n          this._path[page.level] = b;\n          if (!page.level)\n            return defactor(this._path);\n          page = page.children[b];\n          b = 0;\n        }\n      }\n      set(index, bit) {\n        const page = this._getPage(index, bit);\n        if (!page)\n          return false;\n        const i2 = this._path[0];\n        const r = i2 & 31;\n        const b = i2 >>> 5;\n        const prev = page.bits[b];\n        page.bits[b] = bit ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);\n        const upd = page.bits[b];\n        if (upd === prev)\n          return false;\n        this._updateAllOne(page, b, upd);\n        this._updateOneOne(page, b, upd);\n        return true;\n      }\n      get(index) {\n        const page = this._getPage(index, false);\n        if (!page)\n          return false;\n        const i2 = this._path[0];\n        const r = i2 & 31;\n        return (page.bits[i2 >>> 5] & 2147483648 >>> r) !== 0;\n      }\n      iterator() {\n        return new Iterator(this);\n      }\n      fill(val2, start, end) {\n        if (!start)\n          start = 0;\n        if (val2 === true)\n          return this._fillBit(true, start, end === 0 ? end : end || this.length);\n        if (val2 === false)\n          return this._fillBit(false, start, end === 0 ? end : end || this.length);\n        this._fillBuffer(val2, start, end === 0 ? end : end || start + 8 * val2.length);\n      }\n      grow() {\n        if (this._page.level === 3)\n          throw new Error(\"Cannot grow beyond \" + this.length);\n        const page = this._page;\n        this._page = new Page(page.level + 1);\n        this._page.children[0] = page;\n        if (this._page.level === 3)\n          this.length = Number.MAX_SAFE_INTEGER;\n        else\n          this.length *= 32768;\n      }\n      _fillBuffer(buf, start, end) {\n        if (start & 7 || end & 7)\n          throw new Error(\"Offsets must be a multiple of 8\");\n        start /= 8;\n        while (end > this.length)\n          this.grow();\n        end /= 8;\n        const offset = start;\n        var page = this._getPage(8 * start, true);\n        while (start < end) {\n          const delta = end - start < 4096 ? end - start : 4096;\n          const s = start - offset;\n          start += this._setPageBuffer(page, buf.subarray(s, s + delta), start & 1023);\n          if (start !== end)\n            page = this._nextPage(page, 8 * start);\n        }\n      }\n      _fillBit(bit, start, end) {\n        var page = this._getPage(start, bit);\n        while (start < end) {\n          const delta = end - start < 32768 ? end - start : 32768;\n          start += this._setPageBits(page, bit, start & 32767, delta);\n          if (start !== end)\n            page = this._nextPage(page, start);\n        }\n      }\n      _nextPage(page, start) {\n        const i2 = ++this._offsets[page.level];\n        return i2 === 32768 ? this._getPage(start, true) : this._parents[page.level].children[i2] || this._addPage(this._parents[page.level], i2);\n      }\n      _setPageBuffer(page, buf, start) {\n        new Uint8Array(page.bits.buffer, page.bits.byteOffset, page.bits.length * 4).set(buf, start);\n        start >>>= 2;\n        this._update(page, start, start + (buf.length >>> 2) + (buf.length & 3 ? 1 : 0));\n        return buf.length;\n      }\n      _setPageBits(page, bit, start, end) {\n        const s = start >>> 5;\n        const e = end >>> 5;\n        const sm = 4294967295 >>> (start & 31);\n        const em = ~(4294967295 >>> (end & 31));\n        if (s === e) {\n          page.bits[s] = bit ? page.bits[s] | sm & em : page.bits[s] & ~(sm & em);\n          this._update(page, s, s + 1);\n          return end - start;\n        }\n        page.bits[s] = bit ? page.bits[s] | sm : page.bits[s] & ~sm;\n        if (e - s > 2)\n          page.bits.fill(bit ? 4294967295 : 0, s + 1, e - 1);\n        if (e === 1024) {\n          page.bits[e - 1] = bit ? 4294967295 : 0;\n          this._update(page, s, e);\n          return end - start;\n        }\n        page.bits[e] = bit ? page.bits[e] | em : page.bits[e] & ~em;\n        this._update(page, s, e + 1);\n        return end - start;\n      }\n      _update(page, start, end) {\n        for (; start < end; start++) {\n          const upd = page.bits[start];\n          this._updateAllOne(page, start, upd);\n          this._updateOneOne(page, start, upd);\n        }\n      }\n      _updateAllOne(page, b, upd) {\n        var i2 = 1;\n        do {\n          for (; i2 < 3; i2++) {\n            const buf = page.allOne[i2];\n            const r = b & 31;\n            const prev = buf[b >>>= 5];\n            buf[b] = upd === 4294967295 ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);\n            upd = buf[b];\n            if (upd === prev)\n              return;\n          }\n          b += this._offsets[page.level];\n          page = this._parents[page.level];\n          i2 = 0;\n        } while (page);\n      }\n      _updateOneOne(page, b, upd) {\n        var i2 = 1;\n        do {\n          for (; i2 < 3; i2++) {\n            const buf = page.oneOne[i2];\n            const r = b & 31;\n            const prev = buf[b >>>= 5];\n            buf[b] = upd !== 0 ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);\n            upd = buf[b];\n            if (upd === prev)\n              return;\n          }\n          b += this._offsets[page.level];\n          page = this._parents[page.level];\n          i2 = 0;\n          if (upd === 0 && page) {\n            page.children[this._offsets[page.level - 1]] = void 0;\n          }\n        } while (page);\n      }\n      _getPage(index, createIfMissing) {\n        factor(index, this._path);\n        while (index >= this.length) {\n          if (!createIfMissing)\n            return null;\n          this.grow();\n        }\n        var page = this._page;\n        for (var i2 = page.level; i2 > 0 && page; i2--) {\n          const p = this._path[i2];\n          this._parents[i2 - 1] = page;\n          page = page.children[p] || (createIfMissing ? this._addPage(page, p) : null);\n        }\n        return page;\n      }\n      _addPage(page, i2) {\n        this._allocs++;\n        page = page.children[i2] = new Page(page.level - 1);\n        return page;\n      }\n    };\n    var Iterator = class {\n      constructor(bitfield) {\n        this._bitfield = bitfield;\n        this._path = new Uint16Array(5);\n        this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4);\n        this._parents = new Array(4).fill(null);\n        this._page = null;\n        this._allocs = bitfield._allocs;\n        this.seek(0);\n      }\n      seek(index) {\n        this._allocs = this._bitfield._allocs;\n        if (index >= this._bitfield.length) {\n          this._page = null;\n          return this;\n        }\n        factor(index, this._path);\n        this._page = this._bitfield._page;\n        for (var i2 = this._page.level; i2 > 0; i2--) {\n          this._parents[i2 - 1] = this._page;\n          this._page = this._page.children[this._path[i2]] || ZEROS[i2 - 1];\n        }\n        return this;\n      }\n      next(bit) {\n        return bit ? this.nextTrue() : this.nextFalse();\n      }\n      nextFalse() {\n        if (this._allocs !== this._bitfield._allocs) {\n          this.seek(defactor(this._path));\n        }\n        var page = this._page;\n        var b = this._path[0];\n        var mask = MASK_INCL;\n        while (page) {\n          for (var i2 = 0; i2 < 3; i2++) {\n            const r = b & 31;\n            const clz = Math.clz32(~page.allOne[i2][b >>>= 5] & mask[r]);\n            if (clz !== 32)\n              return this._downLeftFalse(page, i2, b, clz);\n            mask = MASK;\n          }\n          b = this._offsets[page.level];\n          page = this._parents[page.level];\n        }\n        return -1;\n      }\n      _downLeftFalse(page, i2, b, clz) {\n        while (true) {\n          while (i2) {\n            b = (b << 5) + clz;\n            clz = Math.clz32(~page.allOne[--i2][b]);\n          }\n          b = (b << 5) + clz;\n          if (!page.level)\n            break;\n          this._parents[page.level - 1] = page;\n          this._path[page.level] = b;\n          page = page.children[b];\n          i2 = 3;\n          clz = b = 0;\n        }\n        this._page = page;\n        this._path[0] = b;\n        return this._inc();\n      }\n      nextTrue() {\n        var page = this._page;\n        var b = this._path[0];\n        var mask = MASK_INCL;\n        while (page) {\n          for (var i2 = 0; i2 < 3; i2++) {\n            const r = b & 31;\n            const clz = Math.clz32(page.oneOne[i2][b >>>= 5] & mask[r]);\n            if (clz !== 32)\n              return this._downLeftTrue(page, i2, b, clz);\n            mask = MASK;\n          }\n          b = this._offsets[page.level];\n          page = this._parents[page.level];\n        }\n        return -1;\n      }\n      _downLeftTrue(page, i2, b, clz) {\n        while (true) {\n          while (i2) {\n            b = (b << 5) + clz;\n            clz = Math.clz32(page.oneOne[--i2][b]);\n          }\n          b = (b << 5) + clz;\n          if (!page.level)\n            break;\n          this._parents[page.level - 1] = page;\n          this._path[page.level] = b;\n          page = page.children[b];\n          i2 = 3;\n          clz = b = 0;\n        }\n        this._page = page;\n        this._path[0] = b;\n        return this._inc();\n      }\n      _inc() {\n        const n = defactor(this._path);\n        if (this._path[0] < 32767)\n          this._path[0]++;\n        else\n          this.seek(n + 1);\n        return n;\n      }\n    };\n    function defactor(out) {\n      return ((out[3] * 32768 + out[2]) * 32768 + out[1]) * 32768 + out[0];\n    }\n    function factor(n, out) {\n      n = (n - (out[0] = n & 32767)) / 32768;\n      n = (n - (out[1] = n & 32767)) / 32768;\n      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;\n    }\n  }\n});\n\n// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/replicate.js\nvar require_replicate = __commonJS({\n  \"node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/replicate.js\"(exports, module) {\n    init_inject_globals();\n    var Protocol = require_hypercore_protocol();\n    var timeout = require_browser4();\n    var bitfield = require_fast_bitfield();\n    var set = require_unordered_set();\n    var rle = require_bitfield_rle().align(4);\n    var treeIndex = require_tree_index();\n    var EMPTY = new Uint8Array(1024);\n    module.exports = replicate;\n    function replicate(feed, initiator, opts) {\n      feed.ifAvailable.wait();\n      var stream = Protocol.isProtocolStream(initiator) ? initiator : opts.stream;\n      if (!stream) {\n        if (!opts.keyPair)\n          opts.keyPair = feed.noiseKeyPair;\n        stream = new Protocol(initiator, opts);\n      }\n      if (feed.opened)\n        onready(null);\n      else\n        feed.ready(onready);\n      return stream;\n      function onready(err) {\n        feed.ifAvailable.continue();\n        if (err)\n          return stream.destroy(err);\n        if (stream.destroyed)\n          return;\n        if (stream.opened(feed.key))\n          return;\n        if (opts.noise !== false && opts.onfeedauthenticate) {\n          if (!stream.remotePublicKey) {\n            feed.ifAvailable.wait();\n            stream.setMaxListeners(0);\n            stream.on(\"close\", onhandshake);\n            stream.on(\"handshake\", onhandshake);\n            return;\n          }\n          feedauthenticate();\n          return;\n        }\n        replicatePeer();\n      }\n      function onhandshake() {\n        feed.ifAvailable.continue();\n        stream.off(\"close\", onhandshake);\n        stream.off(\"handshake\", onhandshake);\n        feedauthenticate();\n      }\n      function feedauthenticate() {\n        if (stream.destroyed)\n          return;\n        if (stream.opened(feed.key))\n          return;\n        feed.ifAvailable.wait();\n        opts.onfeedauthenticate(feed, stream.remotePublicKey, function(err) {\n          feed.ifAvailable.continue();\n          if (stream.destroyed)\n            return;\n          if (stream.opened(feed.key))\n            return;\n          if (err) {\n            stream.close(feed.discoveryKey);\n            return;\n          }\n          replicatePeer();\n        });\n      }\n      function replicatePeer() {\n        if (opts.noise !== false) {\n          if (stream.remoteOpened(feed.key) && !stream.remoteVerified(feed.key)) {\n            stream.close(feed.discoveryKey);\n            return;\n          }\n        }\n        var peer = new Peer(feed, opts);\n        peer.feed = feed;\n        peer.stream = stream.open(feed.key, peer);\n        stream.setMaxListeners(0);\n        peer.ready();\n        feed.emit(\"replicating\", stream);\n      }\n    }\n    function Peer(feed, opts) {\n      if (opts.extensions)\n        throw new Error(\"Per peer extensions is not supported. Use feed.registerExtension instead\");\n      this.feed = feed;\n      this.stream = null;\n      this.wants = bitfield();\n      this.remoteBitfield = bitfield();\n      this.remoteLength = 0;\n      this.remoteWant = false;\n      this.remoteTree = null;\n      this.remoteAck = false;\n      this.remoteOpened = false;\n      this.live = !!opts.live;\n      this.sparse = feed.sparse;\n      this.ack = !!opts.ack;\n      this.remoteDownloading = true;\n      this.remoteUploading = true;\n      this.remoteExtensions = feed.extensions.remote();\n      this.downloading = typeof opts.download === \"boolean\" ? opts.download : feed.downloading;\n      this.uploading = typeof opts.upload === \"boolean\" ? opts.upload : feed.uploading;\n      this.updated = false;\n      this.maxRequests = opts.maxRequests || feed.maxRequests || 16;\n      this.urgentRequests = this.maxRequests + 16;\n      this.inflightRequests = [];\n      this.inflightWants = 0;\n      this._index = -1;\n      this._lastBytes = 0;\n      this._first = true;\n      this._closed = false;\n      this._destroyed = false;\n      this._defaultDownloading = this.downloading;\n      this._iterator = this.remoteBitfield.iterator();\n      this._requestTimeout = null;\n      this.stats = !opts.stats ? null : {\n        uploadedBytes: 0,\n        uploadedBlocks: 0,\n        downloadedBytes: 0,\n        downloadedBlocks: 0\n      };\n    }\n    Object.defineProperty(Peer.prototype, \"remoteAddress\", {\n      enumerable: true,\n      get: function() {\n        return this.stream.stream.remoteAddress;\n      }\n    });\n    Object.defineProperty(Peer.prototype, \"remoteType\", {\n      enumerable: true,\n      get: function() {\n        return this.stream.stream.remoteType;\n      }\n    });\n    Object.defineProperty(Peer.prototype, \"remotePublicKey\", {\n      enumerable: true,\n      get: function() {\n        return this.stream.state.remotePublicKey;\n      }\n    });\n    Peer.prototype.onwant = function(want) {\n      if (!this.uploading)\n        return;\n      if (want.start & 8191 || want.length & 8191)\n        return;\n      if (!this.remoteWant && this.feed.length && this.feed.bitfield.get(this.feed.length - 1)) {\n        this.stream.have({ start: this.feed.length - 1 });\n      }\n      this.remoteWant = true;\n      var rle2 = this.feed.bitfield.compress(want.start, want.length);\n      this.stream.have({ start: want.start, length: want.length, bitfield: rle2 });\n    };\n    Peer.prototype.ondata = function(data) {\n      var self = this;\n      var allowPush = this.feed.allowPush || !data.value;\n      if (!allowPush && !this.feed._reserved.get(data.index)) {\n        if (!self.feed.bitfield.get(data.index))\n          self.unhave({ start: data.index });\n        self._clear(data.index, !data.value);\n        return;\n      }\n      this.feed._putBuffer(data.index, data.value, data, this, function(err) {\n        if (err)\n          return self.destroy(err);\n        if (data.value)\n          self.remoteBitfield.set(data.index, false);\n        if (self.remoteAck) {\n          self.stream.have({ start: data.index, length: 1, ack: true });\n        }\n        if (self.stats && data.value) {\n          self.stats.downloadedBlocks += 1;\n          self.stats.downloadedBytes += data.value.length;\n        }\n        self._clear(data.index, !data.value);\n      });\n    };\n    Peer.prototype._clear = function(index, hash) {\n      for (var i = 0; i < this.inflightRequests.length; i++) {\n        if (this.inflightRequests[i].index === index) {\n          if (this._requestTimeout !== null)\n            this._requestTimeout.refresh();\n          this.inflightRequests.splice(i, 1);\n          i--;\n        }\n      }\n      this.feed._reserved.set(index, false);\n      this.feed._updatePeers();\n      if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n        this._requestTimeout.destroy();\n        this._requestTimeout = null;\n      }\n    };\n    Peer.prototype.onrequest = function(request) {\n      if (!this.uploading)\n        return;\n      if (request.bytes)\n        return this._onbytes(request);\n      if (!this.remoteTree)\n        this.remoteTree = treeIndex();\n      var self = this;\n      var opts = { digest: request.nodes, hash: request.hash, tree: this.remoteTree };\n      this.feed.proof(request.index, opts, onproof);\n      function onproof(err, proof) {\n        if (err)\n          return self.destroy(err);\n        if (request.hash)\n          onvalue(null, null);\n        else if (self.feed.bitfield.get(request.index))\n          self.feed._getBuffer(request.index, onvalue);\n        function onvalue(err2, value) {\n          if (!self.uploading)\n            return;\n          if (err2)\n            return self.destroy(err2);\n          if (value) {\n            if (self.stats) {\n              self.stats.uploadedBlocks += 1;\n              self.stats.uploadedBytes += value.length;\n              self.feed._stats.uploadedBlocks += 1;\n              self.feed._stats.uploadedBytes += value.length;\n            }\n            self.feed.emit(\"upload\", request.index, value, self);\n          }\n          if (request.index + 1 > self.remoteLength) {\n            self.remoteLength = request.index + 1;\n            self._updateEnd();\n          }\n          self.stream.data({\n            index: request.index,\n            value,\n            nodes: proof.nodes,\n            signature: proof.signature\n          });\n        }\n      }\n    };\n    Peer.prototype._updateOptions = function() {\n      if (this.ack || this.feed.extensions.length) {\n        this.stream.options({\n          ack: this.ack,\n          extensions: this.feed.extensions.names()\n        });\n      }\n    };\n    Peer.prototype.setDownloading = function(downloading) {\n      if (downloading === this.downloading)\n        return;\n      this.downloading = downloading;\n      this.stream.status({\n        downloading,\n        uploading: this.uploading\n      });\n      this.update();\n    };\n    Peer.prototype.setUploading = function(uploading) {\n      if (uploading === this.uploading)\n        return;\n      this.uploading = uploading;\n      this.stream.status({\n        downloading: this.downloading,\n        uploading\n      });\n      this.update();\n    };\n    Peer.prototype._onbytes = function(request) {\n      var self = this;\n      this.feed.seek(request.bytes, { wait: false }, function(err, index) {\n        if (err) {\n          request.bytes = 0;\n          self.onrequest(request);\n          return;\n        }\n        if (self._lastBytes === request.bytes)\n          return;\n        self._lastBytes = request.bytes;\n        request.bytes = 0;\n        request.index = index;\n        request.nodes = 0;\n        self.onrequest(request);\n      });\n    };\n    Peer.prototype._onrequesttimeout = function() {\n      this._requestTimeout = null;\n      if (!this.inflightRequests.length)\n        return;\n      var first = this.inflightRequests[0];\n      if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {\n        this.inflightRequests.shift();\n        this.feed._reserved.set(first.index, false);\n        if (this.stream.stream.timeout) {\n          this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this);\n        }\n        return;\n      }\n      this.destroy(new Error(\"Request timeout\"));\n    };\n    Peer.prototype.onhave = function(have) {\n      this.feed.emit(\"peer-ack\", this, have);\n      if (this.ack && have.ack && !have.bitfield && this.feed.bitfield.get(have.start)) {\n        this.stream.stream.emit(\"ack\", have);\n        return;\n      }\n      var updated = this._first;\n      if (this._first)\n        this._first = false;\n      if (have.length === 1024 * 1024 && this.inflightWants > 0) {\n        this.feed.ifAvailable.continue();\n        this.inflightWants--;\n      }\n      if (have.bitfield) {\n        if (have.length === 0 || have.length === 1) {\n          this.wants = null;\n        }\n        var buf = rle.decode(have.bitfield);\n        var bits = buf.length * 8;\n        remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start);\n        this.remoteBitfield.fill(buf, have.start);\n        if (bits > this.remoteLength) {\n          this.remoteLength = this.remoteBitfield.last() + 1;\n          updated = true;\n        }\n      } else {\n        var start = have.start;\n        var len = have.length || 1;\n        while (len--)\n          this.remoteBitfield.set(start, !this.feed.bitfield.get(start++));\n        if (start > this.remoteLength) {\n          this.remoteLength = start;\n          updated = true;\n        }\n      }\n      if (updated) {\n        this.updated = true;\n        this.feed.emit(\"remote-update\", this);\n      }\n      this._updateEnd();\n      this.update();\n    };\n    Peer.prototype._updateEnd = function() {\n      if (this.live || this.feed.sparse || !this.feed._selections.length)\n        return;\n      var sel = this.feed._selections[0];\n      var remoteLength = this.feed.length || -1;\n      for (var i = 0; i < this.feed.peers.length; i++) {\n        if (this.feed.peers[i].remoteLength > remoteLength) {\n          remoteLength = this.feed.peers[i].remoteLength;\n        }\n      }\n      sel.end = remoteLength;\n    };\n    Peer.prototype.onextension = function(id, message) {\n      this.remoteExtensions.onmessage(id, message, this);\n    };\n    Peer.prototype.onstatus = function(info) {\n      this.remoteUploading = info.uploading;\n      this.remoteDownloading = info.downloading;\n      if (!info.uploading) {\n        while (this.inflightRequests.length) {\n          const data = this.inflightRequests[0];\n          this._clear(data.index, !data.value);\n        }\n        for (var i = 0; i < this.inflightWants; i++) {\n          this.feed.ifAvailable.continue();\n        }\n        this.inflightWants = 0;\n        this.wants = bitfield();\n      }\n      this.update();\n      if (info.downloading || this.live)\n        return;\n      if (this.feed._selections.length && this.downloading)\n        return;\n      this._autoEnd();\n    };\n    Peer.prototype._autoEnd = function() {\n      if (this.uploading && this.remoteDownloading)\n        return;\n      if ((this.sparse || this.live) && (this.remoteUploading || this.downloading))\n        return;\n      this.end();\n    };\n    Peer.prototype.onunhave = function(unhave) {\n      var start = unhave.start;\n      var len = unhave.length || 1;\n      if (start === 0 && len >= this.remoteLength) {\n        this.remoteLength = 0;\n        this.remoteBitfield = bitfield();\n        return;\n      }\n      while (len--)\n        this.remoteBitfield.set(start++, false);\n    };\n    Peer.prototype.onunwant = Peer.prototype.oncancel = function() {\n    };\n    Peer.prototype.onclose = function() {\n      this._close();\n    };\n    Peer.prototype.have = function(have) {\n      if (this.stream && this.remoteWant)\n        this.stream.have(have);\n      var start = have.start;\n      var len = have.length;\n      while (len--)\n        this.remoteBitfield.set(start++, false);\n    };\n    Peer.prototype.unhave = function(unhave) {\n      if (this.stream && this.remoteWant)\n        this.stream.unhave(unhave);\n    };\n    Peer.prototype.haveBytes = function(bytes) {\n      for (var i = 0; i < this.inflightRequests.length; i++) {\n        if (this.inflightRequests[i].bytes === bytes) {\n          this.feed._reserved.set(this.inflightRequests[i].index, false);\n          this.inflightRequests.splice(i, 1);\n          i--;\n        }\n      }\n      this.update();\n      if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n        this._requestTimeout.destroy();\n        this._requestTimeout = null;\n      }\n    };\n    Peer.prototype.update = function() {\n      while (this._update()) {\n      }\n      this._sendWantsMaybe();\n    };\n    Peer.prototype._update = function() {\n      if (!this.downloading || !this.remoteUploading)\n        return false;\n      var selections = this.feed._selections;\n      var waiting = this.feed._waiting;\n      var wlen = waiting.length;\n      var slen = selections.length;\n      var inflight = this.inflightRequests.length;\n      var offset = 0;\n      var i = 0;\n      while (inflight < this.urgentRequests) {\n        offset = Math.floor(Math.random() * waiting.length);\n        for (i = 0; i < waiting.length; i++) {\n          var w = waiting[offset++];\n          if (offset === waiting.length)\n            offset = 0;\n          this._downloadWaiting(w);\n          if (waiting.length !== wlen)\n            return true;\n          if (this.inflightRequests.length >= this.urgentRequests)\n            return false;\n        }\n        if (inflight === this.inflightRequests.length)\n          break;\n        inflight = this.inflightRequests.length;\n      }\n      while (inflight < this.maxRequests) {\n        offset = Math.floor(Math.random() * selections.length);\n        for (i = 0; i < selections.length; i++) {\n          var s = selections[offset++];\n          if (offset === selections.length)\n            offset = 0;\n          if (!s.iterator)\n            s.iterator = this.feed.bitfield.iterator(s.start, s.end);\n          if (s.blocks)\n            this._downloadBlocks(s);\n          else\n            this._downloadRange(s);\n          if (selections.length !== slen)\n            return true;\n          if (this.inflightRequests.length >= this.maxRequests)\n            return false;\n        }\n        if (inflight === this.inflightRequests.length)\n          return false;\n        inflight = this.inflightRequests.length;\n      }\n      return false;\n    };\n    Peer.prototype.onopen = function() {\n      this.feed.ifAvailable.continue();\n      this.remoteOpened = true;\n      this._updateOptions();\n      if (!this.uploading || !this.downloading) {\n        this.stream.status({\n          uploading: this.uploading,\n          downloading: this.downloading\n        });\n      }\n      this._sendWants();\n      this.feed.emit(\"peer-open\", this);\n    };\n    Peer.prototype.onoptions = function(options) {\n      this.remoteAck = options.ack;\n      this.remoteExtensions.update(options.extensions);\n    };\n    Peer.prototype.ready = function() {\n      this.feed.ifAvailable.wait();\n      set.add(this.feed.peers, this);\n      this.feed.emit(\"peer-add\", this);\n      if (this.stream.remoteOpened)\n        this.onopen();\n    };\n    Peer.prototype.end = function() {\n      if (!this.downloading && !this.remoteDownloading && !this.live) {\n        if (!this._defaultDownloading) {\n          this.stream.status({ downloading: false, uploading: false });\n        }\n        this._close();\n        return;\n      }\n      if (!this._closed) {\n        this._closed = true;\n        this.downloading = false;\n        this.stream.status({ downloading: false, uploading: true });\n      } else {\n        if (!this.live)\n          this._close();\n      }\n    };\n    Peer.prototype._close = function() {\n      if (!this._destroyed) {\n        this._destroyed = true;\n        this.stream.close();\n      }\n      if (this._index === -1)\n        return;\n      set.remove(this.feed.peers, this);\n      this._index = -1;\n      for (var i = 0; i < this.inflightRequests.length; i++) {\n        this.feed._reserved.set(this.inflightRequests[i].index, false);\n      }\n      if (this._requestTimeout !== null) {\n        this._requestTimeout.destroy();\n        this._requestTimeout = null;\n      }\n      this._updateEnd();\n      this.remoteWant = false;\n      this.feed._updatePeers();\n      this.feed.emit(\"peer-remove\", this);\n      for (i = 0; i < this.inflightWants; i++) {\n        this.feed.ifAvailable.continue();\n      }\n      if (!this.remoteOpened) {\n        this.feed.ifAvailable.continue();\n      }\n    };\n    Peer.prototype.destroy = function(err) {\n      if (this._index === -1 || this._destroyed)\n        return;\n      this.stream.destroy(err);\n      this._destroyed = true;\n      this._close();\n    };\n    Peer.prototype._sendWantsMaybe = function() {\n      if (this.inflightRequests.length < this.urgentRequests)\n        this._sendWants();\n    };\n    Peer.prototype._sendWants = function() {\n      if (!this.wants || !this.downloading || !this.remoteOpened || !this.remoteUploading)\n        return;\n      if (this.inflightWants >= 16)\n        return;\n      var i;\n      for (i = 0; i < this.feed._waiting.length; i++) {\n        var w = this.feed._waiting[i];\n        if (w.index === -1)\n          this._sendWantRange(w);\n        else\n          this._sendWant(w.index);\n        if (this.inflightWants >= 16)\n          return;\n      }\n      for (i = 0; i < this.feed._selections.length; i++) {\n        var s = this.feed._selections[i];\n        this._sendWantRange(s);\n        if (this.inflightWants >= 16)\n          return;\n      }\n      this._sendWant(0);\n    };\n    Peer.prototype._sendWantRange = function(s) {\n      if (s.blocks) {\n        if (!s.selected)\n          s.selected = /* @__PURE__ */ new WeakSet();\n        if (s.selected.has(this))\n          return;\n        s.selected.add(this);\n        for (const block of s.blocks) {\n          this._sendWant(block);\n        }\n        return;\n      }\n      var want = s.start ? 1024 * 1024 * Math.floor(s.start / 1024 / 1024) : 0;\n      while (true) {\n        if (want >= this.remoteLength)\n          return;\n        if (s.end !== -1 && want >= s.end)\n          return;\n        if (this._sendWant(want))\n          return;\n        if (!this.wants.get(Math.floor(want / 1024 / 1024)))\n          return;\n        want += 1024 * 1024;\n      }\n    };\n    Peer.prototype._sendWant = function(index) {\n      var len = 1024 * 1024;\n      var j = Math.floor(index / len);\n      if (this.wants.get(j))\n        return false;\n      this.wants.set(j, true);\n      this.inflightWants++;\n      this.feed.ifAvailable.wait();\n      this.stream.want({ start: j * len, length: len });\n      return true;\n    };\n    Peer.prototype._downloadWaiting = function(wait) {\n      if (!wait.bytes) {\n        if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) {\n          if (!wait.update || this.feed._reserved.get(wait.index))\n            return;\n          const i = this._iterator.seek(wait.index).next(true);\n          if (i === -1 || !this.feed._reserved.set(i, true))\n            return;\n          wait.index = i;\n        }\n        this._request(wait.index, 0, wait.hash === true);\n        return;\n      }\n      this._downloadRange(wait);\n    };\n    Peer.prototype._downloadBlocks = function(range) {\n      while (range.blocksDownloaded < range.blocks.length) {\n        const blk = range.blocks[range.blocksDownloaded];\n        if (!this.feed.bitfield.get(blk))\n          break;\n        range.blocksDownloaded++;\n      }\n      if (range.blocksDownloaded >= range.blocks.length) {\n        set.remove(this.feed._selections, range);\n        range.callback(null);\n        return;\n      }\n      for (var i = range.blocksDownloaded; i < range.blocks.length; i++) {\n        const blk = range.blocks[i];\n        if (this.remoteBitfield.get(blk) && this.feed._reserved.set(blk, true)) {\n          range.requested++;\n          this._request(blk, 0, false);\n          return;\n        }\n      }\n    };\n    Peer.prototype._downloadRange = function(range) {\n      if (!range.iterator)\n        range.iterator = this.feed.bitfield.iterator(range.start, range.end);\n      var reserved = this.feed._reserved;\n      var ite = this._iterator;\n      var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength);\n      var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd);\n      var start = i;\n      if (i === -1 || i >= wantedEnd) {\n        if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {\n          set.remove(this.feed._selections, range);\n          range.callback(null);\n          if (!this.live && !this.sparse && !this.feed._selections.length)\n            this.end();\n        }\n        return;\n      }\n      while (range.hash && this.feed.tree.get(2 * i) || !reserved.set(i, true)) {\n        i = ite.next(true);\n        if (i > -1 && i < wantedEnd) {\n          continue;\n        }\n        if (!range.linear && start !== 0) {\n          i = ite.seek(range.start).next(true);\n          start = 0;\n          if (i > -1 && i < wantedEnd)\n            continue;\n        }\n        if (range.hash) {\n          for (var j = range.start; j < wantedEnd; j++) {\n            if (!this.feed.tree.get(2 * j))\n              return;\n          }\n          if (!range.bytes) {\n            set.remove(this.feed._selections, range);\n            range.callback(null);\n          }\n        }\n        return;\n      }\n      range.requested++;\n      this._request(i, range.bytes || 0, range.hash);\n    };\n    Peer.prototype._request = function(index, bytes, hash) {\n      var request = {\n        bytes,\n        index,\n        hash,\n        nodes: this.feed.digest(index)\n      };\n      if (this._requestTimeout === null && this.stream.stream.timeout) {\n        this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this);\n      }\n      this.inflightRequests.push(request);\n      this.stream.request(request);\n    };\n    Peer.prototype.extension = function(id, message) {\n      this.stream.extension(id, message);\n    };\n    function createView(page) {\n      var buf = page ? page.buffer : EMPTY;\n      return new DataView(buf.buffer, buf.byteOffset, 1024);\n    }\n    function remoteAndNotLocal(local, buf, le, start) {\n      var remote = new DataView(buf.buffer, buf.byteOffset);\n      var len = Math.floor(buf.length / 4);\n      var arr = new Uint32Array(buf.buffer, buf.byteOffset, len);\n      var p = start / 8192;\n      var l = 0;\n      var page = createView(local.pages.get(p++, true));\n      for (var i = 0; i < len; i++) {\n        arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * l++, !le);\n        if (l === 256) {\n          page = createView(local.pages.get(p++, true));\n          l = 0;\n        }\n      }\n    }\n    function nextRandom(ite, start, end) {\n      var len = end - start;\n      var i = ite.seek(Math.floor(Math.random() * len) + start).next(true);\n      return i === -1 || i >= end ? ite.seek(start).next(true) : i;\n    }\n  }\n});\n\n// node_modules/.pnpm/nanoresource@1.3.0/node_modules/nanoresource/emitter.js\nvar require_emitter = __commonJS({\n  \"node_modules/.pnpm/nanoresource@1.3.0/node_modules/nanoresource/emitter.js\"(exports, module) {\n    init_inject_globals();\n    var events = import$_dxos_node_std_events;\n    var inherits = require_inherits_browser();\n    var opening = Symbol(\"opening queue\");\n    var preclosing = Symbol(\"closing when inactive\");\n    var closing = Symbol(\"closing queue\");\n    var sync = Symbol(\"sync\");\n    var fastClose = Symbol(\"fast close\");\n    module.exports = Nanoresource;\n    function Nanoresource(opts) {\n      if (!(this instanceof Nanoresource))\n        return new Nanoresource(opts);\n      events.EventEmitter.call(this);\n      if (!opts)\n        opts = {};\n      if (opts.open)\n        this._open = opts.open;\n      if (opts.close)\n        this._close = opts.close;\n      this.opening = false;\n      this.opened = false;\n      this.closing = false;\n      this.closed = false;\n      this.actives = 0;\n      this[opening] = null;\n      this[preclosing] = null;\n      this[closing] = null;\n      this[sync] = false;\n      this[fastClose] = true;\n    }\n    inherits(Nanoresource, events.EventEmitter);\n    Nanoresource.prototype._open = function(cb) {\n      cb(null);\n    };\n    Nanoresource.prototype._close = function(cb) {\n      cb(null);\n    };\n    Nanoresource.prototype.open = function(cb) {\n      if (!cb)\n        cb = noop;\n      if (this[closing] || this.closed)\n        return process.nextTick(cb, new Error(\"Resource is closed\"));\n      if (this.opened)\n        return process.nextTick(cb);\n      if (this[opening]) {\n        this[opening].push(cb);\n        return;\n      }\n      this.opening = true;\n      this[opening] = [cb];\n      this[sync] = true;\n      this._open(onopen.bind(this));\n      this[sync] = false;\n    };\n    Nanoresource.prototype.active = function(cb) {\n      if (this[fastClose] && this[preclosing] || this[closing] || this.closed) {\n        if (cb)\n          process.nextTick(cb, new Error(\"Resource is closed\"));\n        return false;\n      }\n      this.actives++;\n      return true;\n    };\n    Nanoresource.prototype.inactive = function(cb, err, val2) {\n      if (!--this.actives) {\n        const queue = this[preclosing];\n        if (queue) {\n          this[preclosing] = null;\n          while (queue.length)\n            this.close(queue.shift());\n        }\n      }\n      if (cb)\n        cb(err, val2);\n    };\n    Nanoresource.prototype.close = function(allowActive, cb) {\n      if (typeof allowActive === \"function\")\n        return this.close(false, allowActive);\n      if (!cb)\n        cb = noop;\n      if (allowActive)\n        this[fastClose] = false;\n      if (this.closed)\n        return process.nextTick(cb);\n      if (this.actives || this[opening]) {\n        if (!this[preclosing])\n          this[preclosing] = [];\n        this[preclosing].push(cb);\n        return;\n      }\n      if (!this.opened) {\n        this.closed = true;\n        process.nextTick(cb);\n        return;\n      }\n      if (this[closing]) {\n        this[closing].push(cb);\n        return;\n      }\n      this.closing = true;\n      this[closing] = [cb];\n      this[sync] = true;\n      this._close(onclose.bind(this));\n      this[sync] = false;\n    };\n    function onopen(err) {\n      if (this[sync])\n        return process.nextTick(onopen.bind(this), err);\n      const oqueue = this[opening];\n      this[opening] = null;\n      this.opening = false;\n      this.opened = !err;\n      while (oqueue.length)\n        oqueue.shift()(err);\n      const cqueue = this[preclosing];\n      if (cqueue && !this.actives) {\n        this[preclosing] = null;\n        while (cqueue.length)\n          this.close(cqueue.shift());\n      }\n    }\n    function onclose(err) {\n      if (this[sync])\n        return process.nextTick(onclose.bind(this), err);\n      const queue = this[closing];\n      this.closing = false;\n      this[closing] = null;\n      this.closed = !err;\n      while (queue.length)\n        queue.shift()(err);\n    }\n    function noop() {\n    }\n  }\n});\n\n// packages/common/hypercore/src/empty.ts\nvar require_empty = __commonJS({\n  \"packages/common/hypercore/src/empty.ts\"(exports, module) {\n    init_inject_globals();\n    module.exports = new Proxy({}, {\n      get: (target, prop) => {\n        throw new Error(\"Package has been stripped\");\n      }\n    });\n  }\n});\n\n// node_modules/.pnpm/hypercore-streams@1.0.1/node_modules/hypercore-streams/index.js\nvar require_hypercore_streams = __commonJS({\n  \"node_modules/.pnpm/hypercore-streams@1.0.1/node_modules/hypercore-streams/index.js\"(exports, module) {\n    init_inject_globals();\n    var { Writable, Readable: Readable2 } = import$streamx;\n    var WriteStream = class extends Writable {\n      constructor(feed, opts) {\n        super();\n        this.feed = feed;\n        this.maxBlockSize = opts && opts.maxBlockSize || 0;\n      }\n      _writev(batch, cb) {\n        this.feed.append(this.maxBlockSize ? this._ensureMaxSize(batch) : batch, cb);\n      }\n      _ensureMaxSize(batch) {\n        for (let i = 0; i < batch.length; i++) {\n          let blk = batch[i];\n          if (blk.length > this.maxBlockSize) {\n            const chunked = [];\n            while (blk.length > this.maxBlockSize) {\n              chunked.push(blk.slice(0, this.maxBlockSize));\n              blk = blk.slice(this.maxBlockSize);\n            }\n            if (blk.length)\n              chunked.push(blk);\n            batch.splice(i, 1, ...chunked);\n            i += chunked.length - 1;\n          }\n        }\n        return batch;\n      }\n    };\n    var ReadStream = class extends Readable2 {\n      constructor(feed, opts = {}) {\n        super();\n        this.feed = feed;\n        this.start = opts.start || 0;\n        this.end = typeof opts.end === \"number\" ? opts.end : -1;\n        this.live = !!opts.live;\n        this.snapshot = opts.snapshot !== false;\n        this.tail = !!opts.tail;\n        this.index = this.start;\n        this.options = { wait: opts.wait !== false, ifAvailable: !!opts.ifAvailable, valueEncoding: opts.valueEncoding };\n      }\n      _open(cb) {\n        this.feed.ready((err) => {\n          if (err)\n            return cb(err);\n          if (this.end === -1) {\n            if (this.live)\n              this.end = Infinity;\n            else if (this.snapshot)\n              this.end = this.feed.length;\n            if (this.start > this.end)\n              this.push(null);\n          }\n          if (this.tail)\n            this.start = this.feed.length;\n          this.index = this.start;\n          cb(null);\n        });\n      }\n      _read(cb) {\n        if (this.index === this.end || this.end === -1 && this.index >= this.feed.length) {\n          this.push(null);\n          return cb(null);\n        }\n        this.feed.get(this.index++, this.options, (err, block) => {\n          if (err)\n            return cb(err);\n          this.push(block);\n          cb(null);\n        });\n      }\n    };\n    module.exports = { WriteStream, ReadStream };\n  }\n});\n\n// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/index.js\nvar require_hypercore = __commonJS({\n  \"node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/index.js\"(exports, module) {\n    init_inject_globals();\n    var low = require_last_one_wins();\n    var remove = require_unordered_array_remove();\n    var set = require_unordered_set();\n    var MerkleGenerator = require_generator();\n    var flat = require_flat_tree();\n    var codecs = require_codecs();\n    var batcher = require_atomic_batcher();\n    var inherits = require_inherits_browser();\n    var bitfield = require_bitfield();\n    var sparseBitfield = require_sparse_bitfield();\n    var treeIndex = require_tree_index();\n    var storage = require_storage();\n    var crypto = require_hypercore_crypto();\n    var inspect = require_browser();\n    var pretty = require_pretty_hash();\n    var Nanoguard = require_nanoguard();\n    var safeBufferEquals = require_safe_buffer_equals();\n    var replicate = require_replicate();\n    var Protocol = require_hypercore_protocol();\n    var Message = require_abstract_extension();\n    var Nanoresource = require_emitter();\n    var defaultStorage = require_empty();\n    var { WriteStream, ReadStream } = require_hypercore_streams();\n    var Extension = class extends Message {\n      broadcast(message) {\n        const feed = this.local.handlers;\n        const buf = this.encoding.encode(message);\n        let broadcasted = false;\n        for (const peer of feed.peers) {\n          broadcasted = true;\n          peer.extension(this.id, buf);\n        }\n        return broadcasted;\n      }\n      send(message, peer) {\n        peer.extension(this.id, this.encode(message));\n      }\n    };\n    var defaultCrypto = {\n      sign(data, sk, cb) {\n        return cb(null, crypto.sign(data, sk));\n      },\n      verify(sig, data, pk, cb) {\n        return cb(null, crypto.verify(sig, data, pk));\n      }\n    };\n    module.exports = Feed;\n    function Feed(createStorage2, key, opts) {\n      if (!(this instanceof Feed))\n        return new Feed(createStorage2, key, opts);\n      Nanoresource.call(this);\n      if (typeof createStorage2 === \"string\")\n        createStorage2 = defaultStorageDir(createStorage2);\n      if (typeof createStorage2 !== \"function\")\n        throw new Error(\"Storage should be a function or string\");\n      if (typeof key === \"string\")\n        key = Buffer2.from(key, \"hex\");\n      if (!Buffer2.isBuffer(key) && !opts) {\n        opts = key;\n        key = null;\n      }\n      if (!opts)\n        opts = {};\n      var self = this;\n      var secretKey = opts.secretKey || null;\n      if (typeof secretKey === \"string\")\n        secretKey = Buffer2.from(secretKey, \"hex\");\n      this.noiseKeyPair = opts.noiseKeyPair || Protocol.keyPair();\n      this.live = opts.live !== false;\n      this.sparse = !!opts.sparse;\n      this.length = 0;\n      this.byteLength = 0;\n      this.maxRequests = opts.maxRequests || 16;\n      this.key = key || opts.key || null;\n      this.discoveryKey = this.key && crypto.discoveryKey(this.key);\n      this.secretKey = secretKey;\n      this.bitfield = null;\n      this.tree = null;\n      this.writable = !!opts.writable;\n      this.readable = true;\n      this.downloading = opts.downloading !== false;\n      this.uploading = opts.uploading !== false;\n      this.allowPush = !!opts.allowPush;\n      this.peers = [];\n      this.ifAvailable = new Nanoguard();\n      this.extensions = Extension.createLocal(this);\n      this.crypto = opts.crypto || defaultCrypto;\n      this._onwrite = opts.onwrite || null;\n      this._force = !!opts.force;\n      this._expectedLength = -1;\n      this._indexing = !!opts.indexing;\n      this._createIfMissing = opts.createIfMissing !== false;\n      this._overwrite = !!opts.overwrite;\n      this._storeSecretKey = opts.storeSecretKey !== false;\n      this._alwaysIfAvailable = !!opts.ifAvailable;\n      this._merkle = null;\n      this._storage = storage(createStorage2, opts);\n      this._batch = batcher(this._onwrite ? workHook : work);\n      this.timeouts = opts.timeouts || {\n        get(cb) {\n          cb(null);\n        },\n        update(cb) {\n          cb(null);\n        }\n      };\n      this._seq = 0;\n      this._waiting = [];\n      this._selections = [];\n      this._reserved = sparseBitfield();\n      this._synced = null;\n      this._downloadingSet = typeof opts.downloading === \"boolean\";\n      this._stats = typeof opts.stats !== \"undefined\" && !opts.stats ? null : {\n        downloadedBlocks: 0,\n        downloadedBytes: 0,\n        uploadedBlocks: 0,\n        uploadedBytes: 0\n      };\n      this._codec = toCodec(opts.valueEncoding);\n      this._sync = low(sync);\n      if (!this.sparse)\n        this.download({ start: 0, end: -1 });\n      if (this.sparse && opts.eagerUpdate) {\n        this.update(function loop(err) {\n          if (err)\n            self.emit(\"update-error\", err);\n          self.update(loop);\n        });\n      }\n      this.open(onerror);\n      function onerror(err) {\n        if (err)\n          self.emit(\"error\", err);\n      }\n      function workHook(values, cb) {\n        if (!self._merkle)\n          return self._reloadMerkleStateBeforeAppend(workHook, values, cb);\n        self._appendHook(values, cb);\n      }\n      function work(values, cb) {\n        if (!self._merkle)\n          return self._reloadMerkleStateBeforeAppend(work, values, cb);\n        self._append(values, cb);\n      }\n      function sync(_, cb) {\n        self._syncBitfield(cb);\n      }\n    }\n    inherits(Feed, Nanoresource);\n    Feed.discoveryKey = crypto.discoveryKey;\n    Feed.prototype[inspect] = function(depth, opts) {\n      var indent = \"\";\n      if (typeof opts.indentationLvl === \"number\") {\n        while (indent.length < opts.indentationLvl)\n          indent += \" \";\n      }\n      return \"Hypercore(\\n\" + indent + \"  key: \" + opts.stylize(this.key && pretty(this.key), \"string\") + \"\\n\" + indent + \"  discoveryKey: \" + opts.stylize(this.discoveryKey && pretty(this.discoveryKey), \"string\") + \"\\n\" + indent + \"  opened: \" + opts.stylize(this.opened, \"boolean\") + \"\\n\" + indent + \"  sparse: \" + opts.stylize(this.sparse, \"boolean\") + \"\\n\" + indent + \"  writable: \" + opts.stylize(this.writable, \"boolean\") + \"\\n\" + indent + \"  length: \" + opts.stylize(this.length, \"number\") + \"\\n\" + indent + \"  byteLength: \" + opts.stylize(this.byteLength, \"number\") + \"\\n\" + indent + \"  peers: \" + opts.stylize(this.peers.length, \"number\") + \"\\n\" + indent + \")\";\n    };\n    Object.defineProperty(Feed.prototype, \"remoteLength\", {\n      enumerable: true,\n      get: function() {\n        var len = 0;\n        for (var i = 0; i < this.peers.length; i++) {\n          var remoteLength = this.peers[i].remoteLength;\n          if (remoteLength > len)\n            len = remoteLength;\n        }\n        return len;\n      }\n    });\n    Object.defineProperty(Feed.prototype, \"stats\", {\n      enumerable: true,\n      get: function() {\n        if (!this._stats)\n          return null;\n        var peerStats = [];\n        for (var i = 0; i < this.peers.length; i++) {\n          var peer = this.peers[i];\n          peerStats[i] = peer.stats;\n        }\n        return {\n          peers: peerStats,\n          totals: this._stats\n        };\n      }\n    });\n    Feed.prototype.replicate = function(initiator, opts) {\n      if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {\n        this.download({ start: 0, end: -1 });\n      }\n      if (isOptions(initiator) && !opts) {\n        opts = initiator;\n        initiator = opts.initiator;\n      }\n      opts = opts || {};\n      opts.stats = !!this._stats;\n      opts.noise = !(opts.noise === false && opts.encrypted === false);\n      return replicate(this, initiator, opts);\n    };\n    Feed.prototype.registerExtension = function(name, handlers) {\n      return this.extensions.add(name, handlers);\n    };\n    Feed.prototype.onextensionupdate = function() {\n      for (const peer of this.peers)\n        peer._updateOptions();\n    };\n    Feed.prototype.setDownloading = function(downloading) {\n      if (this.downloading === downloading && this._downloadingSet)\n        return;\n      this.downloading = downloading;\n      this._downloadingSet = true;\n      this.ready((err) => {\n        if (err)\n          return;\n        for (const peer of this.peers)\n          peer.setDownloading(this.downloading);\n      });\n    };\n    Feed.prototype.setUploading = function(uploading) {\n      if (uploading === this.uploading)\n        return;\n      this.uploading = uploading;\n      this.ready((err) => {\n        if (err)\n          return;\n        for (const peer of this.peers)\n          peer.setUploading(this.uploading);\n      });\n    };\n    Feed.prototype.ready = Feed.prototype.open;\n    Feed.prototype.update = function(opts, cb) {\n      if (typeof opts === \"function\")\n        return this.update(-1, opts);\n      if (typeof opts === \"number\")\n        opts = { minLength: opts };\n      if (!opts)\n        opts = {};\n      if (!cb)\n        cb = noop;\n      var self = this;\n      var len = typeof opts.minLength === \"number\" ? opts.minLength : -1;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        if (len === -1)\n          len = self.length + 1;\n        if (self.length >= len)\n          return cb(null);\n        const ifAvailable = typeof opts.ifAvailable === \"boolean\" ? opts.ifAvailable : self._alwaysIfAvailable;\n        if (ifAvailable && self.writable && !opts.force)\n          return cb(new Error(\"No update available from peers\"));\n        if (self.writable)\n          cb = self._writeStateReloader(cb);\n        var w = {\n          hash: opts.hash !== false,\n          bytes: 0,\n          index: len - 1,\n          options: opts,\n          update: true,\n          callback: cb\n        };\n        self._waiting.push(w);\n        if (ifAvailable)\n          self._ifAvailable(w, len);\n        self._updatePeers();\n      });\n    };\n    Feed.prototype.setExpectedLength = function(len) {\n      this._expectedLength = len;\n      this.ready((err) => {\n        if (err)\n          return;\n        this.ifAvailable.ready(() => {\n          this._expectedLength = -1;\n        });\n        if (this._expectedLength === -1 || this._expectedLength > this.length)\n          return;\n        for (const w of this._waiting) {\n          if (w.update && w.ifAvailable)\n            w.callback(new Error(\"Expected length is less than current length\"));\n        }\n      });\n    };\n    Feed.prototype.truncate = function(newLength, cb) {\n      if (!cb)\n        cb = noop;\n      const self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        self._roots(newLength, function(err2, roots) {\n          if (err2)\n            return cb(err2);\n          const oldLength = self.length;\n          if (oldLength <= newLength)\n            return cb(null);\n          let byteLength = 0;\n          for (const { size } of roots)\n            byteLength += size;\n          for (let i = oldLength; i < newLength; i++)\n            self.data.set(i, false);\n          self.byteLength = byteLength;\n          self.length = newLength;\n          self.tree.truncate(2 * newLength);\n          self._merkle = new MerkleGenerator(crypto, roots);\n          self._sync(null, function(err3) {\n            if (err3)\n              return cb(err3);\n            self._storage.deleteSignatures(newLength, oldLength, cb);\n          });\n        });\n      });\n    };\n    Feed.prototype._ifAvailable = function(w, minLength) {\n      var cb = w.callback;\n      var called = false;\n      var self = this;\n      w.callback = done;\n      w.ifAvailable = true;\n      if (this._expectedLength > -1 && this._expectedLength <= this.length) {\n        return process.nextTick(w.callback, new Error(\"Expected length is less than current length\"));\n      }\n      this.timeouts.update(function() {\n        if (self.closed)\n          return done(new Error(\"Closed\"));\n        process.nextTick(readyNT, self.ifAvailable, function() {\n          if (self.closed)\n            return done(new Error(\"Closed\"));\n          if (self.length >= minLength || self.remoteLength >= minLength)\n            return;\n          done(new Error(\"No update available from peers\"));\n        });\n      });\n      function done(err) {\n        if (called)\n          return;\n        called = true;\n        var i = self._waiting.indexOf(w);\n        if (i > -1)\n          remove(self._waiting, i);\n        cb(err);\n      }\n    };\n    Feed.prototype._ifAvailableGet = function(w) {\n      var cb = w.callback;\n      var called = false;\n      var self = this;\n      w.callback = done;\n      self.timeouts.get(function() {\n        if (self.closed)\n          return done(new Error(\"Closed\"));\n        process.nextTick(readyNT, self.ifAvailable, function() {\n          if (self.closed)\n            return done(new Error(\"Closed\"));\n          for (var i = 0; i < self.peers.length; i++) {\n            var peer = self.peers[i];\n            if (peer.remoteBitfield.get(w.index))\n              return;\n          }\n          done(new Error(\"Block not available from peers\"));\n        });\n      });\n      function done(err, data) {\n        if (called)\n          return;\n        called = true;\n        var i = self._waiting.indexOf(w);\n        if (i > -1)\n          remove(self._waiting, i);\n        cb(err, data);\n      }\n    };\n    Feed.prototype._writeStateReloader = function(cb) {\n      var self = this;\n      return function(err) {\n        if (err)\n          return cb(err);\n        self._reloadMerkleState(cb);\n      };\n    };\n    Feed.prototype._reloadMerkleState = function(cb) {\n      var self = this;\n      this._roots(self.length, function(err, roots) {\n        if (err)\n          return cb(err);\n        self._merkle = new MerkleGenerator(crypto, roots);\n        cb(null);\n      });\n    };\n    Feed.prototype._reloadMerkleStateBeforeAppend = function(work, values, cb) {\n      this._reloadMerkleState(function(err) {\n        if (err)\n          return cb(err);\n        work(values, cb);\n      });\n    };\n    Feed.prototype._open = function(cb) {\n      var self = this;\n      var generatedKey = false;\n      var retryOpen = true;\n      this._storage.openKey(function(_, key) {\n        if (key && !self._overwrite && !self.key)\n          self.key = key;\n        if (!self.key && self.live) {\n          var keyPair = crypto.keyPair();\n          self.secretKey = keyPair.secretKey;\n          self.key = keyPair.publicKey;\n          generatedKey = true;\n        }\n        self.discoveryKey = self.key && crypto.discoveryKey(self.key);\n        self._storage.open({ key: self.key, discoveryKey: self.discoveryKey }, onopen);\n      });\n      function onopen(err, state) {\n        if (err)\n          return cb(err);\n        if (!state.key && state.bitfield.length) {\n          self._overwrite = true;\n        }\n        if (self._force && state.key && self.key && Buffer2.compare(state.key, self.key) !== 0) {\n          self._overwrite = true;\n        }\n        if (self._overwrite) {\n          state.bitfield = [];\n          state.key = state.secretKey = null;\n        }\n        self.bitfield = bitfield(state.bitfieldPageSize, state.bitfield);\n        self.tree = treeIndex(self.bitfield.tree);\n        self.length = self.tree.blocks();\n        self._seq = self.length;\n        if (state.key && self.key && Buffer2.compare(state.key, self.key) !== 0) {\n          return self._forceClose(cb, new Error(\"Another hypercore is stored here\"));\n        }\n        if (state.key)\n          self.key = state.key;\n        if (state.secretKey)\n          self.secretKey = state.secretKey;\n        if (!self.length)\n          return onsignature(null, null);\n        self._storage.getSignature(self.length - 1, onsignature);\n        function onsignature(_, sig) {\n          if (self.length)\n            self.live = !!sig;\n          if ((generatedKey || !self.key) && !self._createIfMissing) {\n            return self._forceClose(cb, new Error(\"No hypercore is stored here\"));\n          }\n          if (!self.key && self.live) {\n            var keyPair = crypto.keyPair();\n            self.secretKey = keyPair.secretKey;\n            self.key = keyPair.publicKey;\n          }\n          var writable = !!self.secretKey || self.key === null;\n          if (!writable && self.writable)\n            return self._forceClose(cb, new Error(\"Feed is not writable\"));\n          self.writable = writable;\n          if (!self._downloadingSet)\n            self.downloading = !writable;\n          self.discoveryKey = self.key && crypto.discoveryKey(self.key);\n          if (self._storeSecretKey && !self.secretKey) {\n            self._storeSecretKey = false;\n          }\n          var shouldWriteKey = generatedKey || !safeBufferEquals(self.key, state.key);\n          var shouldWriteSecretKey = self._storeSecretKey && (generatedKey || !safeBufferEquals(self.secretKey, state.secretKey));\n          var missing = 1 + (shouldWriteKey ? 1 : 0) + (shouldWriteSecretKey ? 1 : 0) + (self._overwrite ? 1 : 0);\n          var error = null;\n          if (shouldWriteKey)\n            self._storage.key.write(0, self.key, done);\n          if (shouldWriteSecretKey)\n            self._storage.secretKey.write(0, self.secretKey, done);\n          if (self._overwrite) {\n            self._storage.bitfield.del(32, Infinity, done);\n          }\n          done(null);\n          function done(err2) {\n            if (err2)\n              error = err2;\n            if (--missing)\n              return;\n            if (error)\n              return self._forceClose(cb, error);\n            self._roots(self.length, onroots);\n          }\n          function onroots(err2, roots) {\n            if (err2 && retryOpen) {\n              retryOpen = false;\n              self.length--;\n              self._storage.getSignature(self.length - 1, onsignature);\n              return;\n            }\n            if (err2)\n              return self._forceClose(cb, err2);\n            self._merkle = new MerkleGenerator(crypto, roots);\n            self.byteLength = roots.reduce(addSize, 0);\n            self.emit(\"ready\");\n            cb(null);\n          }\n        }\n      }\n    };\n    Feed.prototype.download = function(range, cb) {\n      if (typeof range === \"function\")\n        return this.download(null, range);\n      if (typeof range === \"number\")\n        range = { start: range, end: range + 1 };\n      if (Array.isArray(range))\n        range = { blocks: range };\n      if (!range)\n        range = {};\n      if (!cb)\n        cb = noop;\n      if (!this.readable)\n        return cb(new Error(\"Feed is closed\"));\n      if (range.blocks && typeof range.start !== \"number\") {\n        var min = -1;\n        var max = 0;\n        for (var i = 0; i < range.blocks.length; i++) {\n          const blk = range.blocks[i];\n          if (min === -1 || blk < min)\n            min = blk;\n          if (blk >= max)\n            max = blk + 1;\n        }\n        range.start = min === -1 ? 0 : min;\n        range.end = max;\n      }\n      var sel = {\n        _index: this._selections.length,\n        hash: !!range.hash,\n        iterator: null,\n        start: range.start || 0,\n        end: range.end || -1,\n        want: 0,\n        linear: !!range.linear,\n        blocks: range.blocks || null,\n        blocksDownloaded: 0,\n        requested: 0,\n        callback: cb\n      };\n      sel.want = toWantRange(sel.start);\n      this._selections.push(sel);\n      this._updatePeers();\n      return sel;\n    };\n    Feed.prototype.undownload = function(range) {\n      if (typeof range === \"number\")\n        range = { start: range, end: range + 1 };\n      if (!range)\n        range = {};\n      if (range.callback && range._index > -1) {\n        set.remove(this._selections, range);\n        process.nextTick(range.callback, createError(\"ECANCELED\", -11, \"Download was cancelled\"));\n        return;\n      }\n      var start = range.start || 0;\n      var end = range.end || -1;\n      var hash = !!range.hash;\n      var linear = !!range.linear;\n      for (var i = 0; i < this._selections.length; i++) {\n        var s = this._selections[i];\n        if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {\n          set.remove(this._selections, s);\n          process.nextTick(range.callback, createError(\"ECANCELED\", -11, \"Download was cancelled\"));\n          return;\n        }\n      }\n    };\n    Feed.prototype.digest = function(index) {\n      return this.tree.digest(2 * index);\n    };\n    Feed.prototype.proof = function(index, opts, cb) {\n      if (typeof opts === \"function\")\n        return this.proof(index, null, opts);\n      if (!this.opened)\n        return this._readyAndProof(index, opts, cb);\n      if (!opts)\n        opts = {};\n      var proof = this.tree.proof(2 * index, opts);\n      if (!proof)\n        return cb(new Error(\"No proof available for this index\"));\n      var needsSig = this.live && !!proof.verifiedBy;\n      var pending = proof.nodes.length + (needsSig ? 1 : 0);\n      var error = null;\n      var signature = null;\n      var nodes = new Array(proof.nodes.length);\n      if (!pending)\n        return cb(null, { nodes, signature: null });\n      for (var i = 0; i < proof.nodes.length; i++) {\n        this._storage.getNode(proof.nodes[i], onnode);\n      }\n      if (needsSig) {\n        this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature);\n      }\n      function onsignature(err, sig) {\n        if (sig)\n          signature = sig;\n        onnode(err, null);\n      }\n      function onnode(err, node) {\n        if (err)\n          error = err;\n        if (node) {\n          nodes[proof.nodes.indexOf(node.index)] = node;\n        }\n        if (--pending)\n          return;\n        if (error)\n          return cb(error);\n        cb(null, { nodes, signature });\n      }\n    };\n    Feed.prototype._readyAndProof = function(index, opts, cb) {\n      var self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        self.proof(index, opts, cb);\n      });\n    };\n    Feed.prototype.put = function(index, data, proof, cb) {\n      if (!this.opened)\n        return this._readyAndPut(index, data, proof, cb);\n      this._putBuffer(index, data === null ? null : this._codec.encode(data), proof, null, cb);\n    };\n    Feed.prototype.cancel = function(start, end) {\n      if (typeof start !== \"symbol\") {\n        if (!end)\n          end = start + 1;\n        for (var i = this._selections.length - 1; i >= 0; i--) {\n          var sel = this._selections[i];\n          if (start <= sel.start && sel.end <= end) {\n            this.undownload(sel);\n          }\n        }\n      }\n      if (this.opened)\n        this._cancel(start, end);\n      else\n        this._readyAndCancel(start, end);\n    };\n    Feed.prototype._cancel = function(start, end) {\n      var i = 0;\n      if (typeof start === \"symbol\") {\n        for (i = this._waiting.length - 1; i >= 0; i--) {\n          const w2 = this._waiting[i];\n          if (w2.options.cancel === start) {\n            remove(this._waiting, i);\n            this._reserved.set(w2.index, false);\n            if (w2.callback)\n              process.nextTick(w2.callback, new Error(\"Request cancelled\"));\n            this._updatePeers();\n            return;\n          }\n        }\n        return;\n      }\n      for (i = start; i < end; i++) {\n        this._reserved.set(i, false);\n      }\n      for (i = this._waiting.length - 1; i >= 0; i--) {\n        var w = this._waiting[i];\n        if (start <= w.start && w.end <= end || start <= w.index && w.index < end) {\n          remove(this._waiting, i);\n          if (w.callback)\n            process.nextTick(w.callback, new Error(\"Request cancelled\"));\n        }\n      }\n    };\n    Feed.prototype.clear = function(start, end, opts, cb) {\n      if (typeof end === \"function\")\n        return this.clear(start, start + 1, null, end);\n      if (typeof opts === \"function\")\n        return this.clear(start, end, null, opts);\n      if (!opts)\n        opts = {};\n      if (!end)\n        end = start + 1;\n      if (!cb)\n        cb = noop;\n      var self = this;\n      var byteOffset = start === 0 ? 0 : typeof opts.byteOffset === \"number\" ? opts.byteOffset : -1;\n      var byteLength = typeof opts.byteLength === \"number\" ? opts.byteLength : -1;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        var modified = false;\n        for (var i = start; i < end; i++) {\n          if (self.bitfield.set(i, false))\n            modified = true;\n        }\n        if (!modified)\n          return process.nextTick(cb);\n        self._unannounce({ start, length: end - start });\n        if (opts.delete === false || self._indexing)\n          return sync();\n        if (byteOffset > -1)\n          return onstartbytes(null, byteOffset);\n        self._storage.dataOffset(start, [], onstartbytes);\n        function sync() {\n          self.emit(\"clear\", start, end);\n          self._sync(null, cb);\n        }\n        function onstartbytes(err2, offset) {\n          if (err2)\n            return cb(err2);\n          byteOffset = offset;\n          if (byteLength > -1)\n            return onendbytes(null, byteLength + byteOffset);\n          if (end === self.length)\n            return onendbytes(null, self.byteLength);\n          self._storage.dataOffset(end, [], onendbytes);\n        }\n        function onendbytes(err2, end2) {\n          if (err2)\n            return cb(err2);\n          if (!self._storage.data.del)\n            return sync();\n          self._storage.data.del(byteOffset, end2 - byteOffset, sync);\n        }\n      });\n    };\n    Feed.prototype.signature = function(index, cb) {\n      if (typeof index === \"function\")\n        return this.signature(this.length - 1, index);\n      if (index < 0 || index >= this.length)\n        return cb(new Error(\"No signature available for this index\"));\n      this._storage.nextSignature(index, cb);\n    };\n    Feed.prototype.verify = function(index, signature, cb) {\n      var self = this;\n      this.rootHashes(index, function(err, roots) {\n        if (err)\n          return cb(err);\n        var checksum = crypto.signable(roots, index + 1);\n        verifyCompat(self, checksum, signature, function(err2, valid) {\n          if (err2)\n            return cb(err2);\n          if (!valid)\n            return cb(new Error(\"Signature verification failed\"));\n          return cb(null, true);\n        });\n      });\n    };\n    Feed.prototype.rootHashes = function(index, cb) {\n      this._getRootsToVerify(index * 2 + 2, {}, [], cb);\n    };\n    Feed.prototype.seek = function(bytes, opts, cb) {\n      if (typeof opts === \"function\")\n        return this.seek(bytes, null, opts);\n      if (!opts)\n        opts = {};\n      if (!this.opened)\n        return this._readyAndSeek(bytes, opts, cb);\n      var self = this;\n      if (bytes === this.byteLength)\n        return process.nextTick(cb, null, this.length, 0);\n      this._seek(bytes, function(err, index, offset) {\n        if (!err && isBlock(index))\n          return done(index / 2, offset);\n        if (opts.wait === false)\n          return cb(err || new Error(\"Unable to seek to this offset\"));\n        var start = opts.start || 0;\n        var end = opts.end || -1;\n        if (!err) {\n          var left = flat.leftSpan(index) / 2;\n          var right = flat.rightSpan(index) / 2 + 1;\n          if (left > start)\n            start = left;\n          if (right < end || end === -1)\n            end = right;\n        }\n        if (end > -1 && end <= start)\n          return cb(new Error(\"Unable to seek to this offset\"));\n        var w = {\n          hash: opts.hash !== false,\n          bytes,\n          index: -1,\n          ifAvailable: opts && typeof opts.ifAvailable === \"boolean\" ? opts.ifAvailable : self._alwaysIfAvailable,\n          start,\n          end,\n          want: toWantRange(start),\n          requested: 0,\n          callback: cb || noop\n        };\n        self._waiting.push(w);\n        self._updatePeers();\n        if (w.ifAvailable)\n          self._ifAvailableSeek(w);\n      });\n      function done(index, offset) {\n        for (var i = 0; i < self.peers.length; i++) {\n          self.peers[i].haveBytes(bytes);\n        }\n        cb(null, index, offset);\n      }\n    };\n    Feed.prototype._ifAvailableSeek = function(w) {\n      var self = this;\n      var cb = w.callback;\n      self.timeouts.get(function() {\n        if (self.closed)\n          return done(new Error(\"Closed\"));\n        process.nextTick(readyNT, self.ifAvailable, function() {\n          if (self.closed)\n            return done(new Error(\"Closed\"));\n          let available = false;\n          for (const peer of self.peers) {\n            const ite = peer._iterator;\n            let i = ite.seek(w.start).next(true);\n            while (self.tree.get(i * 2) && i > -1)\n              i = ite.next(true);\n            if (i > -1 && (w.end === -1 || i < w.end)) {\n              available = true;\n              break;\n            }\n          }\n          if (!available)\n            done(new Error(\"Seek not available from peers\"));\n        });\n      });\n      function done(err) {\n        var i = self._waiting.indexOf(w);\n        if (i > -1) {\n          remove(self._waiting, i);\n          w.callback = noop;\n          cb(err);\n        }\n      }\n    };\n    Feed.prototype._seek = function(offset, cb) {\n      if (offset === 0)\n        return cb(null, 0, 0);\n      var self = this;\n      var roots = flat.fullRoots(this.length * 2);\n      var nearestRoot = 0;\n      loop(null, null);\n      function onroot(top) {\n        if (isBlock(top))\n          return cb(null, nearestRoot, offset);\n        var left = flat.leftChild(top);\n        while (!self.tree.get(left)) {\n          if (isBlock(left))\n            return cb(null, nearestRoot, offset);\n          left = flat.leftChild(left);\n        }\n        self._storage.getNode(left, onleftchild);\n      }\n      function onleftchild(err, node) {\n        if (err)\n          return cb(err);\n        if (node.size > offset) {\n          nearestRoot = node.index;\n          onroot(node.index);\n        } else {\n          offset -= node.size;\n          if (flat.parent(node.index) === nearestRoot) {\n            nearestRoot = flat.sibling(node.index);\n            onroot(nearestRoot);\n          } else {\n            onroot(flat.sibling(node.index));\n          }\n        }\n      }\n      function loop(err, node) {\n        if (err)\n          return cb(err);\n        if (node) {\n          if (node.size > offset) {\n            nearestRoot = node.index;\n            return onroot(node.index);\n          }\n          offset -= node.size;\n        }\n        if (!roots.length)\n          return cb(new Error(\"Out of bounds\"));\n        self._storage.getNode(roots.shift(), loop);\n      }\n    };\n    Feed.prototype._readyAndSeek = function(bytes, opts, cb) {\n      var self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        self.seek(bytes, opts, cb);\n      });\n    };\n    Feed.prototype._getBuffer = function(index, cb) {\n      this._storage.getData(index, cb);\n    };\n    Feed.prototype._putBuffer = function(index, data, proof, from, cb) {\n      var self = this;\n      var trusted = -1;\n      var missing = [];\n      var next = 2 * index;\n      var i = data ? 0 : 1;\n      while (true) {\n        if (this.tree.get(next)) {\n          trusted = next;\n          break;\n        }\n        var sib = flat.sibling(next);\n        next = flat.parent(next);\n        if (i < proof.nodes.length && proof.nodes[i].index === sib) {\n          i++;\n          continue;\n        }\n        if (!this.tree.get(sib))\n          break;\n        missing.push(sib);\n      }\n      if (trusted === -1 && this.tree.get(next))\n        trusted = next;\n      var error = null;\n      var trustedNode = null;\n      var missingNodes = new Array(missing.length);\n      var pending = missing.length + (trusted > -1 ? 1 : 0);\n      for (i = 0; i < missing.length; i++)\n        this._storage.getNode(missing[i], onmissing);\n      if (trusted > -1)\n        this._storage.getNode(trusted, ontrusted);\n      if (!missing.length && trusted === -1)\n        onmissingloaded(null);\n      function ontrusted(err, node) {\n        if (err)\n          error = err;\n        if (node)\n          trustedNode = node;\n        if (!--pending)\n          onmissingloaded(error);\n      }\n      function onmissing(err, node) {\n        if (err)\n          error = err;\n        if (node)\n          missingNodes[missing.indexOf(node.index)] = node;\n        if (!--pending)\n          onmissingloaded(error);\n      }\n      function onmissingloaded(err) {\n        if (err)\n          return cb(err);\n        self._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb);\n      }\n    };\n    Feed.prototype._readyAndPut = function(index, data, proof, cb) {\n      var self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        self.put(index, data, proof, cb);\n      });\n    };\n    Feed.prototype._write = function(index, data, nodes, sig, from, cb) {\n      if (!this._onwrite)\n        return this._writeAfterHook(index, data, nodes, sig, from, cb);\n      this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb));\n    };\n    function writeHookDone(self, index, data, nodes, sig, from, cb) {\n      return function(err) {\n        if (err)\n          return cb(err);\n        self._writeAfterHook(index, data, nodes, sig, from, cb);\n      };\n    }\n    Feed.prototype._writeAfterHook = function(index, data, nodes, sig, from, cb) {\n      var self = this;\n      var pending = nodes.length + 1 + (sig ? 1 : 0);\n      var error = null;\n      for (var i = 0; i < nodes.length; i++)\n        this._storage.putNode(nodes[i].index, nodes[i], ondone);\n      if (data)\n        this._storage.putData(index, data, nodes, ondone);\n      else\n        ondone();\n      if (sig)\n        this._storage.putSignature(sig.index, sig.signature, ondone);\n      function ondone(err) {\n        if (err)\n          error = err;\n        if (--pending)\n          return;\n        if (error)\n          return cb(error);\n        self._writeDone(index, data, nodes, from, cb);\n      }\n    };\n    Feed.prototype._writeDone = function(index, data, nodes, from, cb) {\n      for (var i = 0; i < nodes.length; i++)\n        this.tree.set(nodes[i].index);\n      this.tree.set(2 * index);\n      if (data) {\n        if (this.bitfield.set(index, true)) {\n          if (this._stats) {\n            this._stats.downloadedBlocks += 1;\n            this._stats.downloadedBytes += data.length;\n          }\n          this.emit(\"download\", index, data, from);\n        }\n        if (this.peers.length)\n          this._announce({ start: index }, from);\n        if (!this.writable) {\n          if (!this._synced)\n            this._synced = this.bitfield.iterator(0, this.length);\n          if (this._synced.next() === -1) {\n            this._synced.range(0, this.length);\n            this._synced.seek(0);\n            if (this._synced.next() === -1) {\n              this.emit(\"sync\");\n            }\n          }\n        }\n      }\n      this._sync(null, cb);\n    };\n    Feed.prototype._verifyAndWrite = function(index, data, proof, localNodes, trustedNode, from, cb) {\n      var visited = [];\n      var remoteNodes = proof.nodes;\n      var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift();\n      if (verifyNode(trustedNode, top)) {\n        this._write(index, data, visited, null, from, cb);\n        return;\n      }\n      while (true) {\n        var node = null;\n        var next = flat.sibling(top.index);\n        if (remoteNodes.length && remoteNodes[0].index === next) {\n          node = remoteNodes.shift();\n          visited.push(node);\n        } else if (localNodes.length && localNodes[0].index === next) {\n          node = localNodes.shift();\n        } else {\n          this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb);\n          return;\n        }\n        visited.push(top);\n        top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size);\n        if (verifyNode(trustedNode, top)) {\n          this._write(index, data, visited, null, from, cb);\n          return;\n        }\n      }\n    };\n    Feed.prototype._verifyRootsAndWrite = function(index, data, top, proof, nodes, from, cb) {\n      var remoteNodes = proof.nodes;\n      var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index;\n      var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2;\n      var length = verifiedBy / 2;\n      var self = this;\n      this._getRootsToVerify(verifiedBy, top, remoteNodes, function(err, roots, extraNodes) {\n        if (err)\n          return cb(err);\n        var checksum = crypto.signable(roots, length);\n        var signature = null;\n        if (self.length && self.live && !proof.signature) {\n          return cb(new Error(\"Remote did not include a signature\"));\n        }\n        if (proof.signature) {\n          verifyCompat(self, checksum, proof.signature, function(err2, valid) {\n            if (err2)\n              return cb(err2);\n            if (!valid)\n              return cb(new Error(\"Remote signature could not be verified\"));\n            signature = { index: verifiedBy / 2 - 1, signature: proof.signature };\n            write();\n          });\n        } else {\n          if (Buffer2.compare(checksum.slice(0, 32), self.key) !== 0) {\n            return cb(new Error(\"Remote checksum failed\"));\n          }\n          write();\n        }\n        function write() {\n          self.live = !!signature;\n          if (length > self.length) {\n            if (self.writable)\n              self._merkle = null;\n            self.length = length;\n            self._seq = length;\n            self.byteLength = roots.reduce(addSize, 0);\n            if (self._synced)\n              self._synced.seek(0, self.length);\n            self.emit(\"append\");\n          }\n          self._write(index, data, nodes.concat(extraNodes), signature, from, cb);\n        }\n      });\n    };\n    Feed.prototype._getRootsToVerify = function(verifiedBy, top, remoteNodes, cb) {\n      var indexes = flat.fullRoots(verifiedBy);\n      var roots = new Array(indexes.length);\n      var nodes = [];\n      var error = null;\n      var pending = roots.length;\n      for (var i = 0; i < indexes.length; i++) {\n        if (indexes[i] === top.index) {\n          nodes.push(top);\n          onnode(null, top);\n        } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {\n          nodes.push(remoteNodes[0]);\n          onnode(null, remoteNodes.shift());\n        } else if (this.tree.get(indexes[i])) {\n          this._storage.getNode(indexes[i], onnode);\n        } else {\n          onnode(new Error(\"Missing tree roots needed for verify\"));\n        }\n      }\n      function onnode(err, node) {\n        if (err)\n          error = err;\n        if (node)\n          roots[indexes.indexOf(node.index)] = node;\n        if (!--pending)\n          done(error);\n      }\n      function done(err) {\n        if (err)\n          return cb(err);\n        cb(null, roots, nodes);\n      }\n    };\n    Feed.prototype._announce = function(message, from) {\n      for (var i = 0; i < this.peers.length; i++) {\n        var peer = this.peers[i];\n        if (peer !== from)\n          peer.have(message);\n      }\n    };\n    Feed.prototype._unannounce = function(message) {\n      for (var i = 0; i < this.peers.length; i++)\n        this.peers[i].unhave(message);\n    };\n    Feed.prototype.downloaded = function(start, end, cb) {\n      const count = this.bitfield.total(start, end);\n      if (cb)\n        process.nextTick(cb, null, count);\n      return count;\n    };\n    Feed.prototype.has = function(start, end, cb) {\n      if (typeof end === \"function\")\n        return this.has(start, void 0, end);\n      if (end === void 0) {\n        const res2 = this.bitfield.get(start);\n        if (cb)\n          process.nextTick(cb, null, res2);\n        return res2;\n      }\n      const total = end - start;\n      const res = total === this.bitfield.total(start, end);\n      if (cb)\n        process.nextTick(cb, null, res);\n      return res;\n    };\n    Feed.prototype.getBlockInfo = function(index, cb) {\n      var self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        self._storage.getNode(2 * index, cb);\n      });\n    };\n    Feed.prototype.head = function(opts, cb) {\n      if (typeof opts === \"function\")\n        return this.head({}, opts);\n      var self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        if (opts && opts.update)\n          self.update(opts, onupdate);\n        else\n          process.nextTick(onupdate);\n      });\n      function onupdate() {\n        if (self.length === 0)\n          cb(new Error(\"feed is empty\"));\n        else\n          self.get(self.length - 1, opts, cb);\n      }\n    };\n    Feed.prototype.get = function(index, opts, cb) {\n      if (typeof opts === \"function\")\n        return this.get(index, null, opts);\n      opts = { ...opts };\n      if (!opts.cancel)\n        opts.cancel = Symbol(\"hypercore-get\");\n      if (!this.opened)\n        return this._readyAndGet(index, opts, cb);\n      if (!this.readable) {\n        process.nextTick(cb, new Error(\"Feed is closed\"));\n        return opts.cancel;\n      }\n      if (opts.timeout)\n        cb = timeoutCallback(cb, opts.timeout);\n      if (!this.bitfield.get(index)) {\n        if (opts && opts.wait === false)\n          return process.nextTick(cb, new Error(\"Block not downloaded\"));\n        var w = { bytes: 0, hash: false, index, options: opts, requested: 0, callback: cb };\n        this._waiting.push(w);\n        if (opts && typeof opts.ifAvailable === \"boolean\" ? opts.ifAvailable : this._alwaysIfAvailable)\n          this._ifAvailableGet(w);\n        this._updatePeers();\n        if (opts.onwait) {\n          const onwait = opts.onwait;\n          opts.onwait = null;\n          onwait(index);\n        }\n        return opts.cancel;\n      }\n      if (opts && opts.valueEncoding)\n        cb = wrapCodec(toCodec(opts.valueEncoding), cb);\n      else if (this._codec !== codecs.binary)\n        cb = wrapCodec(this._codec, cb);\n      this._getBuffer(index, cb);\n      return opts.cancel;\n    };\n    Feed.prototype._readyAndGet = function(index, opts, cb) {\n      var self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        self.get(index, opts, cb);\n      });\n      return opts.cancel;\n    };\n    Feed.prototype.getBatch = function(start, end, opts, cb) {\n      if (typeof opts === \"function\")\n        return this.getBatch(start, end, null, opts);\n      if (!this.opened)\n        return this._readyAndGetBatch(start, end, opts, cb);\n      var self = this;\n      var wait = !opts || opts.wait !== false;\n      if (this.has(start, end))\n        return this._getBatch(start, end, opts, cb);\n      if (!wait)\n        return process.nextTick(cb, new Error(\"Block not downloaded\"));\n      if (opts && opts.timeout)\n        cb = timeoutCallback(cb, opts.timeout);\n      this.download({ start, end }, function(err) {\n        if (err)\n          return cb(err);\n        self._getBatch(start, end, opts, cb);\n      });\n    };\n    Feed.prototype._getBatch = function(start, end, opts, cb) {\n      var enc = opts && opts.valueEncoding;\n      var codec = enc ? toCodec(enc) : this._codec;\n      this._storage.getDataBatch(start, end - start, onbatch);\n      function onbatch(err, buffers) {\n        if (err)\n          return cb(err);\n        var batch = new Array(buffers.length);\n        for (var i = 0; i < buffers.length; i++) {\n          try {\n            batch[i] = codec ? codec.decode(buffers[i]) : buffers[i];\n          } catch (err2) {\n            return cb(err2);\n          }\n        }\n        cb(null, batch);\n      }\n    };\n    Feed.prototype._readyAndGetBatch = function(start, end, opts, cb) {\n      var self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        self.getBatch(start, end, opts, cb);\n      });\n    };\n    Feed.prototype._updatePeers = function() {\n      for (var i = 0; i < this.peers.length; i++)\n        this.peers[i].update();\n    };\n    Feed.prototype.createWriteStream = function(opts) {\n      return new WriteStream(this, opts);\n    };\n    Feed.prototype.createReadStream = function(opts) {\n      return new ReadStream(this, opts);\n    };\n    Feed.prototype.finalize = function(cb) {\n      if (!this.key) {\n        this.key = crypto.tree(this._merkle.roots);\n        this.discoveryKey = crypto.discoveryKey(this.key);\n      }\n      this._storage.key.write(0, this.key, cb);\n    };\n    Feed.prototype.append = function(batch, cb) {\n      if (!cb)\n        cb = noop;\n      var self = this;\n      var list = Array.isArray(batch) ? batch : [batch];\n      this._batch(list, onappend);\n      function onappend(err) {\n        if (err)\n          return cb(err);\n        var seq = self._seq;\n        self._seq += list.length;\n        cb(null, seq);\n      }\n    };\n    Feed.prototype.flush = function(cb) {\n      this.append([], cb);\n    };\n    Feed.prototype.destroyStorage = function(cb) {\n      const self = this;\n      this.close(function(err) {\n        if (err)\n          cb(err);\n        else\n          self._storage.destroy(cb);\n      });\n    };\n    Feed.prototype._close = function(cb) {\n      const self = this;\n      for (const peer of this.peers) {\n        if (!peer._destroyed)\n          peer._close();\n      }\n      this._forceClose(onclose, null);\n      function onclose(err) {\n        if (!err)\n          self.emit(\"close\");\n        cb(err);\n      }\n    };\n    Feed.prototype._forceClose = function(cb, error) {\n      var self = this;\n      this.writable = false;\n      this.readable = false;\n      this._storage.close(function(err) {\n        if (!err)\n          err = error;\n        self._destroy(err || new Error(\"Feed is closed\"));\n        cb(err);\n      });\n    };\n    Feed.prototype._destroy = function(err) {\n      this.ifAvailable.destroy();\n      while (this._waiting.length) {\n        this._waiting.pop().callback(err);\n      }\n      while (this._selections.length) {\n        this._selections.pop().callback(err);\n      }\n    };\n    Feed.prototype._appendHook = function(batch, cb) {\n      var self = this;\n      var missing = batch.length;\n      var error = null;\n      if (!missing)\n        return this._append(batch, cb);\n      for (var i = 0; i < batch.length; i++) {\n        this._onwrite(i + this.length, batch[i], null, done);\n      }\n      function done(err) {\n        if (err)\n          error = err;\n        if (--missing)\n          return;\n        if (error)\n          return cb(error);\n        self._append(batch, cb);\n      }\n    };\n    Feed.prototype._append = function(batch, cb) {\n      if (!this.opened)\n        return this._readyAndAppend(batch, cb);\n      if (!this.writable)\n        return cb(new Error(\"This feed is not writable. Did you create it?\"));\n      var self = this;\n      var pending = 1;\n      var offset = 0;\n      var error = null;\n      var nodeBatch = new Array(batch.length ? batch.length * 2 - 1 : 0);\n      var nodeOffset = this.length * 2;\n      var dataBatch = new Array(batch.length);\n      if (!pending)\n        return cb();\n      for (var i = 0; i < batch.length; i++) {\n        var data = this._codec.encode(batch[i]);\n        var nodes = this._merkle.next(data);\n        if (data.length > 8388608)\n          return cb(new Error(\"Individual blocks has be less than 8MB\"));\n        offset += data.length;\n        dataBatch[i] = data;\n        for (var j = 0; j < nodes.length; j++) {\n          var node = nodes[j];\n          if (node.index >= nodeOffset && node.index - nodeOffset < nodeBatch.length) {\n            nodeBatch[node.index - nodeOffset] = node;\n          } else {\n            pending++;\n            this._storage.putNode(node.index, node, done);\n          }\n        }\n      }\n      if (this.live && batch.length) {\n        pending++;\n        this.crypto.sign(crypto.signable(this._merkle.roots, self.length + batch.length), this.secretKey, function(err, sig) {\n          if (err)\n            return done(err);\n          self._storage.putSignature(self.length + batch.length - 1, sig, done);\n        });\n      }\n      if (!this._indexing) {\n        pending++;\n        if (dataBatch.length === 1)\n          this._storage.data.write(this.byteLength, dataBatch[0], done);\n        else\n          this._storage.data.write(this.byteLength, Buffer2.concat(dataBatch), done);\n      }\n      this._storage.putNodeBatch(nodeOffset, nodeBatch, done);\n      function done(err) {\n        if (err)\n          error = err;\n        if (--pending)\n          return;\n        if (error)\n          return cb(error);\n        var start = self.length;\n        self.byteLength += offset;\n        for (var i2 = 0; i2 < batch.length; i2++) {\n          self.bitfield.set(self.length, true);\n          self.tree.set(2 * self.length++);\n        }\n        self.emit(\"append\");\n        var message = self.length - start > 1 ? { start, length: self.length - start } : { start };\n        if (self.peers.length)\n          self._announce(message);\n        self._sync(null, cb);\n      }\n    };\n    Feed.prototype._readyAndAppend = function(batch, cb) {\n      var self = this;\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        self._append(batch, cb);\n      });\n    };\n    Feed.prototype._readyAndCancel = function(start, end) {\n      var self = this;\n      this.ready(function() {\n        self._cancel(start, end);\n      });\n    };\n    Feed.prototype._pollWaiting = function() {\n      var len = this._waiting.length;\n      for (var i = 0; i < len; i++) {\n        var next = this._waiting[i];\n        if (!next.bytes && !this.bitfield.get(next.index) && (!next.hash || !this.tree.get(next.index * 2))) {\n          continue;\n        }\n        remove(this._waiting, i--);\n        len--;\n        if (next.bytes)\n          this.seek(next.bytes, next, next.callback);\n        else if (next.update)\n          this.update(next.index + 1, next.callback);\n        else\n          this.get(next.index, next.options, next.callback);\n      }\n    };\n    Feed.prototype._syncBitfield = function(cb) {\n      var missing = this.bitfield.pages.updates.length;\n      var next = null;\n      var error = null;\n      if (!missing) {\n        this._pollWaiting();\n        return cb(null);\n      }\n      while ((next = this.bitfield.pages.lastUpdate()) !== null) {\n        this._storage.putBitfield(next.offset, next.buffer, ondone);\n      }\n      this._pollWaiting();\n      function ondone(err) {\n        if (err)\n          error = err;\n        if (--missing)\n          return;\n        cb(error);\n      }\n    };\n    Feed.prototype._roots = function(index, cb) {\n      var roots = flat.fullRoots(2 * index);\n      var result = new Array(roots.length);\n      var pending = roots.length;\n      var error = null;\n      if (!pending)\n        return cb(null, result);\n      for (var i = 0; i < roots.length; i++) {\n        this._storage.getNode(roots[i], onnode);\n      }\n      function onnode(err, node) {\n        if (err)\n          error = err;\n        if (node)\n          result[roots.indexOf(node.index)] = node;\n        if (--pending)\n          return;\n        if (error)\n          return cb(error);\n        cb(null, result);\n      }\n    };\n    Feed.prototype.audit = function(cb) {\n      if (!cb)\n        cb = noop;\n      var self = this;\n      var report = {\n        valid: 0,\n        invalid: 0\n      };\n      this.ready(function(err) {\n        if (err)\n          return cb(err);\n        var block = 0;\n        var max = self.length;\n        next();\n        function onnode(err2, node) {\n          if (err2)\n            return ondata(null, null);\n          self._storage.getData(block, ondata);\n          function ondata(_, data) {\n            var verified = data && crypto.data(data).equals(node.hash);\n            if (verified)\n              report.valid++;\n            else\n              report.invalid++;\n            self.bitfield.set(block, verified);\n            block++;\n            next();\n          }\n        }\n        function next() {\n          while (block < max && !self.bitfield.get(block))\n            block++;\n          if (block >= max)\n            return done();\n          self._storage.getNode(2 * block, onnode);\n        }\n        function done() {\n          self._sync(null, function(err2) {\n            if (err2)\n              return cb(err2);\n            cb(null, report);\n          });\n        }\n      });\n    };\n    Feed.prototype.extension = function(name, message) {\n      var peers = this.peers;\n      for (var i = 0; i < peers.length; i++) {\n        peers[i].extension(name, message);\n      }\n    };\n    function noop() {\n    }\n    function verifyNode(trusted, node) {\n      return trusted && trusted.index === node.index && Buffer2.compare(trusted.hash, node.hash) === 0;\n    }\n    function addSize(size, node) {\n      return size + node.size;\n    }\n    function isBlock(index) {\n      return (index & 1) === 0;\n    }\n    function toCodec(enc) {\n      return codecs(enc === \"json\" ? \"ndjson\" : enc);\n    }\n    function wrapCodec(enc, cb) {\n      return function(err, buf) {\n        if (err)\n          return cb(err);\n        try {\n          buf = enc.decode(buf);\n        } catch (err2) {\n          return cb(err2);\n        }\n        cb(null, buf);\n      };\n    }\n    function timeoutCallback(cb, timeout) {\n      var failed = false;\n      var id = setTimeout(ontimeout, timeout);\n      return done;\n      function ontimeout() {\n        failed = true;\n        var err = new Error(\"ETIMEDOUT\");\n        err.code = \"ETIMEDOUT\";\n        cb(err);\n      }\n      function done(err, val2) {\n        if (failed)\n          return;\n        clearTimeout(id);\n        cb(err, val2);\n      }\n    }\n    function toWantRange(i) {\n      return Math.floor(i / 1024 / 1024) * 1024 * 1024;\n    }\n    function createError(code, errno, msg) {\n      var err = new Error(msg);\n      err.code = code;\n      err.errno = errno;\n      return err;\n    }\n    function defaultStorageDir(directory) {\n      return function(name) {\n        return defaultStorage(name, { directory });\n      };\n    }\n    function isOptions(initiator) {\n      return !Protocol.isProtocolStream(initiator) && typeof initiator === \"object\" && !!initiator && typeof initiator.initiator === \"boolean\";\n    }\n    function readyNT(ifAvailable, fn) {\n      ifAvailable.ready(fn);\n    }\n    function verifyCompat(self, checksum, signature, cb) {\n      self.crypto.verify(checksum, signature, self.key, function(err, valid) {\n        if (err || valid)\n          return cb(err, valid);\n        self.crypto.verify(checksum.slice(0, 32), signature, self.key, cb);\n      });\n    }\n  }\n});\n\n// packages/common/hypercore/src/index.ts\ninit_inject_globals();\nvar import_hypercore2 = __toESM(require_hypercore());\n\n// packages/common/hypercore/src/crypto.ts\ninit_inject_globals();\nimport { callbackify } from \"@dxos/node-std/util\";\nimport { verifySignature } from \"@dxos/crypto\";\nimport { invariant } from \"@dxos/invariant\";\nimport { arrayToBuffer } from \"@dxos/util\";\nvar __dxlog_file = \"/home/runner/work/dxos/dxos/packages/common/hypercore/src/crypto.ts\";\nvar createCodecEncoding = (codec, opts) => ({\n  encode: (obj) => arrayToBuffer(codec.encode(obj, opts)),\n  decode: (buffer) => codec.decode(buffer, opts)\n});\nvar createCrypto = (signer, publicKey) => {\n  invariant(signer, void 0, {\n    F: __dxlog_file,\n    L: 27,\n    S: void 0,\n    A: [\n      \"signer\",\n      \"\"\n    ]\n  });\n  invariant(publicKey, void 0, {\n    F: __dxlog_file,\n    L: 28,\n    S: void 0,\n    A: [\n      \"publicKey\",\n      \"\"\n    ]\n  });\n  return {\n    sign: (message, secretKey, cb) => {\n      callbackify(signer.sign.bind(signer))(publicKey, message, (err, result) => {\n        if (err) {\n          cb(err, null);\n          return;\n        }\n        cb(null, arrayToBuffer(result));\n      });\n    },\n    verify: async (message, signature, key, cb) => {\n      callbackify(verifySignature)(publicKey, message, signature, cb);\n    }\n  };\n};\n\n// packages/common/hypercore/src/defaults.ts\ninit_inject_globals();\nvar defaultFeedOptions = {\n  createIfMissing: true,\n  valueEncoding: \"binary\"\n};\nvar defaultReadStreamOptions = {\n  start: 0,\n  end: Infinity,\n  snapshot: true,\n  tail: false,\n  live: false,\n  timeout: 0,\n  wait: true,\n  batch: 1\n};\nvar defaultWriteStreamOptions = {\n  maxBlockSize: Infinity\n};\nvar defaultReplicateOptions = {\n  live: false,\n  ack: false,\n  download: true,\n  upload: true,\n  encrypted: true,\n  noise: true\n};\n\n// packages/common/hypercore/src/hypercore-factory.ts\ninit_inject_globals();\nvar import_hypercore = __toESM(require_hypercore());\nimport { invariant as invariant2 } from \"@dxos/invariant\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\n\n// packages/common/hypercore/src/util.ts\ninit_inject_globals();\nimport util from \"@dxos/node-std/util\";\nvar py = (obj, fn) => util.promisify(fn.bind(obj));\n\n// packages/common/hypercore/src/hypercore-factory.ts\nvar __dxlog_file2 = \"/home/runner/work/dxos/dxos/packages/common/hypercore/src/hypercore-factory.ts\";\nvar HypercoreFactory = class {\n  constructor(_root = createStorage({\n    type: StorageType.RAM\n  }).createDirectory(), _options) {\n    this._root = _root;\n    this._options = _options;\n    invariant2(this._root, void 0, {\n      F: __dxlog_file2,\n      L: 21,\n      S: this,\n      A: [\n        \"this._root\",\n        \"\"\n      ]\n    });\n  }\n  /**\n  * Creates a feed using a storage factory prefixed with the feed's key.\n  * NOTE: We have to use our `random-access-storage` implementation since the native ones\n  * do not behave uniformly across platforms.\n  */\n  createFeed(publicKey, options) {\n    const directory = this._root.createDirectory(publicKey.toString(\"hex\"));\n    const storage = (filename) => directory.getOrCreateFile(filename).native;\n    return (0, import_hypercore.default)(storage, publicKey, Object.assign({}, this._options, options));\n  }\n  /**\n  * Creates and opens a feed.\n  */\n  async openFeed(publicKey, options) {\n    const feed = this.createFeed(publicKey, options);\n    await py(feed, feed.open)();\n    return feed;\n  }\n};\n\n// packages/common/hypercore/src/iterator.ts\ninit_inject_globals();\nimport { Readable } from \"readable-stream\";\nvar createReadable = (stream) => {\n  return new Readable({\n    objectMode: true\n  }).wrap(stream);\n};\nvar createAsyncIterator = (stream) => {\n  return stream[Symbol.asyncIterator]();\n};\nvar export_hypercore = import_hypercore2.default;\nexport {\n  HypercoreFactory,\n  createAsyncIterator,\n  createCodecEncoding,\n  createCrypto,\n  createReadable,\n  defaultFeedOptions,\n  defaultReadStreamOptions,\n  defaultReplicateOptions,\n  defaultWriteStreamOptions,\n  export_hypercore as hypercore\n};\n//# sourceMappingURL=index.mjs.map\n"],"file":"index.js"}